{
  "id": "conceptual-project",
  "name": "Codebase Concept Extraction and Visualization",
  "summary": "A system that scans source code repositories, extracts meaningful symbols and snippets, and uses large language models to generate Dubberly-style concept models that can be published to a viewer.",
  "description": "This system analyzes software repositories to discover important domain concepts and relationships embedded in code. It scans files, extracts language-level symbols and snippets, and calls an LLM to synthesize higher-level concept models. These models are organized into projects and views that can be registered, stored, and published to a viewer for exploration by designers, architects, and product stakeholders.",
  "models": [
    {
      "id": "repo-analysis",
      "title": "Repository Analysis & Symbol Extraction",
      "description": "This model covers how a source code repository is scanned and transformed into a structured representation of files, symbols, and snippets that can be used for further conceptual analysis.",
      "concepts": [
        {
          "id": "source-repository",
          "label": "Source code repository",
          "category": "thing",
          "description": "A collection of source files (e.g., a Git repository) that is analyzed to discover domain-relevant structures and behaviors.",
          "aliases": [
            "repository",
            "repo",
            "repoRoot",
            "source repo",
            "code repository"
          ],
          "notes": "A source code repository is the root directory of a codebase that is scanned to discover relevant source files for further analysis. In this model, it is treated as a filesystem root path (repoRoot) that may contain a conventional source subdirectory (e.g., 'src') and optional ignore configuration (e.g., .gitignore). The repository is the scope boundary for repository analysis and symbol extraction activities."
        },
        {
          "id": "file",
          "label": "Source file",
          "category": "thing",
          "description": "An individual file within a repository that contains code to be scanned for symbols and snippets.",
          "aliases": [
            "file",
            "source file",
            "FileInfo",
            "scanned file"
          ],
          "notes": "In this model, a source file is any file within a source code repository that matches the configured extensions and is not excluded by ignore rules. It is represented operationally by the FileInfo structure, which captures its absolute path, repository-relative path, and size. Source files are the primary units scanned during repository analysis and are later used to extract code snippets and symbols."
        },
        {
          "id": "code-snippet",
          "label": "Code snippet",
          "category": "thing",
          "description": "A selected portion of a source file that is extracted to provide focused context for conceptual analysis.",
          "aliases": [
            "FileSnippet",
            "snippet"
          ],
          "notes": "A code snippet is a short excerpt of a source file’s contents, captured as plain text along with the file’s relative path. In this model, snippets are created by selecting a subset of files (typically smaller ones) from a repository and truncating each file’s content to a maximum character length. Snippets are intended to provide lightweight, focused context for downstream conceptual analysis without requiring full-file content."
        },
        {
          "id": "code-symbol",
          "label": "Code symbol",
          "category": "thing",
          "description": "A named element in the codebase (such as a function, class, or type) that represents a potential domain concept or behavior.",
          "aliases": [
            "Symbol",
            "SymbolInfo",
            "SymbolKind",
            "code symbol",
            "TypeScript symbol"
          ],
          "notes": "A code symbol is a named program element (class, interface, type alias, enum, function, or variable) discovered during repository analysis. It is characterized by its name, kind, location within a source file, and export status, and is treated as a candidate domain concept or behavior for higher-level conceptual modeling."
        },
        {
          "id": "language-adapter",
          "label": "Language adapter",
          "category": "thing",
          "description": "An abstraction that knows how to interpret and extract symbols from code written in a particular programming language.",
          "aliases": [
            "LanguageAdapter",
            "language adapter",
            "language-specific symbol extractor",
            "language-specific parser"
          ],
          "notes": "A Language adapter is a pluggable, language-specific component that knows how to interpret source text for one or more file extensions and extract a normalized set of code symbols (SymbolInfo) from it. Each concrete adapter (e.g., TypeScriptAdapter) encapsulates the parsing and symbol-discovery logic for a particular programming language or family of languages."
        },
        {
          "id": "repository-analysis-activity",
          "label": "Repository analysis",
          "category": "activity",
          "description": "The activity of scanning a repository, extracting files, symbols, and snippets, and preparing them for conceptual modeling.",
          "aliases": [
            "repository analysis",
            "repo analysis",
            "scanRepo",
            "scan repository",
            "project analysis",
            "analyze repository",
            "project structure discovery",
            "concept generation",
            "generateConcepts",
            "discoverProjectStructure"
          ],
          "notes": "Repository analysis is the end-to-end activity of examining a source code repository to gather structured inputs for conceptual modeling. In this codebase it is realized as a pipeline that (1) scans the repository for relevant source files (respecting ignore rules), (2) extracts file metadata, (3) extracts representative code snippets from selected files, (4) extracts language-specific code symbols, and (5) passes these artifacts to an LLM-driven process to discover projects, models, and concepts. The activity is parameterized by analysis options (e.g., repoRoot, outDir, verbosity, limits) and can use different language adapters to support multiple programming languages."
        }
      ],
      "relationships": [
        {
          "id": "source-repository-has-source-files",
          "from": "source-repository",
          "to": "file",
          "phrase": "contains",
          "category": "part_of",
          "description": "A source code repository contains multiple source files that are discovered during repository analysis."
        },
        {
          "id": "source-repository-is-analyzed-by-repository-analysis",
          "from": "source-repository",
          "to": "repository-analysis-activity",
          "phrase": "is analyzed by",
          "category": "uses",
          "description": "A source code repository is the input scope for a repository analysis activity, which scans it to find relevant files."
        },
        {
          "id": "repository-analysis-discovers-files-in-source-repository",
          "from": "repository-analysis-activity",
          "to": "file",
          "phrase": "discovers",
          "category": "causes",
          "description": "Repository analysis discovers and enumerates source files within a source code repository, producing a list of files for further symbol and snippet extraction."
        },
        {
          "id": "file-part-of-repo",
          "from": "file",
          "to": "source-repository",
          "phrase": "is contained in",
          "category": "part_of",
          "description": "Each source file resides within a source code repository and is discovered by scanning that repository."
        },
        {
          "id": "analysis-discovers-file",
          "from": "file",
          "to": "repository-analysis-activity",
          "phrase": "is discovered by",
          "category": "causes",
          "description": "Repository analysis scans the repository and discovers source files that match the configured criteria."
        },
        {
          "id": "file-enables-snippet",
          "from": "file",
          "to": "code-snippet",
          "phrase": "is used to extract",
          "category": "enables",
          "description": "Each source file can be read and truncated to produce one or more code snippets that provide focused context for conceptual analysis."
        },
        {
          "id": "file-enables-symbol",
          "from": "file",
          "to": "code-symbol",
          "phrase": "provides definitions for",
          "category": "enables",
          "description": "Source files contain the code in which code symbols (functions, classes, types, etc.) are defined and from which they are extracted."
        },
        {
          "id": "file-uses-language-adapter",
          "from": "file",
          "to": "language-adapter",
          "phrase": "is interpreted by",
          "category": "uses",
          "description": "Each source file is interpreted by a language adapter appropriate to its programming language when extracting symbols and other semantic information."
        },
        {
          "id": "code-snippet-derived-from-file",
          "from": "code-snippet",
          "to": "file",
          "phrase": "is extracted from",
          "category": "part_of",
          "description": "Each code snippet is derived from a specific source file and represents a truncated portion of that file’s contents."
        },
        {
          "id": "file-produces-code-snippet",
          "from": "file",
          "to": "code-snippet",
          "phrase": "produces",
          "category": "enables",
          "description": "A source file can be used to produce one or more code snippets that summarize or sample its contents for analysis."
        },
        {
          "id": "repository-analysis-extracts-code-snippet",
          "from": "repository-analysis-activity",
          "to": "code-snippet",
          "phrase": "extracts",
          "category": "causes",
          "description": "Repository analysis extracts code snippets from selected source files as part of preparing material for conceptual modeling."
        },
        {
          "id": "code-snippet-references-source-repository",
          "from": "code-snippet",
          "to": "source-repository",
          "phrase": "originates from",
          "category": "part_of",
          "description": "Each code snippet ultimately originates from a source file that belongs to a particular source code repository."
        },
        {
          "id": "code-symbol-defined-in-file",
          "from": "code-symbol",
          "to": "file",
          "phrase": "is defined in",
          "category": "part_of",
          "description": "Each code symbol is defined within a specific source file, identified by its absolute and repository-relative path."
        },
        {
          "id": "file-provides-code-symbol",
          "from": "file",
          "to": "code-symbol",
          "phrase": "provides definitions for",
          "category": "enables",
          "description": "A source file provides the textual definitions from which code symbols are extracted."
        },
        {
          "id": "repository-analysis-discovers-code-symbol",
          "from": "repository-analysis-activity",
          "to": "code-symbol",
          "phrase": "discovers",
          "category": "causes",
          "description": "Repository analysis scans source files and discovers code symbols, populating their metadata such as kind, location, and export status."
        },
        {
          "id": "language-adapter-extracts-code-symbol",
          "from": "language-adapter",
          "to": "code-symbol",
          "phrase": "extracts",
          "category": "enables",
          "description": "A language adapter interprets language-specific syntax to extract code symbols and classify them by kind."
        },
        {
          "id": "code-symbol-originates-from-source-repository",
          "from": "code-symbol",
          "to": "source-repository",
          "phrase": "originates from",
          "category": "part_of",
          "description": "Each code symbol ultimately originates from a particular source code repository that contains the defining file."
        },
        {
          "id": "code-symbol-located-in-code-snippet",
          "from": "code-symbol",
          "to": "code-snippet",
          "phrase": "can be located within",
          "category": "uses",
          "description": "A code symbol can be associated with a code snippet that provides focused textual context around its definition."
        },
        {
          "id": "language-adapter-interprets-file",
          "from": "language-adapter",
          "to": "file",
          "phrase": "interprets",
          "category": "uses",
          "description": "A language adapter interprets the contents of a source file in order to understand its structure and discover symbols."
        },
        {
          "id": "language-adapter-extracts-code-symbol",
          "from": "language-adapter",
          "to": "code-symbol",
          "phrase": "extracts",
          "category": "enables",
          "description": "A language adapter extracts code symbols from source files by parsing and analyzing the language-specific syntax."
        },
        {
          "id": "language-adapter-supports-file-extensions",
          "from": "language-adapter",
          "to": "file",
          "phrase": "supports certain extensions of",
          "category": "other",
          "description": "A language adapter declares which file extensions it supports, determining which source files it can interpret and extract symbols from."
        },
        {
          "id": "language-adapter-participates-in-repository-analysis",
          "from": "language-adapter",
          "to": "repository-analysis-activity",
          "phrase": "is used by",
          "category": "uses",
          "description": "Repository analysis uses one or more language adapters to extract symbols from files in the source repository."
        },
        {
          "id": "language-adapter-produces-symbol-info",
          "from": "language-adapter",
          "to": "code-symbol",
          "phrase": "produces metadata for",
          "category": "represents",
          "description": "A language adapter produces structured symbol information (e.g., name, kind, location) that represents code symbols discovered in a file."
        },
        {
          "id": "typescript-adapter-is-a-language-adapter",
          "from": "language-adapter",
          "to": "language-adapter",
          "phrase": "has concrete implementation such as TypeScriptAdapter",
          "category": "is_a",
          "description": "TypeScriptAdapter is a concrete implementation of the LanguageAdapter concept for TypeScript and related JavaScript file extensions."
        },
        {
          "id": "repo-analysis-uses-source-repository",
          "from": "repository-analysis-activity",
          "to": "source-repository",
          "phrase": "analyzes",
          "category": "uses",
          "description": "Repository analysis examines a source code repository as its primary input."
        },
        {
          "id": "repo-analysis-discovers-file",
          "from": "repository-analysis-activity",
          "to": "file",
          "phrase": "discovers",
          "category": "causes",
          "description": "Repository analysis scans the repository to discover source files that match configured criteria."
        },
        {
          "id": "repo-analysis-extracts-code-snippet",
          "from": "repository-analysis-activity",
          "to": "code-snippet",
          "phrase": "extracts",
          "category": "causes",
          "description": "Repository analysis extracts representative code snippets from discovered source files for use in conceptual modeling prompts."
        },
        {
          "id": "repo-analysis-discovers-code-symbol",
          "from": "repository-analysis-activity",
          "to": "code-symbol",
          "phrase": "discovers",
          "category": "causes",
          "description": "Repository analysis identifies code symbols such as classes, interfaces, and functions as candidate domain concepts."
        },
        {
          "id": "repo-analysis-uses-language-adapter",
          "from": "repository-analysis-activity",
          "to": "language-adapter",
          "phrase": "uses",
          "category": "uses",
          "description": "Repository analysis relies on a language adapter to interpret source files and extract language-specific symbols and metadata."
        },
        {
          "id": "repo-analysis-produces-concept-project",
          "from": "repository-analysis-activity",
          "to": "concept-project",
          "phrase": "produces",
          "category": "represents",
          "description": "Repository analysis produces a conceptual representation of the repository as a concept project, including models and concepts derived from code."
        },
        {
          "id": "repo-analysis-produces-concept-model",
          "from": "repository-analysis-activity",
          "to": "concept-model",
          "phrase": "produces",
          "category": "represents",
          "description": "Repository analysis generates one or more concept models that describe the domain structure inferred from the codebase."
        },
        {
          "id": "repo-analysis-produces-concept",
          "from": "repository-analysis-activity",
          "to": "concept",
          "phrase": "identifies",
          "category": "represents",
          "description": "Repository analysis identifies individual concepts, each potentially linked back to code symbols and file locations."
        },
        {
          "id": "repo-analysis-uses-llm-env",
          "from": "repository-analysis-activity",
          "to": "llm-environment",
          "phrase": "uses",
          "category": "uses",
          "description": "Repository analysis uses an LLM environment to call a large language model for project structure discovery and model enrichment."
        },
        {
          "id": "repo-analysis-configured-by-analyze-options",
          "from": "repository-analysis-activity",
          "to": "analyze-options",
          "phrase": "is configured by",
          "category": "uses",
          "description": "Repository analysis is parameterized by analysis options such as repository root, output directory, verbosity, and model limits."
        }
      ],
      "rules": [
        {
          "id": "source-repository-must-be-a-valid-path",
          "title": "Source repository must be a valid filesystem root",
          "text": "The source code repository must correspond to a valid, accessible filesystem path that can be resolved and traversed to discover files.",
          "kind": "constraint",
          "conceptIds": [
            "source-repository"
          ]
        },
        {
          "id": "source-repository-respects-gitignore",
          "title": "Source repository scanning respects ignore configuration",
          "text": "When analyzing a source code repository, any paths matching patterns defined in its .gitignore file are excluded from the discovered files.",
          "kind": "policy",
          "conceptIds": [
            "source-repository"
          ]
        },
        {
          "id": "source-repository-may-have-src-subdirectory",
          "title": "Source repository may define a primary source subdirectory",
          "text": "If a conventional source subdirectory (such as 'src') exists within the source code repository, repository analysis starts from that subdirectory; otherwise, analysis starts from the repository root.",
          "kind": "assumption",
          "conceptIds": [
            "source-repository"
          ]
        },
        {
          "id": "source-repository-filters-by-file-extensions",
          "title": "Source repository analysis filters by file extensions",
          "text": "Only files whose extensions are included in the configured set of source extensions are treated as relevant source files during repository analysis.",
          "kind": "policy",
          "conceptIds": [
            "source-repository"
          ]
        },
        {
          "id": "rule-file-must-match-extension",
          "title": "Source file must match allowed extensions",
          "text": "Only files whose extensions are included in the configured extension list are treated as source files for repository analysis.",
          "kind": "constraint",
          "conceptIds": [
            "file"
          ]
        },
        {
          "id": "rule-file-must-not-be-ignored",
          "title": "Source file must not be ignored by repository rules",
          "text": "Files whose repository-relative paths match ignore rules (e.g., from .gitignore) are excluded from being treated as source files in the analysis.",
          "kind": "constraint",
          "conceptIds": [
            "file"
          ]
        },
        {
          "id": "rule-file-has-unique-relative-path",
          "title": "Source file is identified by repository-relative path",
          "text": "Within a given repository analysis run, each source file is uniquely identified by its path relative to the repository root.",
          "kind": "assumption",
          "conceptIds": [
            "file"
          ]
        },
        {
          "id": "rule-snippet-derived-from-file-content",
          "title": "Code snippet content is a prefix of the source file content",
          "text": "When extracting snippets for analysis, the snippet text is taken as a leading segment of the source file content up to a configured maximum character length.",
          "kind": "invariant",
          "conceptIds": [
            "file"
          ]
        },
        {
          "id": "code-snippet-max-chars-per-file",
          "title": "Code snippet length is limited per file",
          "text": "A code snippet must not exceed the configured maximum number of characters taken from its source file.",
          "kind": "constraint",
          "conceptIds": [
            "code-snippet"
          ]
        },
        {
          "id": "code-snippet-one-source-file",
          "title": "Code snippet is derived from a single file",
          "text": "Each code snippet is derived from exactly one source file and must reference that file’s relative path.",
          "kind": "invariant",
          "conceptIds": [
            "code-snippet"
          ]
        },
        {
          "id": "code-snippet-limited-number-of-files",
          "title": "Code snippets are extracted from a limited number of files",
          "text": "In a single extraction run, code snippets are only created for up to a configured maximum number of source files.",
          "kind": "policy",
          "conceptIds": [
            "code-snippet"
          ]
        },
        {
          "id": "code-snippet-selected-files-bias",
          "title": "Code snippets are biased toward smaller files",
          "text": "When selecting files to extract snippets from, smaller files are preferred over larger ones, based on file size ordering.",
          "kind": "assumption",
          "conceptIds": [
            "code-snippet"
          ]
        },
        {
          "id": "code-symbol-must-have-name",
          "title": "Code symbol must have a name",
          "text": "A code symbol is only recorded if it has a defined, non-empty name; unnamed constructs are not treated as code symbols.",
          "kind": "invariant",
          "conceptIds": [
            "code-symbol"
          ]
        },
        {
          "id": "code-symbol-kind-enumeration",
          "title": "Code symbol kind is constrained to known categories",
          "text": "Each code symbol must be classified as one of the supported kinds: class, interface, type alias, enum, function, or variable.",
          "kind": "constraint",
          "conceptIds": [
            "code-symbol"
          ]
        },
        {
          "id": "code-symbol-location-required",
          "title": "Code symbol must have a precise location",
          "text": "Each code symbol must be associated with a specific file path and a 1-based line and column indicating where it is defined.",
          "kind": "invariant",
          "conceptIds": [
            "code-symbol"
          ]
        },
        {
          "id": "code-symbol-export-flags-consistent",
          "title": "Code symbol export flags are consistent",
          "text": "If a code symbol is marked as a default export, it must also be considered exported; a default export implies exported status.",
          "kind": "invariant",
          "conceptIds": [
            "code-symbol"
          ]
        },
        {
          "id": "language-adapter-must-declare-extensions",
          "title": "Language adapter must declare supported file extensions",
          "text": "Every language adapter must provide a non-empty list of file extensions it supports so that the analysis process can route files to an appropriate adapter.",
          "kind": "constraint",
          "conceptIds": [
            "language-adapter"
          ]
        },
        {
          "id": "language-adapter-extractsymbols-pure-function-of-file",
          "title": "Symbol extraction is based solely on file content and path",
          "text": "A language adapter's symbol extraction is determined only by the provided file content and its paths (absolute and relative), ensuring that symbol discovery is reproducible for the same inputs.",
          "kind": "assumption",
          "conceptIds": [
            "language-adapter"
          ]
        },
        {
          "id": "language-adapter-returns-normalized-symbols",
          "title": "Language adapter returns normalized symbol information",
          "text": "A language adapter must return symbols in a common SymbolInfo format so that downstream repository analysis and conceptual modeling can treat symbols uniformly across languages.",
          "kind": "invariant",
          "conceptIds": [
            "language-adapter"
          ]
        },
        {
          "id": "language-adapter-ignores-unnamed-constructs",
          "title": "Language adapter only reports named symbols",
          "text": "A language adapter does not emit symbol entries for unnamed constructs; only code elements with a name are returned as code symbols.",
          "kind": "assumption",
          "conceptIds": [
            "language-adapter"
          ]
        },
        {
          "id": "rule-repo-analysis-requires-repo-root",
          "title": "Repository analysis requires a repository root",
          "text": "Repository analysis must be provided with a valid repository root path in order to scan files and perform analysis.",
          "kind": "constraint",
          "conceptIds": [
            "repository-analysis-activity"
          ]
        },
        {
          "id": "rule-repo-analysis-respects-ignore-rules",
          "title": "Repository analysis respects repository ignore rules",
          "text": "Repository analysis must respect ignore rules defined in the repository (such as entries in .gitignore) when scanning for files to analyze.",
          "kind": "policy",
          "conceptIds": [
            "repository-analysis-activity"
          ]
        },
        {
          "id": "rule-repo-analysis-limits-snippet-scope",
          "title": "Repository analysis limits snippet extraction scope",
          "text": "Repository analysis should limit the number of files and the number of characters per file when extracting code snippets, to keep prompts and intermediate artifacts within manageable size bounds.",
          "kind": "assumption",
          "conceptIds": [
            "repository-analysis-activity"
          ]
        },
        {
          "id": "rule-repo-analysis-uses-supported-extensions",
          "title": "Repository analysis only scans supported file extensions",
          "text": "Repository analysis must restrict scanning to files whose extensions are explicitly configured as supported for symbol extraction.",
          "kind": "constraint",
          "conceptIds": [
            "repository-analysis-activity"
          ]
        }
      ],
      "lifecycles": [
        {
          "id": "lifecycle-repo-analysis",
          "subjectConceptId": "repository-analysis-activity",
          "stateConceptIds": [
            "repository-analysis-planned",
            "repository-analysis-scanning",
            "repository-analysis-extracting",
            "repository-analysis-modeling",
            "repository-analysis-completed"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "repository-analysis-planned",
          "terminalStateIds": [
            "repository-analysis-completed"
          ]
        }
      ],
      "views": [
        {
          "id": "repo-analysis-overview",
          "name": "Repository analysis overview",
          "kind": "overview",
          "description": "High-level view of how a source repository is analyzed to discover files, snippets, and symbols.",
          "conceptIds": [
            "source-repository",
            "repository-analysis-activity",
            "file",
            "code-snippet",
            "code-symbol",
            "language-adapter"
          ],
          "relationshipIds": [
            "source-repository-is-analyzed-by-repository-analysis",
            "repo-analysis-uses-source-repository",
            "repo-analysis-uses-language-adapter",
            "repo-analysis-discovers-file",
            "repo-analysis-extracts-code-snippet",
            "repo-analysis-discovers-code-symbol",
            "language-adapter-interprets-file",
            "language-adapter-extracts-code-symbol"
          ]
        },
        {
          "id": "repository-artifacts-structure",
          "name": "Repository artifacts and their structure",
          "kind": "structure",
          "description": "How files, snippets, and symbols are structured within and trace back to the source repository.",
          "conceptIds": [
            "source-repository",
            "file",
            "code-snippet",
            "code-symbol"
          ],
          "relationshipIds": [
            "source-repository-has-source-files",
            "file-part-of-repo",
            "file-enables-snippet",
            "file-produces-code-snippet",
            "code-snippet-derived-from-file",
            "code-snippet-references-source-repository",
            "file-enables-symbol",
            "code-symbol-defined-in-file",
            "code-symbol-originates-from-source-repository"
          ]
        },
        {
          "id": "language-adapter-role",
          "name": "Role of the language adapter",
          "kind": "implementation",
          "description": "How the language adapter participates in repository analysis and symbol extraction.",
          "conceptIds": [
            "language-adapter",
            "file",
            "code-symbol",
            "repository-analysis-activity"
          ],
          "relationshipIds": [
            "language-adapter-interprets-file",
            "language-adapter-supports-file-extensions",
            "language-adapter-extracts-code-symbol",
            "language-adapter-produces-symbol-info",
            "language-adapter-participates-in-repository-analysis",
            "repo-analysis-uses-language-adapter"
          ]
        },
        {
          "id": "analysis-to-concepts-bridge",
          "name": "From repository analysis to concept models",
          "kind": "lifecycle",
          "description": "How repository analysis uses configuration and LLMs to produce concept projects, models, and concepts.",
          "conceptIds": [
            "repository-analysis-activity",
            "source-repository",
            "llm-environment",
            "analyze-options",
            "concept-project",
            "concept-model",
            "concept"
          ],
          "relationshipIds": [
            "repo-analysis-uses-source-repository",
            "repo-analysis-uses-llm-env",
            "repo-analysis-configured-by-analyze-options",
            "repo-analysis-produces-concept-project",
            "repo-analysis-produces-concept-model",
            "repo-analysis-produces-concept"
          ]
        },
        {
          "id": "symbol-and-snippet-context",
          "name": "Symbols within snippets and files",
          "kind": "structure",
          "description": "How code symbols relate to files and snippets to provide localized context for analysis.",
          "conceptIds": [
            "file",
            "code-snippet",
            "code-symbol",
            "source-repository"
          ],
          "relationshipIds": [
            "file-produces-code-snippet",
            "code-snippet-derived-from-file",
            "code-snippet-references-source-repository",
            "file-provides-code-symbol",
            "code-symbol-defined-in-file",
            "code-symbol-located-in-code-snippet",
            "code-symbol-originates-from-source-repository"
          ]
        }
      ],
      "storyViews": [
        {
          "id": "basic-repository-scan-and-symbol-discovery",
          "name": "Basic Repository Scan and Symbol Discovery",
          "kind": "system_flow",
          "description": "A straightforward pass where the system scans a repository, discovers files, and extracts symbols and snippets using a language adapter.",
          "tags": [
            "happy-path",
            "scan",
            "symbols",
            "snippets"
          ],
          "focusConceptId": "repository-analysis-activity",
          "steps": [
            {
              "id": "repo-selected-for-analysis",
              "index": 0,
              "title": "Repository Is Selected for Analysis",
              "narrative": "A source code repository is chosen as the target for analysis, making its contents available to the repository analysis activity.",
              "conceptIds": [
                "source-repository",
                "repository-analysis-activity"
              ],
              "relationshipIds": [
                "source-repository-is-analyzed-by-repository-analysis",
                "repo-analysis-uses-source-repository"
              ],
              "primaryConceptIds": [
                "source-repository",
                "repository-analysis-activity"
              ],
              "primaryRelationshipIds": [
                "repo-analysis-uses-source-repository"
              ]
            },
            {
              "id": "files-discovered-in-repository",
              "index": 1,
              "title": "Files Are Discovered in the Repository",
              "narrative": "The repository analysis walks the repository structure and discovers individual source files contained within it.",
              "conceptIds": [
                "source-repository",
                "file",
                "repository-analysis-activity"
              ],
              "relationshipIds": [
                "source-repository-has-source-files",
                "repository-analysis-discovers-files-in-source-repository",
                "repo-analysis-discovers-file",
                "file-part-of-repo",
                "analysis-discovers-file"
              ],
              "primaryConceptIds": [
                "file",
                "repository-analysis-activity"
              ],
              "primaryRelationshipIds": [
                "repo-analysis-discovers-file"
              ]
            },
            {
              "id": "language-adapter-engaged-for-files",
              "index": 2,
              "title": "Language Adapter Is Engaged for Each File",
              "narrative": "For each discovered file, the repository analysis activity selects an appropriate language adapter that supports the file’s extension and can interpret its contents.",
              "conceptIds": [
                "file",
                "language-adapter",
                "repository-analysis-activity"
              ],
              "relationshipIds": [
                "repo-analysis-uses-language-adapter",
                "language-adapter-participates-in-repository-analysis",
                "language-adapter-supports-file-extensions",
                "file-uses-language-adapter",
                "language-adapter-interprets-file"
              ],
              "primaryConceptIds": [
                "language-adapter",
                "file"
              ],
              "primaryRelationshipIds": [
                "language-adapter-interprets-file"
              ]
            },
            {
              "id": "symbols-extracted-from-files",
              "index": 3,
              "title": "Code Symbols Are Extracted from Files",
              "narrative": "The language adapter interprets each file and extracts code symbols, while the repository analysis activity records these discovered symbols and their defining files.",
              "conceptIds": [
                "file",
                "code-symbol",
                "language-adapter",
                "repository-analysis-activity"
              ],
              "relationshipIds": [
                "file-enables-symbol",
                "file-provides-code-symbol",
                "code-symbol-defined-in-file",
                "language-adapter-extracts-code-symbol",
                "language-adapter-produces-symbol-info",
                "repository-analysis-discovers-code-symbol",
                "repo-analysis-discovers-code-symbol"
              ],
              "primaryConceptIds": [
                "code-symbol",
                "language-adapter"
              ],
              "primaryRelationshipIds": [
                "language-adapter-extracts-code-symbol",
                "repo-analysis-discovers-code-symbol"
              ]
            },
            {
              "id": "snippets-extracted-for-context",
              "index": 4,
              "title": "Code Snippets Are Extracted for Context",
              "narrative": "The repository analysis activity extracts focused code snippets from files, capturing regions around important symbols to support later conceptual analysis.",
              "conceptIds": [
                "file",
                "code-snippet",
                "repository-analysis-activity",
                "source-repository"
              ],
              "relationshipIds": [
                "file-enables-snippet",
                "file-produces-code-snippet",
                "repository-analysis-extracts-code-snippet",
                "repo-analysis-extracts-code-snippet",
                "code-snippet-derived-from-file",
                "code-snippet-references-source-repository"
              ],
              "primaryConceptIds": [
                "code-snippet",
                "file"
              ],
              "primaryRelationshipIds": [
                "repo-analysis-extracts-code-snippet"
              ]
            },
            {
              "id": "symbols-and-snippets-linked-to-repository",
              "index": 5,
              "title": "Symbols and Snippets Are Linked Back to the Repository",
              "narrative": "Each discovered symbol and extracted snippet is associated with its originating repository, preserving traceability from conceptual elements back to the source code.",
              "conceptIds": [
                "code-symbol",
                "code-snippet",
                "source-repository"
              ],
              "relationshipIds": [
                "code-symbol-originates-from-source-repository",
                "code-snippet-references-source-repository"
              ],
              "primaryConceptIds": [
                "code-symbol",
                "code-snippet"
              ],
              "primaryRelationshipIds": [
                "code-symbol-originates-from-source-repository"
              ]
            }
          ]
        },
        {
          "id": "multi-language-repository-analysis",
          "name": "Multi-language Repository Analysis with Adapters",
          "kind": "system_flow",
          "description": "A repository containing multiple languages is analyzed using different language adapters, each extracting symbols and snippets from supported files.",
          "tags": [
            "multi-language",
            "adapters",
            "symbols"
          ],
          "focusConceptId": "language-adapter",
          "steps": [
            {
              "id": "multi-language-repo-identified",
              "index": 0,
              "title": "Multi-language Repository Is Identified",
              "narrative": "A source repository containing files in several programming languages is selected for analysis, preparing it for adapter-based processing.",
              "conceptIds": [
                "source-repository",
                "repository-analysis-activity"
              ],
              "relationshipIds": [
                "source-repository-is-analyzed-by-repository-analysis",
                "repo-analysis-uses-source-repository"
              ],
              "primaryConceptIds": [
                "source-repository"
              ],
              "primaryRelationshipIds": [
                "source-repository-is-analyzed-by-repository-analysis"
              ]
            },
            {
              "id": "files-grouped-by-language",
              "index": 1,
              "title": "Files Are Discovered and Grouped by Language",
              "narrative": "The repository analysis discovers files in the repository and groups them by extension so that appropriate language adapters can be chosen.",
              "conceptIds": [
                "source-repository",
                "file",
                "repository-analysis-activity"
              ],
              "relationshipIds": [
                "source-repository-has-source-files",
                "repository-analysis-discovers-files-in-source-repository",
                "repo-analysis-discovers-file",
                "file-part-of-repo"
              ],
              "primaryConceptIds": [
                "file"
              ],
              "primaryRelationshipIds": [
                "repo-analysis-discovers-file"
              ]
            },
            {
              "id": "adapters-matched-to-file-extensions",
              "index": 2,
              "title": "Language Adapters Are Matched to File Extensions",
              "narrative": "For each group of files, the repository analysis activity selects a language adapter that supports the corresponding file extensions and can interpret those files.",
              "conceptIds": [
                "file",
                "language-adapter",
                "repository-analysis-activity"
              ],
              "relationshipIds": [
                "repo-analysis-uses-language-adapter",
                "language-adapter-participates-in-repository-analysis",
                "language-adapter-supports-file-extensions",
                "file-uses-language-adapter"
              ],
              "primaryConceptIds": [
                "language-adapter"
              ],
              "primaryRelationshipIds": [
                "language-adapter-supports-file-extensions"
              ]
            },
            {
              "id": "adapters-interpret-files",
              "index": 3,
              "title": "Adapters Interpret Files in Their Languages",
              "narrative": "Each language adapter interprets the files it supports, understanding language-specific constructs in preparation for symbol extraction.",
              "conceptIds": [
                "file",
                "language-adapter"
              ],
              "relationshipIds": [
                "language-adapter-interprets-file",
                "file-uses-language-adapter"
              ],
              "primaryConceptIds": [
                "language-adapter"
              ],
              "primaryRelationshipIds": [
                "language-adapter-interprets-file"
              ]
            },
            {
              "id": "symbols-extracted-per-language",
              "index": 4,
              "title": "Symbols Are Extracted Per Language",
              "narrative": "Language adapters extract code symbols and produce metadata for them, while the repository analysis activity records these symbols as discovered entities tied to their defining files.",
              "conceptIds": [
                "file",
                "code-symbol",
                "language-adapter",
                "repository-analysis-activity"
              ],
              "relationshipIds": [
                "file-enables-symbol",
                "file-provides-code-symbol",
                "code-symbol-defined-in-file",
                "language-adapter-extracts-code-symbol",
                "language-adapter-produces-symbol-info",
                "repository-analysis-discovers-code-symbol",
                "repo-analysis-discovers-code-symbol"
              ],
              "primaryConceptIds": [
                "code-symbol"
              ],
              "primaryRelationshipIds": [
                "language-adapter-extracts-code-symbol"
              ]
            },
            {
              "id": "snippets-created-around-key-symbols",
              "index": 5,
              "title": "Snippets Are Created Around Key Symbols",
              "narrative": "For important symbols across all languages, the repository analysis extracts code snippets from the corresponding files to capture local context for later conceptual modeling.",
              "conceptIds": [
                "file",
                "code-snippet",
                "repository-analysis-activity"
              ],
              "relationshipIds": [
                "file-enables-snippet",
                "file-produces-code-snippet",
                "repository-analysis-extracts-code-snippet",
                "repo-analysis-extracts-code-snippet",
                "code-snippet-derived-from-file"
              ],
              "primaryConceptIds": [
                "code-snippet"
              ],
              "primaryRelationshipIds": [
                "repo-analysis-extracts-code-snippet"
              ]
            }
          ]
        },
        {
          "id": "symbol-centric-traceback-to-source",
          "name": "Symbol-centric Traceback to Files and Repository",
          "kind": "system_flow",
          "description": "Starting from a discovered symbol, the story traces how its origin in a file and repository, and its surrounding snippet, are maintained for traceability.",
          "tags": [
            "traceability",
            "symbols",
            "snippets"
          ],
          "focusConceptId": "code-symbol",
          "steps": [
            {
              "id": "symbol-discovered-during-analysis",
              "index": 0,
              "title": "Symbol Is Discovered During Analysis",
              "narrative": "While analyzing the repository, the repository analysis activity, with help from a language adapter, discovers a new code symbol.",
              "conceptIds": [
                "repository-analysis-activity",
                "language-adapter",
                "code-symbol"
              ],
              "relationshipIds": [
                "repo-analysis-uses-language-adapter",
                "language-adapter-participates-in-repository-analysis",
                "language-adapter-extracts-code-symbol",
                "language-adapter-produces-symbol-info",
                "repository-analysis-discovers-code-symbol",
                "repo-analysis-discovers-code-symbol"
              ],
              "primaryConceptIds": [
                "code-symbol"
              ],
              "primaryRelationshipIds": [
                "repo-analysis-discovers-code-symbol"
              ]
            },
            {
              "id": "symbol-linked-to-defining-file",
              "index": 1,
              "title": "Symbol Is Linked to Its Defining File",
              "narrative": "The discovered code symbol is associated with the specific file that provides its definition, preserving where it is defined in the codebase.",
              "conceptIds": [
                "code-symbol",
                "file"
              ],
              "relationshipIds": [
                "file-enables-symbol",
                "file-provides-code-symbol",
                "code-symbol-defined-in-file"
              ],
              "primaryConceptIds": [
                "code-symbol",
                "file"
              ],
              "primaryRelationshipIds": [
                "code-symbol-defined-in-file"
              ]
            },
            {
              "id": "symbol-associated-with-repository",
              "index": 2,
              "title": "Symbol Is Associated with Its Repository",
              "narrative": "Because the defining file is contained in a source repository, the symbol is also recorded as originating from that repository.",
              "conceptIds": [
                "code-symbol",
                "file",
                "source-repository"
              ],
              "relationshipIds": [
                "file-part-of-repo",
                "source-repository-has-source-files",
                "code-symbol-originates-from-source-repository"
              ],
              "primaryConceptIds": [
                "code-symbol",
                "source-repository"
              ],
              "primaryRelationshipIds": [
                "code-symbol-originates-from-source-repository"
              ]
            },
            {
              "id": "snippet-extracted-around-symbol",
              "index": 3,
              "title": "Snippet Is Extracted Around the Symbol",
              "narrative": "To capture local context, the repository analysis activity extracts a code snippet from the defining file that includes or surrounds the symbol.",
              "conceptIds": [
                "repository-analysis-activity",
                "file",
                "code-snippet",
                "code-symbol"
              ],
              "relationshipIds": [
                "file-enables-snippet",
                "file-produces-code-snippet",
                "repository-analysis-extracts-code-snippet",
                "repo-analysis-extracts-code-snippet",
                "code-snippet-derived-from-file",
                "code-symbol-located-in-code-snippet"
              ],
              "primaryConceptIds": [
                "code-snippet",
                "code-symbol"
              ],
              "primaryRelationshipIds": [
                "code-symbol-located-in-code-snippet"
              ]
            },
            {
              "id": "symbol-and-snippet-traceable-to-repo",
              "index": 4,
              "title": "Symbol and Snippet Remain Traceable to the Repository",
              "narrative": "Both the symbol and its snippet are recorded as originating from the same source repository, enabling end-to-end traceability from conceptual elements back to the codebase.",
              "conceptIds": [
                "code-symbol",
                "code-snippet",
                "source-repository"
              ],
              "relationshipIds": [
                "code-symbol-originates-from-source-repository",
                "code-snippet-references-source-repository"
              ],
              "primaryConceptIds": [
                "code-symbol",
                "code-snippet"
              ],
              "primaryRelationshipIds": [
                "code-snippet-references-source-repository"
              ]
            }
          ]
        },
        {
          "id": "adapter-focused-internal-processing",
          "name": "Adapter-focused Internal Processing of a Single File",
          "kind": "system_flow",
          "description": "Zooms into how a single file is interpreted by a language adapter during repository analysis to yield symbols and snippets.",
          "tags": [
            "single-file",
            "adapter",
            "internal-process"
          ],
          "focusConceptId": "file",
          "steps": [
            {
              "id": "file-identified-in-repository",
              "index": 0,
              "title": "File Is Identified in the Repository",
              "narrative": "Within the selected source repository, a particular source file is discovered and queued for detailed analysis.",
              "conceptIds": [
                "source-repository",
                "file",
                "repository-analysis-activity"
              ],
              "relationshipIds": [
                "source-repository-has-source-files",
                "repository-analysis-discovers-files-in-source-repository",
                "repo-analysis-discovers-file",
                "file-part-of-repo"
              ],
              "primaryConceptIds": [
                "file"
              ],
              "primaryRelationshipIds": [
                "repo-analysis-discovers-file"
              ]
            },
            {
              "id": "adapter-selected-for-file",
              "index": 1,
              "title": "Language Adapter Is Selected for the File",
              "narrative": "The repository analysis activity selects a language adapter that supports the file’s extension and can interpret its syntax.",
              "conceptIds": [
                "file",
                "language-adapter",
                "repository-analysis-activity"
              ],
              "relationshipIds": [
                "repo-analysis-uses-language-adapter",
                "language-adapter-participates-in-repository-analysis",
                "language-adapter-supports-file-extensions",
                "file-uses-language-adapter"
              ],
              "primaryConceptIds": [
                "language-adapter"
              ],
              "primaryRelationshipIds": [
                "language-adapter-supports-file-extensions"
              ]
            },
            {
              "id": "file-interpreted-by-adapter",
              "index": 2,
              "title": "File Is Interpreted by the Adapter",
              "narrative": "The language adapter parses and interprets the file, building an internal representation that exposes potential symbols and snippet regions.",
              "conceptIds": [
                "file",
                "language-adapter"
              ],
              "relationshipIds": [
                "language-adapter-interprets-file",
                "file-uses-language-adapter"
              ],
              "primaryConceptIds": [
                "language-adapter",
                "file"
              ],
              "primaryRelationshipIds": [
                "language-adapter-interprets-file"
              ]
            },
            {
              "id": "symbols-produced-from-file",
              "index": 3,
              "title": "Symbols Are Produced from the File",
              "narrative": "Using its interpretation, the language adapter extracts code symbols and produces metadata, while the repository analysis activity records these symbols as discovered.",
              "conceptIds": [
                "file",
                "code-symbol",
                "language-adapter",
                "repository-analysis-activity"
              ],
              "relationshipIds": [
                "file-enables-symbol",
                "file-provides-code-symbol",
                "code-symbol-defined-in-file",
                "language-adapter-extracts-code-symbol",
                "language-adapter-produces-symbol-info",
                "repository-analysis-discovers-code-symbol",
                "repo-analysis-discovers-code-symbol"
              ],
              "primaryConceptIds": [
                "code-symbol"
              ],
              "primaryRelationshipIds": [
                "language-adapter-extracts-code-symbol"
              ]
            },
            {
              "id": "snippets-produced-from-file",
              "index": 4,
              "title": "Snippets Are Produced from the File",
              "narrative": "The repository analysis activity extracts one or more code snippets from the file, often around the newly discovered symbols, to capture relevant context.",
              "conceptIds": [
                "file",
                "code-snippet",
                "repository-analysis-activity"
              ],
              "relationshipIds": [
                "file-enables-snippet",
                "file-produces-code-snippet",
                "repository-analysis-extracts-code-snippet",
                "repo-analysis-extracts-code-snippet",
                "code-snippet-derived-from-file"
              ],
              "primaryConceptIds": [
                "code-snippet"
              ],
              "primaryRelationshipIds": [
                "code-snippet-derived-from-file"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "llm-concept-synthesis",
      "title": "LLM-based Concept Synthesis",
      "description": "This model describes how extracted code information is transformed into higher-level concept models using large language models.",
      "concepts": [
        {
          "id": "llm-environment",
          "label": "LLM environment",
          "category": "thing",
          "description": "The configuration and external context required to call a large language model, such as API keys, model identifiers, and runtime settings.",
          "aliases": [
            "LLMEnv",
            "LLM environment",
            "LLM configuration",
            "LLM client configuration"
          ],
          "notes": "An LLM environment encapsulates the minimal configuration and external context required to make a call to a large language model provider. In this code it consists of an API key, an optional base URL for the provider endpoint, and a model identifier. It is passed into LLM invocations rather than being global, allowing different calls to use different providers or models."
        },
        {
          "id": "llm-message",
          "label": "LLM message",
          "category": "thing",
          "description": "A structured message or prompt sent to or received from a large language model as part of a conversation.",
          "aliases": [
            "LLMMessage",
            "message",
            "chat message"
          ],
          "notes": "An LLM message is a single structured chat turn provided to or received from a large language model. In this codebase it is modeled minimally with a role and textual content, and is used as part of the messages array passed into a chat-completions style LLM API."
        },
        {
          "id": "llm-response-format",
          "label": "LLM response format",
          "category": "thing",
          "description": "The expected structure or schema of the response returned by the large language model.",
          "aliases": [
            "ResponseFormat",
            "responseFormat",
            "LLM response format",
            "LLM output format"
          ],
          "notes": "LLM response format represents the expected structure of the content returned by the LLM for a given invocation. In this code, it is a discrete choice between free-form text and a structured JSON object. The chosen format determines how the client will interpret and post-process the LLM's message content (either as an opaque string or as JSON to be parsed into a typed object)."
        },
        {
          "id": "llm-invocation",
          "label": "LLM invocation",
          "category": "activity",
          "description": "The activity of calling a large language model with repository-derived context to generate conceptual descriptions and models.",
          "aliases": [
            "LLM call",
            "callLLM",
            "LLM request",
            "LLM API call",
            "LLM chat completion request"
          ],
          "notes": "An LLM invocation is the concrete act of sending one or more LLM messages to a configured LLM environment and obtaining a response, optionally in a structured response format. In this project it is embodied by the callLLM function, which is used to drive concept discovery and enrichment from a code repository."
        },
        {
          "id": "concept-synthesis",
          "label": "Concept synthesis",
          "category": "activity",
          "description": "The process of turning low-level code symbols and snippets into higher-level domain concepts, relationships, and stories using LLM output.",
          "aliases": [
            "concept synthesis",
            "concept generation",
            "project structure discovery",
            "model discovery",
            "discoverProjectStructure",
            "enrichProjectModels"
          ],
          "notes": "Concept synthesis is the LLM-driven process that takes low-level repository artifacts (symbols, files, snippets) and produces higher-level domain concepts, relationships, lifecycles, and stories organized into concept models and projects. In this codebase, it is primarily realized through LLM calls that infer a DiscoveredProject (and its DiscoveredModels and DiscoveredConcepts) from SymbolInfo and FileInfo, and then further enrich those models with additional context. The process depends on a configured LLM environment and a structured prompt, and it outputs structured ConceptProject/ConceptModel/Concept objects suitable for visualization and further tooling."
        }
      ],
      "relationships": [
        {
          "id": "rel-llm-env-enables-llm-invocation",
          "from": "llm-environment",
          "to": "llm-invocation",
          "phrase": "enables",
          "category": "enables",
          "description": "An LLM environment provides the credentials, endpoint, and model identifier required for an LLM invocation to be executed."
        },
        {
          "id": "rel-llm-env-used-by-llm-invocation",
          "from": "llm-environment",
          "to": "llm-invocation",
          "phrase": "is used by",
          "category": "uses",
          "description": "Each LLM invocation uses a specific LLM environment instance when calling the external LLM API."
        },
        {
          "id": "rel-llm-env-selects-llm-response-format",
          "from": "llm-environment",
          "to": "llm-response-format",
          "phrase": "constrains",
          "category": "other",
          "description": "The LLM environment, together with invocation options, constrains which response formats are valid for a given model and endpoint."
        },
        {
          "id": "rel-llm-env-contextualizes-llm-message",
          "from": "llm-environment",
          "to": "llm-message",
          "phrase": "contextualizes",
          "category": "uses",
          "description": "An LLM environment provides the external API context in which LLM messages are sent to and interpreted by the model."
        },
        {
          "id": "rel-llm-message-part-of-llm-invocation",
          "from": "llm-message",
          "to": "llm-invocation",
          "phrase": "is included in",
          "category": "part_of",
          "description": "Each LLM invocation sends one or more LLM messages as the conversational context for the model call."
        },
        {
          "id": "rel-llm-invocation-uses-llm-message",
          "from": "llm-invocation",
          "to": "llm-message",
          "phrase": "uses",
          "category": "uses",
          "description": "An LLM invocation uses LLM messages to convey system instructions and user prompts to the model."
        },
        {
          "id": "rel-llm-message-uses-llm-environment",
          "from": "llm-message",
          "to": "llm-environment",
          "phrase": "is interpreted within",
          "category": "uses",
          "description": "The meaning and handling of an LLM message depend on the LLM environment, including which model is called and its configuration."
        },
        {
          "id": "rel-llm-message-influences-llm-response-format",
          "from": "llm-message",
          "to": "llm-response-format",
          "phrase": "influences",
          "category": "other",
          "description": "The content of LLM messages (e.g., instructions to return JSON) can influence how the LLM realizes the expected response format, even when a formal response format is specified."
        },
        {
          "id": "rel-llm-response-format-constrains-llm-invocation-output",
          "from": "llm-response-format",
          "to": "llm-invocation",
          "phrase": "constrains output of",
          "category": "other",
          "description": "LLM response format constrains how the result of an LLM invocation is structured and how it must be handled by the caller (as plain text or as JSON)."
        },
        {
          "id": "rel-llm-invocation-selects-llm-response-format",
          "from": "llm-invocation",
          "to": "llm-response-format",
          "phrase": "selects",
          "category": "uses",
          "description": "An LLM invocation selects a response format via options, indicating whether it expects text or a JSON object from the LLM."
        },
        {
          "id": "rel-llm-response-format-interprets-llm-message-content",
          "from": "llm-response-format",
          "to": "llm-message",
          "phrase": "determines interpretation of content in",
          "category": "other",
          "description": "LLM response format determines how the content field of the returned LLM message is interpreted (as raw text or as JSON to be parsed)."
        },
        {
          "id": "rel-llm-environment-limits-llm-response-format",
          "from": "llm-environment",
          "to": "llm-response-format",
          "phrase": "limits available options for",
          "category": "other",
          "description": "The LLM environment, through its chosen model and API, limits which response formats are actually supported (e.g., whether JSON object mode is available)."
        },
        {
          "id": "llm-invocation-uses-env",
          "from": "llm-invocation",
          "to": "llm-environment",
          "phrase": "uses",
          "category": "uses",
          "description": "An LLM invocation uses an LLM environment to determine which model to call, where to send the request, and which credentials to use."
        },
        {
          "id": "llm-invocation-includes-messages",
          "from": "llm-invocation",
          "to": "llm-message",
          "phrase": "includes",
          "category": "part_of",
          "description": "An LLM invocation includes one or more LLM messages that define the system and user roles and provide the prompt content."
        },
        {
          "id": "llm-invocation-selects-response-format",
          "from": "llm-invocation",
          "to": "llm-response-format",
          "phrase": "selects",
          "category": "uses",
          "description": "An LLM invocation selects a response format to indicate whether the model should return plain text or a structured JSON object."
        },
        {
          "id": "llm-invocation-enables-concept-synthesis",
          "from": "llm-invocation",
          "to": "concept-synthesis",
          "phrase": "enables",
          "category": "enables",
          "description": "An LLM invocation enables concept synthesis by generating structured descriptions of projects, models, and concepts from repository-derived prompts."
        },
        {
          "id": "concept-synthesis-uses-llm-invocation",
          "from": "concept-synthesis",
          "to": "llm-invocation",
          "phrase": "uses",
          "category": "uses",
          "description": "Concept synthesis uses LLM invocations to transform repository-derived symbols and files into higher-level concept projects, models, and concepts."
        },
        {
          "id": "concept-synthesis-uses-llm-message",
          "from": "concept-synthesis",
          "to": "llm-message",
          "phrase": "constructs and consumes",
          "category": "uses",
          "description": "Concept synthesis constructs LLM messages (prompts) describing the repository structure and consumes the LLM's reply to infer domain concepts and models."
        },
        {
          "id": "concept-synthesis-is-constrained-by-llm-response-format",
          "from": "concept-synthesis",
          "to": "llm-response-format",
          "phrase": "is constrained by",
          "category": "other",
          "description": "Concept synthesis is constrained by the LLM response format, which requires the LLM to return a JSON object matching the DiscoveredProject/ConceptProject structure."
        },
        {
          "id": "concept-synthesis-uses-llm-environment",
          "from": "concept-synthesis",
          "to": "llm-environment",
          "phrase": "uses",
          "category": "uses",
          "description": "Concept synthesis uses the LLM environment (LLMEnv) to configure model identifiers, API access, and runtime settings for its LLM calls."
        },
        {
          "id": "concept-synthesis-produces-concept-project",
          "from": "concept-synthesis",
          "to": "ConceptProject",
          "phrase": "produces",
          "category": "represents",
          "description": "Concept synthesis produces a ConceptProject (here as DiscoveredProject) that groups the discovered and enriched concept models for a repository."
        },
        {
          "id": "concept-synthesis-populates-concept-models",
          "from": "concept-synthesis",
          "to": "ConceptModel",
          "phrase": "populates",
          "category": "represents",
          "description": "Concept synthesis populates ConceptModels (here as DiscoveredModel) with discovered concepts, relationships, lifecycles, and stories inferred from code."
        },
        {
          "id": "concept-synthesis-derives-concepts-from-symbols",
          "from": "concept-synthesis",
          "to": "SymbolInfo",
          "phrase": "derives concepts from",
          "category": "uses",
          "description": "Concept synthesis derives higher-level concepts from low-level SymbolInfo extracted from the repository."
        },
        {
          "id": "concept-synthesis-derives-concepts-from-files",
          "from": "concept-synthesis",
          "to": "FileInfo",
          "phrase": "derives concepts from",
          "category": "uses",
          "description": "Concept synthesis uses FileInfo and extracted snippets to provide contextual code examples that inform the inferred concepts and models."
        }
      ],
      "rules": [
        {
          "id": "rule-llm-env-requires-api-key",
          "title": "LLM environment must include an API key",
          "text": "An LLM environment must contain a non-empty API key so that the LLM provider can authenticate the request.",
          "kind": "constraint",
          "conceptIds": [
            "llm-environment"
          ]
        },
        {
          "id": "rule-llm-env-requires-model",
          "title": "LLM environment must specify a model identifier",
          "text": "An LLM environment must specify which model to use so that the LLM invocation can be routed to the correct model.",
          "kind": "constraint",
          "conceptIds": [
            "llm-environment"
          ]
        },
        {
          "id": "rule-llm-env-base-url-default",
          "title": "LLM environment base URL defaults to provider standard endpoint",
          "text": "If an LLM environment does not specify a base URL, the LLM invocation will use the default provider base URL for chat completions.",
          "kind": "assumption",
          "conceptIds": [
            "llm-environment"
          ]
        },
        {
          "id": "rule-llm-message-role-required",
          "title": "LLM message must have a role",
          "text": "Every LLM message must specify a role, which in this system is either 'system' or 'user'.",
          "kind": "invariant",
          "conceptIds": [
            "llm-message"
          ]
        },
        {
          "id": "rule-llm-message-content-required",
          "title": "LLM message must have content",
          "text": "Every LLM message must include non-empty textual content to be meaningful to the LLM.",
          "kind": "constraint",
          "conceptIds": [
            "llm-message"
          ]
        },
        {
          "id": "rule-llm-invocation-requires-at-least-one-message",
          "title": "LLM invocation requires at least one message",
          "text": "An LLM invocation must include at least one LLM message in the messages list to provide context or a prompt to the model.",
          "kind": "constraint",
          "conceptIds": [
            "llm-message"
          ]
        },
        {
          "id": "rule-llm-message-role-limited",
          "title": "LLM message role is limited to system or user",
          "text": "Within this system, LLM messages are restricted to the 'system' and 'user' roles; other roles such as 'assistant' are not modeled.",
          "kind": "assumption",
          "conceptIds": [
            "llm-message"
          ]
        },
        {
          "id": "rule-llm-response-format-enum",
          "title": "Response format must be a supported option",
          "text": "LLM response format must be one of the supported values ('text' or 'json_object'); any other value is considered invalid and should not occur.",
          "kind": "constraint",
          "conceptIds": [
            "llm-response-format"
          ]
        },
        {
          "id": "rule-llm-response-format-defaults-to-text",
          "title": "Default response format is text",
          "text": "If no response format is specified for an LLM invocation, the system assumes a text response format and returns the LLM content as a string without attempting JSON parsing.",
          "kind": "assumption",
          "conceptIds": [
            "llm-response-format"
          ]
        },
        {
          "id": "rule-llm-response-format-json-requires-parseable-json",
          "title": "JSON response format requires valid JSON content",
          "text": "When the response format is 'json_object', the LLM's content must be valid JSON; otherwise, JSON parsing will fail and the invocation is treated as an error.",
          "kind": "invariant",
          "conceptIds": [
            "llm-response-format"
          ]
        },
        {
          "id": "rule-llm-response-format-json-requests-structured-output",
          "title": "JSON response format requests structured output from the LLM",
          "text": "When the response format is 'json_object', the invocation must request structured JSON output from the LLM provider (e.g., by setting the provider-specific response_format parameter).",
          "kind": "policy",
          "conceptIds": [
            "llm-response-format"
          ]
        },
        {
          "id": "rule-llm-invocation-requires-env",
          "title": "LLM invocation must have a valid environment",
          "text": "Every LLM invocation must be provided with an LLM environment that includes a model identifier and API key; without these, the invocation cannot be performed.",
          "kind": "constraint",
          "conceptIds": [
            "llm-invocation"
          ]
        },
        {
          "id": "rule-llm-invocation-requires-messages",
          "title": "LLM invocation must include at least one message",
          "text": "Every LLM invocation must include at least one LLM message to define the prompt content sent to the model.",
          "kind": "constraint",
          "conceptIds": [
            "llm-invocation"
          ]
        },
        {
          "id": "rule-llm-invocation-response-content-required",
          "title": "LLM invocation must yield non-empty content",
          "text": "An LLM invocation is considered successful only if the LLM returns a response whose first choice contains non-empty message content; otherwise the invocation is treated as an error.",
          "kind": "invariant",
          "conceptIds": [
            "llm-invocation"
          ]
        },
        {
          "id": "rule-llm-invocation-json-format-parsable",
          "title": "JSON response format must be parsable",
          "text": "When an LLM invocation requests a JSON object response format, the returned content must be valid JSON that can be parsed into the expected structure; invalid JSON causes the invocation to be treated as a failure.",
          "kind": "constraint",
          "conceptIds": [
            "llm-invocation"
          ]
        },
        {
          "id": "rule-concept-synthesis-requires-llm-env",
          "title": "Concept synthesis requires an LLM environment",
          "text": "Concept synthesis must be provided with a valid LLM environment (LLMEnv) so that it can invoke the LLM to discover and enrich project structure.",
          "kind": "constraint",
          "conceptIds": [
            "concept-synthesis"
          ]
        },
        {
          "id": "rule-concept-synthesis-operates-on-repo-root",
          "title": "Concept synthesis operates on a repository root",
          "text": "Concept synthesis requires a repository root path and associated scan results (symbols and files) as input to infer project, model, and concept structures.",
          "kind": "assumption",
          "conceptIds": [
            "concept-synthesis"
          ]
        },
        {
          "id": "rule-concept-synthesis-returns-structured-project",
          "title": "Concept synthesis returns a structured concept project",
          "text": "The primary output of concept synthesis must conform to the ConceptProject structure (here DiscoveredProject), including nested models and concepts suitable for downstream tooling.",
          "kind": "invariant",
          "conceptIds": [
            "concept-synthesis"
          ]
        }
      ],
      "lifecycles": [
        {
          "id": "lifecycle-llm-invocation-basic",
          "subjectConceptId": "llm-invocation",
          "stateConceptIds": [
            "llm-invocation-requested",
            "llm-invocation-in-flight",
            "llm-invocation-succeeded",
            "llm-invocation-failed"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "llm-invocation-requested",
          "terminalStateIds": [
            "llm-invocation-succeeded",
            "llm-invocation-failed"
          ]
        },
        {
          "id": "lifecycle-concept-synthesis-basic",
          "subjectConceptId": "concept-synthesis",
          "stateConceptIds": [
            "concept-synthesis-input-collected",
            "concept-synthesis-structure-discovered",
            "concept-synthesis-models-enriched"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "concept-synthesis-input-collected",
          "terminalStateIds": [
            "concept-synthesis-models-enriched"
          ]
        }
      ],
      "views": [
        {
          "id": "llm-synthesis-overview",
          "name": "LLM-based concept synthesis overview",
          "kind": "overview",
          "description": "High-level view of how the LLM environment, messages, and response format participate in an invocation that enables concept synthesis.",
          "conceptIds": [
            "llm-environment",
            "llm-message",
            "llm-response-format",
            "llm-invocation",
            "concept-synthesis"
          ],
          "relationshipIds": [
            "rel-llm-env-enables-llm-invocation",
            "llm-invocation-uses-env",
            "llm-invocation-includes-messages",
            "llm-invocation-selects-response-format",
            "llm-invocation-enables-concept-synthesis",
            "concept-synthesis-uses-llm-invocation",
            "concept-synthesis-uses-llm-message",
            "concept-synthesis-is-constrained-by-llm-response-format",
            "concept-synthesis-uses-llm-environment"
          ]
        },
        {
          "id": "llm-invocation-lifecycle",
          "name": "LLM invocation lifecycle",
          "kind": "lifecycle",
          "description": "Lifecycle of an LLM invocation: how environment, messages, and response format interact during a single call.",
          "conceptIds": [
            "llm-environment",
            "llm-message",
            "llm-response-format",
            "llm-invocation"
          ],
          "relationshipIds": [
            "rel-llm-env-enables-llm-invocation",
            "llm-invocation-uses-env",
            "llm-invocation-includes-messages",
            "llm-invocation-selects-response-format",
            "rel-llm-env-contextualizes-llm-message",
            "rel-llm-message-part-of-llm-invocation",
            "rel-llm-invocation-uses-llm-message",
            "rel-llm-message-influences-llm-response-format",
            "rel-llm-response-format-constrains-llm-invocation-output",
            "rel-llm-response-format-interprets-llm-message-content"
          ]
        },
        {
          "id": "llm-configuration-and-constraints",
          "name": "LLM configuration and constraints",
          "kind": "implementation",
          "description": "How the LLM environment and response format constrain and shape messages and invocation behavior.",
          "conceptIds": [
            "llm-environment",
            "llm-message",
            "llm-response-format",
            "llm-invocation"
          ],
          "relationshipIds": [
            "rel-llm-env-selects-llm-response-format",
            "rel-llm-env-limits-llm-response-format",
            "rel-llm-env-contextualizes-llm-message",
            "rel-llm-message-uses-llm-environment",
            "rel-llm-message-influences-llm-response-format",
            "rel-llm-response-format-interprets-llm-message-content",
            "rel-llm-response-format-constrains-llm-invocation-output",
            "rel-llm-invocation-selects-llm-response-format"
          ]
        },
        {
          "id": "concept-synthesis-from-code",
          "name": "Concept synthesis from code artifacts",
          "kind": "lifecycle",
          "description": "How concept synthesis uses LLM machinery and code-derived inputs to produce concept projects and models.",
          "conceptIds": [
            "concept-synthesis",
            "llm-environment",
            "llm-message",
            "llm-invocation",
            "llm-response-format",
            "ConceptProject",
            "ConceptModel",
            "SymbolInfo",
            "FileInfo"
          ],
          "relationshipIds": [
            "concept-synthesis-uses-llm-environment",
            "concept-synthesis-uses-llm-message",
            "concept-synthesis-uses-llm-invocation",
            "concept-synthesis-is-constrained-by-llm-response-format",
            "concept-synthesis-derives-concepts-from-symbols",
            "concept-synthesis-derives-concepts-from-files",
            "concept-synthesis-produces-concept-project",
            "concept-synthesis-populates-concept-models",
            "llm-invocation-enables-concept-synthesis"
          ]
        },
        {
          "id": "concept-synthesis-artifacts",
          "name": "Concept synthesis artifacts and outputs",
          "kind": "structure",
          "description": "Artifact-centric view of concept synthesis: what it consumes and what conceptual structures it produces.",
          "conceptIds": [
            "concept-synthesis",
            "ConceptProject",
            "ConceptModel",
            "SymbolInfo",
            "FileInfo"
          ],
          "relationshipIds": [
            "concept-synthesis-derives-concepts-from-symbols",
            "concept-synthesis-derives-concepts-from-files",
            "concept-synthesis-produces-concept-project",
            "concept-synthesis-populates-concept-models"
          ]
        }
      ],
      "storyViews": [
        {
          "id": "single-llm-call-for-concept-synthesis",
          "name": "Single LLM Call for Concept Synthesis",
          "kind": "system_flow",
          "description": "A straightforward, one-shot LLM invocation that turns extracted code symbols and files into a populated concept project and models.",
          "tags": [
            "one-shot",
            "happy-path",
            "system"
          ],
          "focusConceptId": "concept-synthesis",
          "steps": [
            {
              "id": "prepare-llm-environment",
              "index": 0,
              "title": "Prepare LLM Environment",
              "narrative": "The system initializes the LLM environment with API keys, model identifiers, and runtime settings, which will govern how the LLM can be called and what response formats are available.",
              "conceptIds": [
                "llm-environment",
                "llm-response-format"
              ],
              "relationshipIds": [
                "rel-llm-env-enables-llm-invocation",
                "rel-llm-env-selects-llm-response-format",
                "rel-llm-environment-limits-llm-response-format"
              ],
              "primaryConceptIds": [
                "llm-environment"
              ],
              "primaryRelationshipIds": [
                "rel-llm-env-enables-llm-invocation"
              ]
            },
            {
              "id": "construct-llm-message-from-code",
              "index": 1,
              "title": "Construct LLM Message from Code Artifacts",
              "narrative": "Concept synthesis logic assembles an LLM message that embeds selected SymbolInfo and FileInfo details, framing them as a task for the LLM to derive higher-level concepts.",
              "conceptIds": [
                "llm-message",
                "llm-environment",
                "concept-synthesis"
              ],
              "relationshipIds": [
                "rel-llm-env-contextualizes-llm-message",
                "rel-llm-message-uses-llm-environment",
                "concept-synthesis-uses-llm-message",
                "concept-synthesis-derives-concepts-from-symbols",
                "concept-synthesis-derives-concepts-from-files"
              ],
              "primaryConceptIds": [
                "llm-message",
                "concept-synthesis"
              ],
              "primaryRelationshipIds": [
                "concept-synthesis-uses-llm-message"
              ]
            },
            {
              "id": "select-response-format-for-concepts",
              "index": 2,
              "title": "Select Response Format for Concept Output",
              "narrative": "The system chooses an LLM response format that specifies how concepts, relationships, and model structures should be returned, shaping how the LLM will structure its answer.",
              "conceptIds": [
                "llm-response-format",
                "llm-invocation",
                "llm-message"
              ],
              "relationshipIds": [
                "rel-llm-invocation-selects-llm-response-format",
                "rel-llm-response-format-constrains-llm-invocation-output",
                "rel-llm-message-influences-llm-response-format",
                "rel-llm-response-format-interprets-llm-message-content"
              ],
              "primaryConceptIds": [
                "llm-response-format"
              ],
              "primaryRelationshipIds": [
                "rel-llm-invocation-selects-llm-response-format"
              ]
            },
            {
              "id": "invoke-llm-with-context",
              "index": 3,
              "title": "Invoke LLM with Context and Format",
              "narrative": "An LLM invocation is executed using the prepared environment, the constructed message, and the selected response format to generate structured conceptual output.",
              "conceptIds": [
                "llm-invocation",
                "llm-environment",
                "llm-message",
                "llm-response-format"
              ],
              "relationshipIds": [
                "llm-invocation-uses-env",
                "llm-invocation-includes-messages",
                "rel-llm-invocation-uses-llm-message",
                "rel-llm-response-format-constrains-llm-invocation-output"
              ],
              "primaryConceptIds": [
                "llm-invocation"
              ],
              "primaryRelationshipIds": [
                "llm-invocation-uses-env"
              ]
            },
            {
              "id": "perform-concept-synthesis-from-llm-output",
              "index": 4,
              "title": "Perform Concept Synthesis from LLM Output",
              "narrative": "Concept synthesis consumes the LLM invocation results, interpreting them within the constraints of the response format to derive coherent domain concepts and relationships.",
              "conceptIds": [
                "concept-synthesis",
                "llm-invocation",
                "llm-response-format",
                "llm-message"
              ],
              "relationshipIds": [
                "llm-invocation-enables-concept-synthesis",
                "concept-synthesis-uses-llm-invocation",
                "concept-synthesis-is-constrained-by-llm-response-format",
                "concept-synthesis-uses-llm-message"
              ],
              "primaryConceptIds": [
                "concept-synthesis"
              ],
              "primaryRelationshipIds": [
                "llm-invocation-enables-concept-synthesis"
              ]
            },
            {
              "id": "populate-concept-project-and-models",
              "index": 5,
              "title": "Populate Concept Project and Models",
              "narrative": "Using the synthesized concepts, the system populates ConceptModel structures and assembles them into a ConceptProject that represents the codebase at a higher level.",
              "conceptIds": [
                "concept-synthesis"
              ],
              "relationshipIds": [
                "concept-synthesis-produces-concept-project",
                "concept-synthesis-populates-concept-models"
              ],
              "primaryConceptIds": [
                "concept-synthesis"
              ],
              "primaryRelationshipIds": [
                "concept-synthesis-produces-concept-project"
              ]
            }
          ]
        },
        {
          "id": "iterative-refinement-of-concepts",
          "name": "Iterative Refinement of Concepts via Multiple LLM Invocations",
          "kind": "system_flow",
          "description": "The system refines an initial concept model through multiple LLM invocations, adjusting messages and formats based on previous results.",
          "tags": [
            "iteration",
            "refinement"
          ],
          "focusConceptId": "llm-message",
          "steps": [
            {
              "id": "initial-environment-and-format-setup",
              "index": 0,
              "title": "Initial Environment and Format Setup",
              "narrative": "The system configures the LLM environment and selects an initial response format suitable for broad, exploratory concept extraction.",
              "conceptIds": [
                "llm-environment",
                "llm-response-format"
              ],
              "relationshipIds": [
                "rel-llm-env-enables-llm-invocation",
                "rel-llm-env-selects-llm-response-format",
                "rel-llm-environment-limits-llm-response-format"
              ],
              "primaryConceptIds": [
                "llm-environment"
              ],
              "primaryRelationshipIds": [
                "rel-llm-env-selects-llm-response-format"
              ]
            },
            {
              "id": "first-pass-message-and-invocation",
              "index": 1,
              "title": "First-pass Message and Invocation",
              "narrative": "Concept synthesis constructs a broad LLM message summarizing key symbols and files, then triggers an LLM invocation to obtain an initial, coarse-grained concept map.",
              "conceptIds": [
                "llm-message",
                "llm-invocation",
                "concept-synthesis",
                "llm-environment"
              ],
              "relationshipIds": [
                "rel-llm-env-contextualizes-llm-message",
                "llm-invocation-includes-messages",
                "llm-invocation-uses-env",
                "concept-synthesis-uses-llm-message",
                "concept-synthesis-uses-llm-invocation"
              ],
              "primaryConceptIds": [
                "llm-message",
                "llm-invocation"
              ],
              "primaryRelationshipIds": [
                "llm-invocation-includes-messages"
              ]
            },
            {
              "id": "analyze-initial-output-and-identify-gaps",
              "index": 2,
              "title": "Analyze Initial Output and Identify Gaps",
              "narrative": "Concept synthesis inspects the initial LLM output, noticing missing relationships or ambiguous concepts, and plans follow-up questions to clarify these gaps.",
              "conceptIds": [
                "concept-synthesis",
                "llm-response-format",
                "llm-message"
              ],
              "relationshipIds": [
                "concept-synthesis-is-constrained-by-llm-response-format",
                "rel-llm-response-format-interprets-llm-message-content"
              ],
              "primaryConceptIds": [
                "concept-synthesis"
              ],
              "primaryRelationshipIds": [
                "concept-synthesis-is-constrained-by-llm-response-format"
              ]
            },
            {
              "id": "refine-llm-message-based-on-gaps",
              "index": 3,
              "title": "Refine LLM Message Based on Gaps",
              "narrative": "A new LLM message is constructed that references the earlier output and asks the LLM to elaborate on specific modules, edge cases, or domain concepts that were unclear.",
              "conceptIds": [
                "llm-message",
                "concept-synthesis",
                "llm-environment"
              ],
              "relationshipIds": [
                "rel-llm-env-contextualizes-llm-message",
                "rel-llm-message-uses-llm-environment",
                "concept-synthesis-uses-llm-message"
              ],
              "primaryConceptIds": [
                "llm-message"
              ],
              "primaryRelationshipIds": [
                "rel-llm-message-uses-llm-environment"
              ]
            },
            {
              "id": "second-invocation-with-adjusted-format",
              "index": 4,
              "title": "Second Invocation with Adjusted Format",
              "narrative": "The system optionally tightens the response format to demand more structured relationships, then performs another LLM invocation using the refined message.",
              "conceptIds": [
                "llm-invocation",
                "llm-response-format",
                "llm-message",
                "llm-environment"
              ],
              "relationshipIds": [
                "rel-llm-invocation-selects-llm-response-format",
                "rel-llm-response-format-constrains-llm-invocation-output",
                "llm-invocation-uses-env",
                "llm-invocation-includes-messages"
              ],
              "primaryConceptIds": [
                "llm-invocation",
                "llm-response-format"
              ],
              "primaryRelationshipIds": [
                "rel-llm-invocation-selects-llm-response-format"
              ]
            },
            {
              "id": "merge-refined-output-into-concept-models",
              "index": 5,
              "title": "Merge Refined Output into Concept Models",
              "narrative": "Concept synthesis merges the refined LLM output with the initial concepts, updating ConceptModel structures and the overall ConceptProject to reflect the clarified understanding.",
              "conceptIds": [
                "concept-synthesis",
                "llm-invocation",
                "llm-response-format"
              ],
              "relationshipIds": [
                "llm-invocation-enables-concept-synthesis",
                "concept-synthesis-uses-llm-invocation",
                "concept-synthesis-populates-concept-models",
                "concept-synthesis-produces-concept-project"
              ],
              "primaryConceptIds": [
                "concept-synthesis"
              ],
              "primaryRelationshipIds": [
                "concept-synthesis-populates-concept-models"
              ]
            }
          ]
        },
        {
          "id": "admin-tunes-llm-environment-and-format",
          "name": "Admin Tunes LLM Environment and Response Format",
          "kind": "admin_flow",
          "description": "An administrator configures and tunes the LLM environment and response formats to balance cost, performance, and concept model fidelity.",
          "tags": [
            "admin",
            "configuration"
          ],
          "focusConceptId": "llm-environment",
          "steps": [
            {
              "id": "admin-configures-llm-environment",
              "index": 0,
              "title": "Admin Configures LLM Environment",
              "narrative": "An admin sets API keys, selects a base model, and defines runtime limits, establishing the LLM environment that all future invocations will use.",
              "conceptIds": [
                "llm-environment"
              ],
              "relationshipIds": [
                "rel-llm-env-enables-llm-invocation"
              ],
              "primaryConceptIds": [
                "llm-environment"
              ],
              "primaryRelationshipIds": [
                "rel-llm-env-enables-llm-invocation"
              ]
            },
            {
              "id": "admin-limits-available-response-formats",
              "index": 1,
              "title": "Admin Limits Available Response Formats",
              "narrative": "Within this environment, the admin restricts which LLM response formats are allowed, ensuring that only schemas compatible with downstream concept synthesis are used.",
              "conceptIds": [
                "llm-environment",
                "llm-response-format"
              ],
              "relationshipIds": [
                "rel-llm-env-selects-llm-response-format",
                "rel-llm-environment-limits-llm-response-format"
              ],
              "primaryConceptIds": [
                "llm-environment"
              ],
              "primaryRelationshipIds": [
                "rel-llm-environment-limits-llm-response-format"
              ]
            },
            {
              "id": "define-message-context-rules",
              "index": 2,
              "title": "Define Message Context Rules",
              "narrative": "The admin configures how repository metadata and project settings are injected into LLM messages, shaping the context in which prompts are interpreted.",
              "conceptIds": [
                "llm-environment",
                "llm-message"
              ],
              "relationshipIds": [
                "rel-llm-env-contextualizes-llm-message",
                "rel-llm-message-uses-llm-environment"
              ],
              "primaryConceptIds": [
                "llm-environment",
                "llm-message"
              ],
              "primaryRelationshipIds": [
                "rel-llm-env-contextualizes-llm-message"
              ]
            },
            {
              "id": "test-invocation-with-sample-repo",
              "index": 3,
              "title": "Test Invocation with Sample Repository",
              "narrative": "Using a small sample repository, the admin triggers a test LLM invocation to see how the configured environment and response format affect the generated concepts.",
              "conceptIds": [
                "llm-invocation",
                "llm-environment",
                "llm-message",
                "llm-response-format"
              ],
              "relationshipIds": [
                "llm-invocation-uses-env",
                "llm-invocation-includes-messages",
                "rel-llm-invocation-selects-llm-response-format",
                "rel-llm-response-format-constrains-llm-invocation-output"
              ],
              "primaryConceptIds": [
                "llm-invocation"
              ],
              "primaryRelationshipIds": [
                "llm-invocation-uses-env"
              ]
            },
            {
              "id": "evaluate-impact-on-concept-synthesis",
              "index": 4,
              "title": "Evaluate Impact on Concept Synthesis",
              "narrative": "The admin reviews how concept synthesis uses the test invocation output and adjusts environment or format settings if the resulting ConceptModels are too sparse or noisy.",
              "conceptIds": [
                "concept-synthesis",
                "llm-invocation",
                "llm-response-format"
              ],
              "relationshipIds": [
                "llm-invocation-enables-concept-synthesis",
                "concept-synthesis-uses-llm-invocation",
                "concept-synthesis-is-constrained-by-llm-response-format"
              ],
              "primaryConceptIds": [
                "concept-synthesis"
              ],
              "primaryRelationshipIds": [
                "concept-synthesis-is-constrained-by-llm-response-format"
              ]
            }
          ]
        },
        {
          "id": "error-handling-when-llm-output-breaks-schema",
          "name": "Error Handling When LLM Output Breaks Schema",
          "kind": "error_flow",
          "description": "The system detects when LLM output does not match the expected response format and recovers by adjusting messages and formats.",
          "tags": [
            "error",
            "recovery"
          ],
          "focusConceptId": "llm-response-format",
          "steps": [
            {
              "id": "invoke-llm-with-strict-format",
              "index": 0,
              "title": "Invoke LLM with Strict Response Format",
              "narrative": "The system performs an LLM invocation using a strict response format that demands well-structured concept and relationship data.",
              "conceptIds": [
                "llm-invocation",
                "llm-response-format",
                "llm-environment",
                "llm-message"
              ],
              "relationshipIds": [
                "llm-invocation-uses-env",
                "llm-invocation-includes-messages",
                "rel-llm-invocation-selects-llm-response-format",
                "rel-llm-response-format-constrains-llm-invocation-output"
              ],
              "primaryConceptIds": [
                "llm-invocation",
                "llm-response-format"
              ],
              "primaryRelationshipIds": [
                "rel-llm-response-format-constrains-llm-invocation-output"
              ]
            },
            {
              "id": "detect-schema-mismatch",
              "index": 1,
              "title": "Detect Schema Mismatch in LLM Output",
              "narrative": "When parsing the LLM output, concept synthesis detects that the content does not conform to the expected response format, preventing safe population of ConceptModels.",
              "conceptIds": [
                "concept-synthesis",
                "llm-response-format",
                "llm-invocation"
              ],
              "relationshipIds": [
                "concept-synthesis-is-constrained-by-llm-response-format",
                "llm-invocation-enables-concept-synthesis"
              ],
              "primaryConceptIds": [
                "concept-synthesis"
              ],
              "primaryRelationshipIds": [
                "concept-synthesis-is-constrained-by-llm-response-format"
              ]
            },
            {
              "id": "craft-correction-message",
              "index": 2,
              "title": "Craft Correction Message to LLM",
              "narrative": "The system constructs a new LLM message that includes the invalid output and explicitly instructs the LLM to reformat the response to match the required schema.",
              "conceptIds": [
                "llm-message",
                "llm-environment",
                "concept-synthesis"
              ],
              "relationshipIds": [
                "rel-llm-env-contextualizes-llm-message",
                "rel-llm-message-uses-llm-environment",
                "concept-synthesis-uses-llm-message"
              ],
              "primaryConceptIds": [
                "llm-message"
              ],
              "primaryRelationshipIds": [
                "rel-llm-message-uses-llm-environment"
              ]
            },
            {
              "id": "retry-invocation-with-guidance",
              "index": 3,
              "title": "Retry Invocation with Additional Guidance",
              "narrative": "A second LLM invocation is made using the corrective message and the same response format, relying on the format constraints to steer the LLM toward valid output.",
              "conceptIds": [
                "llm-invocation",
                "llm-message",
                "llm-response-format",
                "llm-environment"
              ],
              "relationshipIds": [
                "llm-invocation-uses-env",
                "llm-invocation-includes-messages",
                "rel-llm-invocation-selects-llm-response-format",
                "rel-llm-response-format-constrains-llm-invocation-output"
              ],
              "primaryConceptIds": [
                "llm-invocation"
              ],
              "primaryRelationshipIds": [
                "llm-invocation-includes-messages"
              ]
            },
            {
              "id": "resume-concept-synthesis",
              "index": 4,
              "title": "Resume Concept Synthesis with Validated Output",
              "narrative": "Once the new output matches the response format, concept synthesis proceeds to derive concepts and populate ConceptModels and the ConceptProject as originally intended.",
              "conceptIds": [
                "concept-synthesis",
                "llm-invocation",
                "llm-response-format"
              ],
              "relationshipIds": [
                "concept-synthesis-uses-llm-invocation",
                "concept-synthesis-is-constrained-by-llm-response-format",
                "concept-synthesis-populates-concept-models",
                "concept-synthesis-produces-concept-project"
              ],
              "primaryConceptIds": [
                "concept-synthesis"
              ],
              "primaryRelationshipIds": [
                "concept-synthesis-populates-concept-models"
              ]
            }
          ]
        },
        {
          "id": "integration-with-upstream-code-extraction",
          "name": "Integration with Upstream Code Extraction",
          "kind": "integration_flow",
          "description": "Concept synthesis integrates with upstream code extraction, using LLM invocations to transform SymbolInfo and FileInfo into a coherent concept project.",
          "tags": [
            "integration",
            "pipeline"
          ],
          "focusConceptId": "concept-synthesis",
          "steps": [
            {
              "id": "receive-symbol-and-file-info",
              "index": 0,
              "title": "Receive Symbol and File Information",
              "narrative": "Concept synthesis receives SymbolInfo and FileInfo from an upstream extraction process, preparing to translate these low-level artifacts into higher-level concepts.",
              "conceptIds": [
                "concept-synthesis"
              ],
              "relationshipIds": [
                "concept-synthesis-derives-concepts-from-symbols",
                "concept-synthesis-derives-concepts-from-files"
              ],
              "primaryConceptIds": [
                "concept-synthesis"
              ],
              "primaryRelationshipIds": [
                "concept-synthesis-derives-concepts-from-symbols"
              ]
            },
            {
              "id": "configure-environment-for-repo",
              "index": 1,
              "title": "Configure LLM Environment for Repository",
              "narrative": "The system configures the LLM environment with repository-specific settings, such as language, framework, and size constraints, which will shape subsequent invocations.",
              "conceptIds": [
                "llm-environment",
                "concept-synthesis"
              ],
              "relationshipIds": [
                "rel-llm-env-enables-llm-invocation",
                "concept-synthesis-uses-llm-environment"
              ],
              "primaryConceptIds": [
                "llm-environment"
              ],
              "primaryRelationshipIds": [
                "concept-synthesis-uses-llm-environment"
              ]
            },
            {
              "id": "build-contextual-llm-message",
              "index": 2,
              "title": "Build Contextual LLM Message from Extracted Code",
              "narrative": "Using the extracted symbols and files, concept synthesis constructs an LLM message that summarizes key structures and asks for domain-level concepts and relationships.",
              "conceptIds": [
                "llm-message",
                "llm-environment",
                "concept-synthesis"
              ],
              "relationshipIds": [
                "rel-llm-env-contextualizes-llm-message",
                "rel-llm-message-uses-llm-environment",
                "concept-synthesis-uses-llm-message",
                "concept-synthesis-derives-concepts-from-symbols",
                "concept-synthesis-derives-concepts-from-files"
              ],
              "primaryConceptIds": [
                "llm-message",
                "concept-synthesis"
              ],
              "primaryRelationshipIds": [
                "concept-synthesis-uses-llm-message"
              ]
            },
            {
              "id": "invoke-llm-and-generate-concepts",
              "index": 3,
              "title": "Invoke LLM and Generate Conceptual Output",
              "narrative": "An LLM invocation is executed with the contextual message and a chosen response format, producing structured conceptual descriptions of the codebase.",
              "conceptIds": [
                "llm-invocation",
                "llm-message",
                "llm-response-format",
                "llm-environment"
              ],
              "relationshipIds": [
                "llm-invocation-uses-env",
                "llm-invocation-includes-messages",
                "rel-llm-invocation-selects-llm-response-format",
                "rel-llm-response-format-constrains-llm-invocation-output"
              ],
              "primaryConceptIds": [
                "llm-invocation"
              ],
              "primaryRelationshipIds": [
                "llm-invocation-uses-env"
              ]
            },
            {
              "id": "synthesize-and-export-concept-project",
              "index": 4,
              "title": "Synthesize and Export Concept Project",
              "narrative": "Concept synthesis consumes the LLM output, populates ConceptModels, and exports a ConceptProject that downstream tools can visualize or further analyze.",
              "conceptIds": [
                "concept-synthesis",
                "llm-invocation",
                "llm-response-format"
              ],
              "relationshipIds": [
                "llm-invocation-enables-concept-synthesis",
                "concept-synthesis-uses-llm-invocation",
                "concept-synthesis-is-constrained-by-llm-response-format",
                "concept-synthesis-populates-concept-models",
                "concept-synthesis-produces-concept-project"
              ],
              "primaryConceptIds": [
                "concept-synthesis"
              ],
              "primaryRelationshipIds": [
                "concept-synthesis-produces-concept-project"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "concept-project-management",
      "title": "Concept Project & Model Management",
      "description": "This model focuses on how concept projects, models, and related artifacts are structured, identified, and organized for ongoing use and collaboration.",
      "concepts": [
        {
          "id": "concept-project",
          "label": "Concept project",
          "category": "thing",
          "description": "A container for one or more concept models that describe the domain of a particular codebase or product area.",
          "aliases": [
            "Concept project",
            "Project",
            "Repository",
            "Workspace"
          ],
          "notes": "A Concept project is a top-level workspace that groups multiple concept models describing a single product, system, or domain. It provides a high-level summary, narrative context, and organizational metadata (tags, repo URL, notes) so humans, LLMs, and tooling have a single entry point into the modeled codebase or product area."
        },
        {
          "id": "project-registry",
          "label": "Project registry",
          "category": "thing",
          "description": "A catalog of concept projects and their entries, enabling discovery and management of multiple modeled systems.",
          "aliases": [
            "ProjectRegistry",
            "project registry",
            "project catalog",
            "project index",
            "project list"
          ],
          "notes": "A Project registry is a lightweight catalog of concept projects, optimized for discovery and navigation rather than full project detail. Each entry in the registry (ProjectEntry) captures just enough metadata (id, name, path, updatedAt) to locate and present a project, while the full ConceptProject is defined elsewhere. The registry is the place where tools and UIs look to find available concept projects/workspaces."
        },
        {
          "id": "concept-model",
          "label": "Concept model",
          "category": "thing",
          "description": "A coherent set of concepts, relationships, rules, and views that together describe a particular aspect or subsystem of a domain.",
          "aliases": [
            "ConceptModel",
            "model",
            "concept model"
          ],
          "notes": "A concept model is an individual, coherent model within a Concept project that describes some aspect, subsystem, or slice of the overall domain. In the code, it appears as `ConceptModel` and is treated as a unit that can be listed, opened as a primary/default model, and referenced from other models via external references. It is distinct from the higher-level Concept project, which groups multiple concept models."
        },
        {
          "id": "concept",
          "label": "Concept",
          "category": "thing",
          "description": "A named domain element such as a thing, activity, role, state, event, place, or time that appears in a concept model.",
          "aliases": [
            "Concept",
            "Concept element",
            "Domain concept",
            "Named domain element"
          ],
          "notes": "A Concept is a named domain element (thing, activity, role, state, event, place, or time) that appears inside a ConceptModel. It is the primary building block used to describe the domain in a structured way. Concepts are referenced by relationships, model views, and story views/steps, but the provided code snippet only shows that ConceptModel contains concepts; it does not expose the internal structure of a Concept."
        },
        {
          "id": "relationship",
          "label": "Relationship",
          "category": "thing",
          "description": "A connection between two or more concepts that describes how they interact or depend on each other in the domain.",
          "aliases": [
            "edge",
            "link",
            "connection",
            "association"
          ],
          "notes": "A Relationship connects two or more Concepts within a ConceptModel to express how they interact, depend on, or relate to each other in the modeled domain. Relationships are first-class elements of a concept model (not just annotations on concepts) and are used by views and stories to explain domain behavior."
        },
        {
          "id": "model-rule",
          "label": "Model rule",
          "category": "thing",
          "description": "A constraint, heuristic, or pattern that governs how concepts and relationships behave or should be interpreted within a model.",
          "aliases": [
            "rule",
            "model constraint",
            "model heuristic",
            "model pattern"
          ],
          "notes": "A model rule is a declarative guideline that shapes how a concept model should be interpreted or constructed. It can be a hard constraint (must hold), a heuristic (usually true or recommended), or a pattern (preferred way to structure concepts and relationships). Model rules apply at the level of the concept model and govern the behavior and interpretation of concepts and relationships within that model."
        },
        {
          "id": "concept-lifecycle",
          "label": "Concept lifecycle",
          "category": "thing",
          "description": "A description of the states a concept can pass through over time and the transitions between those states.",
          "aliases": [
            "concept state machine",
            "concept state lifecycle",
            "concept status lifecycle"
          ],
          "notes": "A concept lifecycle describes the possible states a Concept can occupy over time within a ConceptModel and the allowed transitions between those states. It is defined at the model level and then applied to individual concepts that \"may have\" a lifecycle. The lifecycle is a modeling artifact, not runtime code behavior; it is used to visualize and reason about how a domain concept evolves (e.g., Draft → Reviewed → Approved)."
        },
        {
          "id": "model-view",
          "label": "Model view",
          "category": "thing",
          "description": "A particular visualization or slice of a concept model, tailored to highlight certain concepts, relationships, or stories.",
          "aliases": [
            "view",
            "model slice",
            "visualization",
            "concept model view"
          ],
          "notes": "A model view is a particular visualization or slice of a concept model, tailored to highlight specific concepts, relationships, lifecycles, or stories. It is used to present the same underlying concept model from different perspectives (e.g., structural overview, lifecycle focus, scenario focus) without changing the underlying concepts or relationships."
        },
        {
          "id": "story-view",
          "label": "Story view",
          "category": "thing",
          "description": "A narrative-oriented view that presents a sequence of steps or events to explain how concepts interact in a scenario.",
          "aliases": [
            "Story view",
            "story-view",
            "storyView"
          ],
          "notes": "A Story view is a narrative-oriented model view that explains how concepts and relationships from a Concept model interact over time in a specific scenario. It is composed of ordered Story steps, each referencing particular Concepts and Relationships, and is used to provide human-readable, scenario-based explanations of the domain captured in a Concept model."
        },
        {
          "id": "story-step",
          "label": "Story step",
          "category": "thing",
          "description": "An individual step or moment within a story view that references specific concepts and relationships.",
          "aliases": [
            "Story step",
            "story-step",
            "StoryStep"
          ],
          "notes": "A story step is an atomic moment or frame within a story-view that highlights how specific concepts and relationships from a concept-model interact at that point in the narrative. It is primarily a narrative/visualization construct rather than a new domain entity, and serves to break a story-view into ordered, explainable increments."
        }
      ],
      "relationships": [
        {
          "id": "concept-project-has-concept-models",
          "from": "concept-project",
          "to": "concept-model",
          "phrase": "contains concept models",
          "category": "part_of",
          "description": "A Concept project contains one or more concept models that together describe the domain of a particular codebase, product, or system."
        },
        {
          "id": "concept-project-listed-in-project-registry",
          "from": "concept-project",
          "to": "project-registry",
          "phrase": "is listed in",
          "category": "part_of",
          "description": "A Concept project appears as an entry in a project registry so that multiple modeled systems can be discovered and managed."
        },
        {
          "id": "project-registry-contains-concept-projects",
          "from": "project-registry",
          "to": "concept-project",
          "phrase": "contains entries for",
          "category": "part_of",
          "description": "A Project registry maintains a catalog of concept projects, each represented by a project entry with basic identifying information."
        },
        {
          "id": "concept-project-provides-entry-point-to-concept-models",
          "from": "concept-project",
          "to": "concept-model",
          "phrase": "provides entry point to",
          "category": "enables",
          "description": "A Concept project acts as the primary entry point for LLMs and project tooling to access and navigate its contained concept models."
        },
        {
          "id": "project-registry-contains-project-entries",
          "from": "project-registry",
          "to": "concept-project",
          "phrase": "contains entries for",
          "category": "part_of",
          "description": "The project registry contains entries that reference concept projects, allowing tools and users to discover which concept projects exist."
        },
        {
          "id": "concept-project-is-listed-in-registry",
          "from": "concept-project",
          "to": "project-registry",
          "phrase": "is listed in",
          "category": "part_of",
          "description": "Each concept project can be listed in a project registry via a corresponding project entry, making the project discoverable."
        },
        {
          "id": "concept-model-contained-in-concept-project",
          "from": "concept-model",
          "to": "concept-project",
          "phrase": "is grouped within",
          "category": "part_of",
          "description": "Each concept model belongs to a specific concept project, which groups multiple related models around a single product, system, or domain."
        },
        {
          "id": "concept-project-contains-concept-models",
          "from": "concept-project",
          "to": "concept-model",
          "phrase": "contains",
          "category": "part_of",
          "description": "A concept project contains one or more concept models that together describe different aspects or subsystems of the project’s domain."
        },
        {
          "id": "concept-model-contains-concepts",
          "from": "concept-model",
          "to": "concept",
          "phrase": "contains",
          "category": "part_of",
          "description": "A concept model is composed of multiple concepts that represent the domain elements relevant to the modeled aspect or subsystem."
        },
        {
          "id": "concept-model-contains-relationships",
          "from": "concept-model",
          "to": "relationship",
          "phrase": "contains",
          "category": "part_of",
          "description": "A concept model includes relationships that connect its concepts and describe how they interact or depend on each other."
        },
        {
          "id": "concept-model-applies-model-rules",
          "from": "concept-model",
          "to": "model-rule",
          "phrase": "is governed by",
          "category": "uses",
          "description": "A concept model is governed by model rules that constrain or guide how its concepts and relationships should be interpreted."
        },
        {
          "id": "concept-model-defines-concept-lifecycles",
          "from": "concept-model",
          "to": "concept-lifecycle",
          "phrase": "defines",
          "category": "uses",
          "description": "A concept model may define lifecycles for its concepts, describing the states and transitions those concepts can undergo."
        },
        {
          "id": "concept-model-has-model-views",
          "from": "concept-model",
          "to": "model-view",
          "phrase": "has",
          "category": "part_of",
          "description": "A concept model can be explored through one or more model views that present specific visualizations or slices of the model."
        },
        {
          "id": "concept-model-has-story-views",
          "from": "concept-model",
          "to": "story-view",
          "phrase": "has",
          "category": "part_of",
          "description": "A concept model can be narrated through story views that explain how its concepts interact in particular scenarios."
        },
        {
          "id": "story-view-references-concept-model-elements",
          "from": "story-view",
          "to": "concept-model",
          "phrase": "references elements from",
          "category": "uses",
          "description": "A story view draws on the concepts and relationships defined in a concept model to construct narrative sequences."
        },
        {
          "id": "story-step-references-concept-model-elements",
          "from": "story-step",
          "to": "concept-model",
          "phrase": "references elements from",
          "category": "uses",
          "description": "Each story step references specific concepts and relationships that are defined within a concept model."
        },
        {
          "id": "concept-contained-in-concept-model",
          "from": "concept",
          "to": "concept-model",
          "phrase": "is contained in",
          "category": "part_of",
          "description": "Each Concept exists within a Concept model, which groups related concepts, relationships, and rules into a coherent description of part of the domain."
        },
        {
          "id": "concept-participates-in-relationship",
          "from": "concept",
          "to": "relationship",
          "phrase": "participates in",
          "category": "uses",
          "description": "Concepts are the endpoints or participants in Relationships, which describe how concepts interact or depend on each other in the domain."
        },
        {
          "id": "concept-governed-by-model-rule",
          "from": "concept",
          "to": "model-rule",
          "phrase": "is governed by",
          "category": "uses",
          "description": "Concepts, as elements of a Concept model, are subject to Model rules that constrain or guide how they should be interpreted and used."
        },
        {
          "id": "concept-has-concept-lifecycle",
          "from": "concept",
          "to": "concept-lifecycle",
          "phrase": "may have",
          "category": "uses",
          "description": "A Concept can be associated with a Concept lifecycle that describes the states it can pass through and the transitions between those states."
        },
        {
          "id": "concept-appears-in-model-view",
          "from": "concept",
          "to": "model-view",
          "phrase": "appears in",
          "category": "uses",
          "description": "Concepts can be included in Model views, which visualize selected concepts and relationships from a Concept model."
        },
        {
          "id": "concept-appears-in-story-view",
          "from": "concept",
          "to": "story-view",
          "phrase": "appears in",
          "category": "uses",
          "description": "Concepts can be referenced in Story views that narrate how domain elements interact over time or across scenarios."
        },
        {
          "id": "concept-appears-in-story-step",
          "from": "concept",
          "to": "story-step",
          "phrase": "is referenced by",
          "category": "uses",
          "description": "Individual Story steps reference specific Concepts (and Relationships) to describe what happens at each moment in a scenario."
        },
        {
          "id": "relationship-contained-in-concept-model",
          "from": "relationship",
          "to": "concept-model",
          "phrase": "is contained in",
          "category": "part_of",
          "description": "Each relationship belongs to a specific concept model, which defines the scope and context in which that relationship is valid."
        },
        {
          "id": "relationship-connects-concept",
          "from": "relationship",
          "to": "concept",
          "phrase": "connects",
          "category": "uses",
          "description": "A relationship connects two or more concepts, describing how those concepts interact, depend on, or are associated with each other in the domain."
        },
        {
          "id": "relationship-governed-by-model-rule",
          "from": "relationship",
          "to": "model-rule",
          "phrase": "is governed by",
          "category": "uses",
          "description": "Model rules can constrain or interpret relationships, specifying valid patterns, cardinalities, or semantics for how concepts may be related."
        },
        {
          "id": "relationship-appears-in-model-view",
          "from": "relationship",
          "to": "model-view",
          "phrase": "appears in",
          "category": "uses",
          "description": "Model views can display relationships alongside concepts to visualize how domain elements are connected."
        },
        {
          "id": "relationship-appears-in-story-view",
          "from": "relationship",
          "to": "story-view",
          "phrase": "appears in",
          "category": "uses",
          "description": "Story views may reference relationships to narrate how concepts interact over time in a scenario."
        },
        {
          "id": "relationship-referenced-by-story-step",
          "from": "relationship",
          "to": "story-step",
          "phrase": "is referenced by",
          "category": "uses",
          "description": "Individual story steps can reference specific relationships to highlight particular interactions or dependencies between concepts at that moment in the story."
        },
        {
          "id": "model-rule-governs-concept-model",
          "from": "model-rule",
          "to": "concept-model",
          "phrase": "governs",
          "category": "uses",
          "description": "A model rule governs how a concept model should be interpreted or constructed, defining constraints, heuristics, or patterns that apply across the model."
        },
        {
          "id": "model-rule-governs-concept",
          "from": "model-rule",
          "to": "concept",
          "phrase": "governs",
          "category": "uses",
          "description": "A model rule governs how individual concepts are defined, related, or constrained within a concept model."
        },
        {
          "id": "model-rule-governs-relationship",
          "from": "model-rule",
          "to": "relationship",
          "phrase": "governs",
          "category": "uses",
          "description": "A model rule governs how relationships between concepts may be formed, interpreted, or constrained within a concept model."
        },
        {
          "id": "rel-concept-lifecycle-defined-by-concept-model",
          "from": "concept-lifecycle",
          "to": "concept-model",
          "phrase": "is defined within",
          "category": "part_of",
          "description": "A concept lifecycle is defined as part of a concept model, which specifies the states and transitions relevant for that model's domain."
        },
        {
          "id": "rel-concept-model-defines-concept-lifecycle",
          "from": "concept-model",
          "to": "concept-lifecycle",
          "phrase": "defines",
          "category": "uses",
          "description": "A concept model defines one or more concept lifecycles to describe how its concepts can evolve over time."
        },
        {
          "id": "rel-concept-lifecycle-applies-to-concept",
          "from": "concept-lifecycle",
          "to": "concept",
          "phrase": "applies to",
          "category": "uses",
          "description": "A concept lifecycle applies to a concept to describe the allowed states and transitions that concept can pass through over time."
        },
        {
          "id": "rel-concept-may-have-concept-lifecycle",
          "from": "concept",
          "to": "concept-lifecycle",
          "phrase": "may have",
          "category": "uses",
          "description": "A concept may have an associated concept lifecycle that constrains and documents its possible states and transitions."
        },
        {
          "id": "rel-concept-lifecycle-represented-in-model-view",
          "from": "concept-lifecycle",
          "to": "model-view",
          "phrase": "may be visualized in",
          "category": "represents",
          "description": "A concept lifecycle may be visualized in a model view to show the states and transitions of a concept within the broader concept model."
        },
        {
          "id": "rel-concept-lifecycle-used-in-story-view",
          "from": "concept-lifecycle",
          "to": "story-view",
          "phrase": "may inform",
          "category": "uses",
          "description": "A concept lifecycle may inform story views by providing the underlying state changes that occur as concepts move through a scenario."
        },
        {
          "id": "model-view-part-of-concept-model",
          "from": "model-view",
          "to": "concept-model",
          "phrase": "is a view within",
          "category": "part_of",
          "description": "A model view is defined as one of the views that belong to a concept model and presents that model from a particular perspective."
        },
        {
          "id": "model-view-uses-concept",
          "from": "model-view",
          "to": "concept",
          "phrase": "selects and displays",
          "category": "uses",
          "description": "A model view chooses a subset of concepts from the concept model to display or emphasize."
        },
        {
          "id": "model-view-uses-relationship",
          "from": "model-view",
          "to": "relationship",
          "phrase": "selects and displays",
          "category": "uses",
          "description": "A model view chooses a subset of relationships from the concept model to display or emphasize."
        },
        {
          "id": "model-view-represents-concept-lifecycle",
          "from": "model-view",
          "to": "concept-lifecycle",
          "phrase": "may visualize",
          "category": "represents",
          "description": "A model view can be used to visualize the lifecycle of one or more concepts, showing states and transitions as part of the view."
        },
        {
          "id": "model-view-related-to-story-view",
          "from": "model-view",
          "to": "story-view",
          "phrase": "complements",
          "category": "other",
          "description": "A model view provides a structural or relational perspective that complements the narrative perspective provided by a story view over the same concept model."
        },
        {
          "id": "story-view-is-model-view",
          "from": "story-view",
          "to": "model-view",
          "phrase": "is a specialized",
          "category": "is_a",
          "description": "Story view is a specialized kind of model view focused on narrative, scenario-based sequences rather than structural overviews."
        },
        {
          "id": "story-view-part-of-concept-model",
          "from": "story-view",
          "to": "concept-model",
          "phrase": "is a view within",
          "category": "part_of",
          "description": "A Story view exists as one of the views defined inside a Concept model."
        },
        {
          "id": "story-view-uses-concept",
          "from": "story-view",
          "to": "concept",
          "phrase": "references and illustrates",
          "category": "uses",
          "description": "A Story view references concepts from the Concept model to show how they participate in a scenario."
        },
        {
          "id": "story-view-uses-relationship",
          "from": "story-view",
          "to": "relationship",
          "phrase": "references and illustrates",
          "category": "uses",
          "description": "A Story view references relationships from the Concept model to show how concepts interact during the scenario."
        },
        {
          "id": "story-view-composed-of-story-step",
          "from": "story-view",
          "to": "story-step",
          "phrase": "is composed of ordered",
          "category": "part_of",
          "description": "A Story view consists of a sequence of Story steps that together form the narrative of the scenario."
        },
        {
          "id": "story-view-uses-concept-lifecycle",
          "from": "story-view",
          "to": "concept-lifecycle",
          "phrase": "may draw on",
          "category": "uses",
          "description": "A Story view may use concept lifecycles to show how a concept’s state changes across the steps of the story."
        },
        {
          "id": "story-view-complements-model-view",
          "from": "story-view",
          "to": "model-view",
          "phrase": "complements",
          "category": "other",
          "description": "Story view complements structural or static model views by providing narrative, scenario-based explanations of the same underlying concepts and relationships."
        },
        {
          "id": "story-view-uses-concept-model",
          "from": "story-view",
          "to": "concept-model",
          "phrase": "references elements from",
          "category": "uses",
          "description": "A Story view draws all of its referenced concepts and relationships from a specific Concept model."
        },
        {
          "id": "story-step-part-of-story-view",
          "from": "story-step",
          "to": "story-view",
          "phrase": "is an ordered element within",
          "category": "part_of",
          "description": "Each story-step is one element in the ordered sequence that makes up a story-view, representing a single moment or move in the narrative."
        },
        {
          "id": "story-step-uses-concept",
          "from": "story-step",
          "to": "concept",
          "phrase": "references",
          "category": "uses",
          "description": "A story-step references one or more concepts to show which domain elements are involved at that moment in the story."
        },
        {
          "id": "story-step-uses-relationship",
          "from": "story-step",
          "to": "relationship",
          "phrase": "references",
          "category": "uses",
          "description": "A story-step references one or more relationships to show how the involved concepts are connected or interact in that moment."
        },
        {
          "id": "story-step-uses-concept-model-elements",
          "from": "story-step",
          "to": "concept-model",
          "phrase": "references elements from",
          "category": "uses",
          "description": "A story-step draws its referenced concepts and relationships from a specific concept-model, ensuring the story remains grounded in the modeled domain."
        }
      ],
      "rules": [
        {
          "id": "concept-project-must-have-id-name-summary-models",
          "title": "Concept project must define core identifying information and models",
          "text": "Each Concept project must have a unique identifier, a human-readable name, a short summary of what the project is about, and a collection of concept models that belong to the project.",
          "kind": "invariant",
          "conceptIds": [
            "concept-project"
          ]
        },
        {
          "id": "concept-project-primary-model-must-belong-to-project",
          "title": "Primary model must be one of the project’s models",
          "text": "If a Concept project specifies a primary or default model identifier, that model must be one of the concept models contained in the project.",
          "kind": "constraint",
          "conceptIds": [
            "concept-project"
          ]
        },
        {
          "id": "project-registry-has-projects-array",
          "title": "Registry maintains a list of project entries",
          "text": "A project registry consists of a collection of project entries; each entry must at minimum have an id, name, path, and updatedAt timestamp so that the corresponding concept project can be identified and located.",
          "kind": "invariant",
          "conceptIds": [
            "project-registry"
          ]
        },
        {
          "id": "rule-concept-model-belongs-to-single-project",
          "title": "Concept model belongs to a single concept project",
          "text": "Each concept model is grouped under exactly one concept project, which provides the high-level container and context for that model.",
          "kind": "assumption",
          "conceptIds": [
            "concept-model"
          ]
        },
        {
          "id": "rule-concept-project-may-have-multiple-models",
          "title": "Concept project may contain multiple concept models",
          "text": "A concept project can contain multiple concept models that belong together around a single product, system, or domain.",
          "kind": "assumption",
          "conceptIds": [
            "concept-model"
          ]
        },
        {
          "id": "rule-concept-project-primary-model",
          "title": "Concept project may designate a primary concept model",
          "text": "A concept project may designate one concept model as the primary or default model to open first in user interfaces or tooling.",
          "kind": "policy",
          "conceptIds": [
            "concept-model"
          ]
        },
        {
          "id": "rule-concept-model-is-coherent",
          "title": "Concept model must be coherent",
          "text": "A concept model should form a coherent set of concepts, relationships, rules, and views that together describe a particular aspect or subsystem of the domain, rather than an arbitrary collection of unrelated elements.",
          "kind": "constraint",
          "conceptIds": [
            "concept-model"
          ]
        },
        {
          "id": "rule-concept-must-belong-to-model",
          "title": "Concept must belong to a Concept model",
          "text": "Every Concept is defined within exactly one Concept model that provides its surrounding context and relationships.",
          "kind": "assumption",
          "conceptIds": [
            "concept"
          ]
        },
        {
          "id": "rule-concept-must-be-domain-level",
          "title": "Concept represents a domain-level idea",
          "text": "A Concept should represent a domain-level element such as a thing, activity, role, state, event, place, or time, rather than an implementation detail.",
          "kind": "policy",
          "conceptIds": [
            "concept"
          ]
        },
        {
          "id": "rule-relationship-must-belong-to-model",
          "title": "Relationship must belong to a concept model",
          "text": "Every relationship is defined within exactly one concept model, which provides the context and boundary for interpreting that relationship.",
          "kind": "constraint",
          "conceptIds": [
            "relationship",
            "concept-model"
          ]
        },
        {
          "id": "rule-relationship-connects-at-least-two-concepts",
          "title": "Relationship connects two or more concepts",
          "text": "A relationship must involve at least two concepts; it is not defined for a single isolated concept.",
          "kind": "assumption",
          "conceptIds": [
            "relationship",
            "concept"
          ]
        },
        {
          "id": "rule-model-rule-applies-within-single-model",
          "title": "Model rule applies within a specific concept model",
          "text": "Each model rule is defined in the context of a particular concept model and is intended to govern the interpretation and structure of concepts and relationships within that model.",
          "kind": "assumption",
          "conceptIds": [
            "model-rule"
          ]
        },
        {
          "id": "rule-model-rule-is-declarative",
          "title": "Model rule is declarative",
          "text": "A model rule expresses a declarative constraint, heuristic, or pattern about the model rather than an imperative procedure, focusing on what should hold in the model rather than how to enforce it.",
          "kind": "assumption",
          "conceptIds": [
            "model-rule"
          ]
        },
        {
          "id": "rule-concept-lifecycle-defined-at-model-level",
          "title": "Concept lifecycle is defined at the model level",
          "text": "A concept lifecycle must be defined within a concept model before it can be associated with individual concepts in that model.",
          "kind": "constraint",
          "conceptIds": [
            "concept-lifecycle"
          ]
        },
        {
          "id": "rule-concept-lifecycle-optional-for-concept",
          "title": "Concept lifecycle is optional for a concept",
          "text": "A concept may, but does not have to, have an associated concept lifecycle; lifecycles are used only where state evolution is important to the model.",
          "kind": "assumption",
          "conceptIds": [
            "concept-lifecycle"
          ]
        },
        {
          "id": "rule-model-view-belongs-to-single-concept-model",
          "title": "Model view belongs to a single concept model",
          "text": "Each model view is defined within exactly one concept model and only visualizes concepts, relationships, and lifecycles from that concept model.",
          "kind": "constraint",
          "conceptIds": [
            "model-view"
          ]
        },
        {
          "id": "rule-model-view-does-not-alter-model",
          "title": "Model view does not change underlying model",
          "text": "A model view may filter, group, or highlight elements of a concept model, but it does not create, modify, or delete the underlying concepts, relationships, or lifecycles.",
          "kind": "invariant",
          "conceptIds": [
            "model-view"
          ]
        },
        {
          "id": "rule-model-view-is-optional",
          "title": "Model views are optional per concept model",
          "text": "A concept model may define zero or more model views; the existence of a concept model does not require any particular view to be present.",
          "kind": "assumption",
          "conceptIds": [
            "model-view"
          ]
        },
        {
          "id": "story-view-must-reference-model-elements",
          "title": "Story view must reference elements from its Concept model",
          "text": "Every Story view is defined in the context of a specific Concept model and should only reference concepts and relationships that belong to that model (or are explicitly modeled as external references).",
          "kind": "constraint",
          "conceptIds": [
            "story-view"
          ]
        },
        {
          "id": "story-view-has-ordered-steps",
          "title": "Story view consists of an ordered sequence of story steps",
          "text": "A Story view is made up of Story steps that are ordered to form a coherent narrative describing how concepts and relationships interact over time in a scenario.",
          "kind": "assumption",
          "conceptIds": [
            "story-view"
          ]
        },
        {
          "id": "story-step-must-belong-to-story-view",
          "title": "Story step must belong to a story view",
          "text": "Every story-step is defined in the context of exactly one story-view and has meaning only as part of that ordered narrative.",
          "kind": "constraint",
          "conceptIds": [
            "story-step"
          ]
        },
        {
          "id": "story-step-should-reference-model-elements",
          "title": "Story step should reference model elements",
          "text": "A story-step should reference at least one concept or relationship from its underlying concept-model so that it contributes concrete domain content to the story.",
          "kind": "heuristic",
          "conceptIds": [
            "story-step"
          ]
        },
        {
          "id": "story-step-order-matters",
          "title": "Story step order is significant",
          "text": "Story-steps within a story-view are ordered, and their sequence is intended to convey temporal or logical progression in the scenario.",
          "kind": "assumption",
          "conceptIds": [
            "story-step"
          ]
        }
      ],
      "lifecycles": [],
      "views": [
        {
          "id": "project-landscape-overview",
          "name": "Project landscape: registry, projects, and models",
          "kind": "overview",
          "description": "Shows how the project registry catalogs concept projects and how each project groups its concept models.",
          "conceptIds": [
            "project-registry",
            "concept-project",
            "concept-model",
            "concept",
            "relationship"
          ],
          "relationshipIds": [
            "project-registry-contains-concept-projects",
            "concept-project-listed-in-project-registry",
            "concept-project-contains-concept-models",
            "concept-model-contained-in-concept-project",
            "concept-model-contains-concepts",
            "concept-model-contains-relationships"
          ]
        },
        {
          "id": "model-internals-structure",
          "name": "Inside a concept model: core elements and rules",
          "kind": "structure",
          "description": "Explains the internal structure of a single concept model: its concepts, relationships, rules, and lifecycles.",
          "conceptIds": [
            "concept-model",
            "concept",
            "relationship",
            "model-rule",
            "concept-lifecycle"
          ],
          "relationshipIds": [
            "concept-model-contains-concepts",
            "concept-model-contains-relationships",
            "concept-model-applies-model-rules",
            "concept-model-defines-concept-lifecycles",
            "concept-participates-in-relationship",
            "concept-governed-by-model-rule",
            "concept-has-concept-lifecycle",
            "relationship-connects-concept"
          ]
        },
        {
          "id": "views-on-a-model",
          "name": "Views on a model: structural and narrative slices",
          "kind": "structure",
          "description": "Shows how model views and story views provide different slices of a concept model and how story steps compose a story.",
          "conceptIds": [
            "concept-model",
            "model-view",
            "story-view",
            "story-step",
            "concept",
            "relationship"
          ],
          "relationshipIds": [
            "concept-model-has-model-views",
            "concept-model-has-story-views",
            "model-view-part-of-concept-model",
            "story-view-part-of-concept-model",
            "story-view-is-model-view",
            "story-view-composed-of-story-step",
            "model-view-uses-concept",
            "story-view-uses-concept",
            "story-step-uses-concept",
            "story-step-part-of-story-view"
          ]
        },
        {
          "id": "narrative-usage-of-model-elements",
          "name": "How stories use model elements",
          "kind": "other",
          "description": "Details how story views and their steps reference concepts and relationships from a concept model.",
          "conceptIds": [
            "concept-model",
            "story-view",
            "story-step",
            "concept",
            "relationship"
          ],
          "relationshipIds": [
            "story-view-uses-concept-model",
            "story-view-uses-concept",
            "story-view-uses-relationship",
            "story-step-uses-concept-model-elements",
            "story-step-uses-concept",
            "story-step-uses-relationship",
            "story-view-references-concept-model-elements",
            "story-step-references-concept-model-elements",
            "relationship-referenced-by-story-step",
            "relationship-appears-in-story-view"
          ]
        },
        {
          "id": "lifecycle-and-visualization",
          "name": "Concept lifecycles and their visualization",
          "kind": "lifecycle",
          "description": "Shows how concept lifecycles are defined in a model, applied to concepts, and visualized in model and story views.",
          "conceptIds": [
            "concept-model",
            "concept",
            "concept-lifecycle",
            "model-view",
            "story-view"
          ],
          "relationshipIds": [
            "rel-concept-model-defines-concept-lifecycle",
            "rel-concept-lifecycle-defined-by-concept-model",
            "rel-concept-lifecycle-applies-to-concept",
            "rel-concept-may-have-concept-lifecycle",
            "rel-concept-lifecycle-represented-in-model-view",
            "rel-concept-lifecycle-used-in-story-view",
            "model-view-represents-concept-lifecycle",
            "story-view-uses-concept-lifecycle"
          ]
        }
      ],
      "storyViews": [
        {
          "id": "browse-and-open-concept-project-from-registry",
          "name": "Browse and Open a Concept Project from the Registry",
          "kind": "user_flow",
          "description": "A modeler discovers a concept project in the project registry, opens it, and navigates into its concept models and story views.",
          "tags": [
            "discovery",
            "navigation",
            "onboarding"
          ],
          "focusConceptId": "project-registry",
          "steps": [
            {
              "id": "user-opens-project-registry",
              "index": 0,
              "title": "User Opens the Project Registry",
              "narrative": "A modeler accesses the project registry to see what concept projects already exist for their organization’s codebases. The registry presents a catalog of available concept projects as discoverable entries.",
              "conceptIds": [
                "project-registry",
                "concept-project"
              ],
              "relationshipIds": [
                "project-registry-contains-concept-projects",
                "project-registry-contains-project-entries"
              ],
              "primaryConceptIds": [
                "project-registry"
              ],
              "primaryRelationshipIds": [
                "project-registry-contains-concept-projects"
              ]
            },
            {
              "id": "user-selects-concept-project-entry",
              "index": 1,
              "title": "User Selects a Concept Project Entry",
              "narrative": "The modeler scans the list and selects a concept project that matches a particular codebase or product area. The selected concept project is known to be listed in the registry and acts as an entry point into its internal models.",
              "conceptIds": [
                "project-registry",
                "concept-project",
                "concept-model"
              ],
              "relationshipIds": [
                "project-registry-contains-project-entries",
                "concept-project-is-listed-in-registry",
                "concept-project-provides-entry-point-to-concept-models"
              ],
              "primaryConceptIds": [
                "concept-project"
              ],
              "primaryRelationshipIds": [
                "concept-project-provides-entry-point-to-concept-models"
              ]
            },
            {
              "id": "user-opens-concept-project-and-sees-models",
              "index": 2,
              "title": "User Opens Concept Project and Sees Its Concept Models",
              "narrative": "After selecting the project, the modeler opens it and sees the set of concept models grouped within that project. The project container clarifies which concept models belong to this domain.",
              "conceptIds": [
                "concept-project",
                "concept-model"
              ],
              "relationshipIds": [
                "concept-project-has-concept-models",
                "concept-model-contained-in-concept-project"
              ],
              "primaryConceptIds": [
                "concept-project",
                "concept-model"
              ],
              "primaryRelationshipIds": [
                "concept-project-has-concept-models"
              ]
            },
            {
              "id": "user-opens-specific-concept-model",
              "index": 3,
              "title": "User Opens a Specific Concept Model",
              "narrative": "The modeler chooses one concept model that describes a subsystem they care about. Inside the model, they see the core concepts and relationships that define this part of the domain.",
              "conceptIds": [
                "concept-model",
                "concept",
                "relationship"
              ],
              "relationshipIds": [
                "concept-model-contains-concepts",
                "concept-model-contains-relationships"
              ],
              "primaryConceptIds": [
                "concept-model"
              ],
              "primaryRelationshipIds": [
                "concept-model-contains-concepts"
              ]
            },
            {
              "id": "user-switches-to-story-view",
              "index": 4,
              "title": "User Switches to a Story View of the Model",
              "narrative": "To understand how the domain behaves over time, the modeler opens a story view within the concept model. The story view presents an ordered sequence of story steps that reference the same concepts and relationships from the model.",
              "conceptIds": [
                "concept-model",
                "story-view",
                "story-step",
                "concept",
                "relationship"
              ],
              "relationshipIds": [
                "concept-model-has-story-views",
                "story-view-part-of-concept-model",
                "story-view-references-concept-model-elements",
                "story-view-composed-of-story-step",
                "story-step-uses-concept-model-elements"
              ],
              "primaryConceptIds": [
                "story-view"
              ],
              "primaryRelationshipIds": [
                "story-view-composed-of-story-step"
              ]
            }
          ]
        },
        {
          "id": "create-and-register-new-concept-project",
          "name": "Create and Register a New Concept Project",
          "kind": "admin_flow",
          "description": "An administrator creates a new concept project, populates it with an initial concept model, and registers it in the project registry for others to discover.",
          "tags": [
            "creation",
            "governance",
            "registration"
          ],
          "focusConceptId": "concept-project",
          "steps": [
            {
              "id": "admin-identifies-need-for-new-project",
              "index": 0,
              "title": "Admin Identifies Need for a New Concept Project",
              "narrative": "An administrator realizes that a new codebase or product area lacks a dedicated concept project. They decide to create a new project container to group future concept models for this domain.",
              "conceptIds": [
                "concept-project",
                "project-registry"
              ],
              "relationshipIds": [
                "project-registry-contains-concept-projects"
              ],
              "primaryConceptIds": [
                "concept-project"
              ],
              "primaryRelationshipIds": []
            },
            {
              "id": "admin-creates-empty-concept-project",
              "index": 1,
              "title": "Admin Creates an Empty Concept Project",
              "narrative": "The administrator creates a new concept project record, initially without any concept models. This project will later contain one or more concept models that describe the domain.",
              "conceptIds": [
                "concept-project",
                "concept-model"
              ],
              "relationshipIds": [
                "concept-project-contains-concept-models"
              ],
              "primaryConceptIds": [
                "concept-project"
              ],
              "primaryRelationshipIds": [
                "concept-project-contains-concept-models"
              ]
            },
            {
              "id": "admin-adds-initial-concept-model",
              "index": 2,
              "title": "Admin Adds an Initial Concept Model to the Project",
              "narrative": "To make the project useful, the administrator or lead modeler creates an initial concept model and groups it within the new concept project. This establishes the first structured description of the domain.",
              "conceptIds": [
                "concept-project",
                "concept-model"
              ],
              "relationshipIds": [
                "concept-model-contained-in-concept-project",
                "concept-project-has-concept-models"
              ],
              "primaryConceptIds": [
                "concept-model"
              ],
              "primaryRelationshipIds": [
                "concept-model-contained-in-concept-project"
              ]
            },
            {
              "id": "admin-registers-project-in-registry",
              "index": 3,
              "title": "Admin Registers the Concept Project in the Project Registry",
              "narrative": "The administrator adds the new concept project to the project registry so that others can discover and navigate to it. The registry now contains an entry for this project, and the project is listed in the registry.",
              "conceptIds": [
                "project-registry",
                "concept-project"
              ],
              "relationshipIds": [
                "project-registry-contains-project-entries",
                "concept-project-listed-in-project-registry",
                "concept-project-is-listed-in-registry"
              ],
              "primaryConceptIds": [
                "project-registry",
                "concept-project"
              ],
              "primaryRelationshipIds": [
                "project-registry-contains-project-entries"
              ]
            },
            {
              "id": "project-now-serves-as-entry-point",
              "index": 4,
              "title": "Project Now Serves as Entry Point to Its Concept Models",
              "narrative": "Once registered, the concept project becomes the standard entry point for anyone wanting to access its concept models. Users can navigate from the registry to the project and then into its models.",
              "conceptIds": [
                "project-registry",
                "concept-project",
                "concept-model"
              ],
              "relationshipIds": [
                "project-registry-contains-concept-projects",
                "concept-project-provides-entry-point-to-concept-models"
              ],
              "primaryConceptIds": [
                "concept-project"
              ],
              "primaryRelationshipIds": [
                "concept-project-provides-entry-point-to-concept-models"
              ]
            }
          ]
        },
        {
          "id": "develop-concept-model-with-rules-and-lifecycles",
          "name": "Develop a Concept Model with Rules and Lifecycles",
          "kind": "system_flow",
          "description": "A modeler iteratively enriches a concept model by adding concepts, relationships, model rules, and concept lifecycles, then exposes them through model views and story views.",
          "tags": [
            "modeling",
            "rules",
            "lifecycles",
            "views"
          ],
          "focusConceptId": "concept-model",
          "steps": [
            {
              "id": "modeler-defines-core-concepts-and-relationships",
              "index": 0,
              "title": "Modeler Defines Core Concepts and Relationships",
              "narrative": "A modeler starts by identifying the main domain concepts and how they connect. These concepts and relationships are added to the concept model as its foundational structure.",
              "conceptIds": [
                "concept-model",
                "concept",
                "relationship"
              ],
              "relationshipIds": [
                "concept-model-contains-concepts",
                "concept-model-contains-relationships",
                "relationship-connects-concept",
                "concept-participates-in-relationship",
                "relationship-contained-in-concept-model"
              ],
              "primaryConceptIds": [
                "concept-model"
              ],
              "primaryRelationshipIds": [
                "concept-model-contains-concepts"
              ]
            },
            {
              "id": "modeler-applies-model-rules",
              "index": 1,
              "title": "Modeler Applies Model Rules to Concepts and Relationships",
              "narrative": "To ensure consistency, the modeler defines model rules that govern how concepts and relationships should behave or be interpreted. These rules govern the overall concept model as well as specific concepts and relationships.",
              "conceptIds": [
                "concept-model",
                "concept",
                "relationship",
                "model-rule"
              ],
              "relationshipIds": [
                "concept-model-applies-model-rules",
                "model-rule-governs-concept-model",
                "model-rule-governs-concept",
                "model-rule-governs-relationship",
                "concept-governed-by-model-rule",
                "relationship-governed-by-model-rule"
              ],
              "primaryConceptIds": [
                "model-rule"
              ],
              "primaryRelationshipIds": [
                "concept-model-applies-model-rules"
              ]
            },
            {
              "id": "modeler-defines-concept-lifecycles",
              "index": 2,
              "title": "Modeler Defines Concept Lifecycles",
              "narrative": "For key concepts that change over time, the modeler defines concept lifecycles within the concept model. Each lifecycle describes the states and transitions a concept may go through.",
              "conceptIds": [
                "concept-model",
                "concept",
                "concept-lifecycle"
              ],
              "relationshipIds": [
                "concept-model-defines-concept-lifecycles",
                "rel-concept-model-defines-concept-lifecycle",
                "rel-concept-lifecycle-defined-by-concept-model",
                "rel-concept-lifecycle-applies-to-concept",
                "rel-concept-may-have-concept-lifecycle",
                "concept-has-concept-lifecycle"
              ],
              "primaryConceptIds": [
                "concept-lifecycle"
              ],
              "primaryRelationshipIds": [
                "concept-model-defines-concept-lifecycles"
              ]
            },
            {
              "id": "modeler-creates-structural-model-views",
              "index": 3,
              "title": "Modeler Creates Structural Model Views",
              "narrative": "To communicate the structure, the modeler creates model views that select and display relevant concepts and relationships, and may visualize concept lifecycles. These views provide static snapshots of the domain.",
              "conceptIds": [
                "concept-model",
                "model-view",
                "concept",
                "relationship",
                "concept-lifecycle"
              ],
              "relationshipIds": [
                "concept-model-has-model-views",
                "model-view-part-of-concept-model",
                "model-view-uses-concept",
                "model-view-uses-relationship",
                "model-view-represents-concept-lifecycle",
                "rel-concept-lifecycle-represented-in-model-view"
              ],
              "primaryConceptIds": [
                "model-view"
              ],
              "primaryRelationshipIds": [
                "model-view-uses-concept"
              ]
            },
            {
              "id": "modeler-adds-story-views-for-dynamic-behavior",
              "index": 4,
              "title": "Modeler Adds Story Views for Dynamic Behavior",
              "narrative": "To show how the domain behaves over time, the modeler creates story views within the concept model. Each story view is composed of ordered story steps that reference concepts, relationships, and lifecycles, complementing the structural model views.",
              "conceptIds": [
                "concept-model",
                "story-view",
                "story-step",
                "concept",
                "relationship",
                "concept-lifecycle",
                "model-view"
              ],
              "relationshipIds": [
                "concept-model-has-story-views",
                "story-view-part-of-concept-model",
                "story-view-composed-of-story-step",
                "story-view-uses-concept",
                "story-view-uses-relationship",
                "story-step-uses-concept",
                "story-step-uses-relationship",
                "story-view-uses-concept-lifecycle",
                "rel-concept-lifecycle-used-in-story-view",
                "story-view-complements-model-view",
                "model-view-related-to-story-view"
              ],
              "primaryConceptIds": [
                "story-view",
                "story-step"
              ],
              "primaryRelationshipIds": [
                "story-view-composed-of-story-step"
              ]
            }
          ]
        },
        {
          "id": "use-story-view-to-explain-concept-lifecycle",
          "name": "Use a Story View to Explain a Concept Lifecycle",
          "kind": "user_flow",
          "description": "A model consumer opens a story view to understand how a particular concept moves through its lifecycle, seeing how concepts and relationships change step by step.",
          "tags": [
            "lifecycles",
            "explanation",
            "education"
          ],
          "focusConceptId": "concept-lifecycle",
          "steps": [
            {
              "id": "user-locates-concept-and-lifecycle",
              "index": 0,
              "title": "User Locates a Concept and Its Lifecycle in the Model",
              "narrative": "A user opens a concept model and focuses on a specific concept that has a defined lifecycle. They see that the concept may have an associated concept lifecycle defined within the model.",
              "conceptIds": [
                "concept-model",
                "concept",
                "concept-lifecycle"
              ],
              "relationshipIds": [
                "concept-model-contains-concepts",
                "concept-has-concept-lifecycle",
                "rel-concept-may-have-concept-lifecycle",
                "rel-concept-lifecycle-defined-by-concept-model"
              ],
              "primaryConceptIds": [
                "concept",
                "concept-lifecycle"
              ],
              "primaryRelationshipIds": [
                "concept-has-concept-lifecycle"
              ]
            },
            {
              "id": "user-opens-lifecycle-oriented-model-view",
              "index": 1,
              "title": "User Opens a Lifecycle-Oriented Model View",
              "narrative": "To see the lifecycle structure, the user opens a model view that visualizes the states and transitions of the concept lifecycle. This view provides a static diagram of how the concept can evolve.",
              "conceptIds": [
                "model-view",
                "concept-lifecycle",
                "concept-model"
              ],
              "relationshipIds": [
                "model-view-part-of-concept-model",
                "model-view-represents-concept-lifecycle",
                "rel-concept-lifecycle-represented-in-model-view"
              ],
              "primaryConceptIds": [
                "model-view"
              ],
              "primaryRelationshipIds": [
                "model-view-represents-concept-lifecycle"
              ]
            },
            {
              "id": "user-switches-to-lifecycle-story-view",
              "index": 2,
              "title": "User Switches to a Lifecycle Story View",
              "narrative": "To understand the lifecycle in context, the user opens a story view that focuses on this concept’s journey over time. The story view is a specialized model view that complements the structural lifecycle diagram.",
              "conceptIds": [
                "story-view",
                "model-view",
                "concept-model",
                "concept-lifecycle"
              ],
              "relationshipIds": [
                "story-view-is-model-view",
                "story-view-part-of-concept-model",
                "story-view-uses-concept-lifecycle",
                "rel-concept-lifecycle-used-in-story-view",
                "story-view-complements-model-view",
                "model-view-related-to-story-view"
              ],
              "primaryConceptIds": [
                "story-view"
              ],
              "primaryRelationshipIds": [
                "story-view-uses-concept-lifecycle"
              ]
            },
            {
              "id": "story-steps-show-concept-state-changes",
              "index": 3,
              "title": "Story Steps Show Concept State Changes",
              "narrative": "Within the story view, each story step references the concept and its relationships as it moves from one lifecycle state to another. The ordered steps illustrate how the concept participates in relationships at each stage.",
              "conceptIds": [
                "story-view",
                "story-step",
                "concept",
                "relationship",
                "concept-lifecycle",
                "concept-model"
              ],
              "relationshipIds": [
                "story-view-composed-of-story-step",
                "story-step-part-of-story-view",
                "story-step-uses-concept",
                "story-step-uses-relationship",
                "story-step-uses-concept-model-elements",
                "concept-appears-in-story-step",
                "relationship-referenced-by-story-step",
                "rel-concept-lifecycle-applies-to-concept"
              ],
              "primaryConceptIds": [
                "story-step",
                "concept"
              ],
              "primaryRelationshipIds": [
                "story-view-composed-of-story-step"
              ]
            },
            {
              "id": "user-relates-story-view-back-to-structural-views",
              "index": 4,
              "title": "User Relates Story View Back to Structural Views",
              "narrative": "After following the story, the user returns to the structural model views to cross-check concepts and relationships. Because the same elements appear in both model views and story views, the user gains a coherent understanding of both structure and behavior.",
              "conceptIds": [
                "concept",
                "relationship",
                "model-view",
                "story-view"
              ],
              "relationshipIds": [
                "concept-appears-in-model-view",
                "relationship-appears-in-model-view",
                "concept-appears-in-story-view",
                "relationship-appears-in-story-view",
                "model-view-related-to-story-view",
                "story-view-complements-model-view"
              ],
              "primaryConceptIds": [
                "concept",
                "relationship"
              ],
              "primaryRelationshipIds": [
                "concept-appears-in-model-view"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "publishing-and-viewing",
      "title": "Publishing and Viewing Concept Models",
      "description": "This model describes how generated concept models are delivered to external viewers or tools so that humans can explore and use them.",
      "concepts": [
        {
          "id": "concept-viewer",
          "label": "Concept viewer",
          "category": "thing",
          "description": "An external tool or interface where concept models, views, and stories are published for exploration and discussion.",
          "aliases": [
            "viewer",
            "model viewer",
            "concept model viewer",
            "published viewer",
            "external viewer"
          ],
          "notes": "A Concept viewer is an external tool or interface that receives generated concept models, model views, and stories from the analysis system so that humans can explore, inspect, and discuss them. In this codebase it is treated as a downstream consumer of the analysis output, reached via the model publication process (e.g., when the `publish` option is enabled in analysis). The viewer itself is not implemented here; it is an integration target that can render and navigate ConceptModels, ModelViews, StoryViews, and related artifacts."
        },
        {
          "id": "model-publication",
          "label": "Model publication",
          "category": "activity",
          "description": "The activity of sending generated concept models and related artifacts from the analysis system to a viewer or downstream consumer.",
          "aliases": [
            "publishing",
            "publish",
            "model publishing",
            "publication of models",
            "publish generated models",
            "publish concept models",
            "publish project models"
          ],
          "notes": "Model publication is the optional step in the analysis pipeline where generated concept models and related artifacts (e.g., concept models, model views, story views, project metadata) are sent from the analysis system to an external consumer such as a concept viewer. In the provided code, this is controlled by the AnalyzeOptions.publish flag and is conceptually the boundary between internal model generation and external consumption or exploration."
        }
      ],
      "relationships": [
        {
          "id": "rel-concept-viewer-receives-publication",
          "from": "concept-viewer",
          "to": "model-publication",
          "phrase": "receives output from",
          "category": "uses",
          "description": "The Concept viewer receives concept models, views, and stories that are sent out by the model publication process for exploration and discussion."
        },
        {
          "id": "rel-concept-viewer-displays-concept-models",
          "from": "concept-viewer",
          "to": "concept-model",
          "phrase": "displays",
          "category": "uses",
          "description": "The Concept viewer displays ConceptModels generated by the analysis system so that users can explore the domain structure."
        },
        {
          "id": "rel-concept-viewer-displays-model-views",
          "from": "concept-viewer",
          "to": "model-view",
          "phrase": "displays",
          "category": "uses",
          "description": "The Concept viewer displays ModelViews, which are focused perspectives or slices of a ConceptModel tailored for particular questions or audiences."
        },
        {
          "id": "rel-concept-viewer-displays-story-views",
          "from": "concept-viewer",
          "to": "story-view",
          "phrase": "displays",
          "category": "uses",
          "description": "The Concept viewer displays StoryViews, which present narrative walkthroughs or scenarios based on the underlying concept models."
        },
        {
          "id": "rel-concept-viewer-serves-human-users",
          "from": "concept-viewer",
          "to": "human-user",
          "phrase": "serves",
          "category": "uses",
          "description": "The Concept viewer serves human users who explore and discuss the published concept models, views, and stories."
        },
        {
          "id": "rel-concept-viewer-consumes-project-models",
          "from": "concept-viewer",
          "to": "concept-project",
          "phrase": "consumes models from",
          "category": "uses",
          "description": "The Concept viewer consumes ConceptProjects and their associated models as a cohesive set of artifacts for a given codebase or domain."
        },
        {
          "id": "rel-model-publication-to-concept-viewer",
          "from": "model-publication",
          "to": "concept-viewer",
          "phrase": "sends models and views to",
          "category": "enables",
          "description": "Model publication sends generated concept models and related artifacts from the analysis system to a concept viewer so they can be explored and discussed."
        },
        {
          "id": "rel-model-publication-uses-concept-project",
          "from": "model-publication",
          "to": "concept-project",
          "phrase": "publishes models from",
          "category": "uses",
          "description": "Model publication operates on the models and artifacts belonging to a specific concept project, preparing them for external consumption."
        },
        {
          "id": "rel-model-publication-uses-concept-model",
          "from": "model-publication",
          "to": "concept-model",
          "phrase": "publishes",
          "category": "uses",
          "description": "Model publication takes generated concept models and makes them available to downstream consumers such as a concept viewer."
        },
        {
          "id": "rel-model-publication-uses-model-view",
          "from": "model-publication",
          "to": "model-view",
          "phrase": "publishes",
          "category": "uses",
          "description": "Model publication includes model views as part of the published artifacts so that consumers can see focused perspectives on the concept models."
        },
        {
          "id": "rel-model-publication-uses-story-view",
          "from": "model-publication",
          "to": "story-view",
          "phrase": "publishes",
          "category": "uses",
          "description": "Model publication includes story views as part of the published artifacts, enabling narrative or scenario-based exploration in the concept viewer."
        },
        {
          "id": "rel-model-publication-precedes-concept-viewing",
          "from": "model-publication",
          "to": "concept-viewing-session",
          "phrase": "precedes",
          "category": "precedes",
          "description": "Model publication must occur before a human user can view and explore the models in the concept viewer."
        }
      ],
      "rules": [
        {
          "id": "rule-concept-viewer-requires-publication",
          "title": "Concept viewer only shows published artifacts",
          "text": "A Concept viewer can only display concept models, model views, and story views that have been published via the model publication process from the analysis system.",
          "kind": "assumption",
          "conceptIds": [
            "concept-viewer",
            "model-publication"
          ]
        },
        {
          "id": "rule-concept-viewer-read-only",
          "title": "Concept viewer is read-oriented",
          "text": "Within this project, the Concept viewer is assumed to be primarily read-only, used for exploration and discussion rather than for authoring or modifying the underlying concept models.",
          "kind": "assumption",
          "conceptIds": [
            "concept-viewer"
          ]
        },
        {
          "id": "rule-model-publication-optional",
          "title": "Model publication is optional in analysis runs",
          "text": "Model publication occurs only when the analysis is configured with publishing enabled (e.g., via an option such as AnalyzeOptions.publish). If publishing is not enabled, generated models remain internal to the analysis system and are not sent to external viewers or consumers.",
          "kind": "policy",
          "conceptIds": [
            "model-publication"
          ]
        },
        {
          "id": "rule-model-publication-requires-generated-models",
          "title": "Model publication requires generated project models",
          "text": "Model publication can only operate on a project once its concept models and related artifacts have been generated or discovered; without a discovered project structure and its models, there is nothing to publish.",
          "kind": "assumption",
          "conceptIds": [
            "model-publication"
          ]
        },
        {
          "id": "rule-model-publication-targets-external-consumers",
          "title": "Model publication targets external consumers",
          "text": "The purpose of model publication is to make generated concept models and related artifacts available to external consumers such as a concept viewer or other downstream tools, rather than for internal analysis only.",
          "kind": "assumption",
          "conceptIds": [
            "model-publication"
          ]
        }
      ],
      "lifecycles": [
        {
          "id": "lifecycle-model-publication-basic",
          "subjectConceptId": "model-publication",
          "stateConceptIds": [
            "model-publication-requested",
            "model-publication-in-progress",
            "model-publication-completed",
            "model-publication-failed"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "model-publication-requested",
          "terminalStateIds": [
            "model-publication-completed",
            "model-publication-failed"
          ]
        }
      ],
      "views": [
        {
          "id": "publishing-overview",
          "name": "Publishing and viewing overview",
          "kind": "overview",
          "description": "High-level overview of how models from a concept project are published and then consumed by a concept viewer for human exploration.",
          "conceptIds": [
            "concept-project",
            "model-publication",
            "concept-model",
            "model-view",
            "story-view",
            "concept-viewer",
            "human-user"
          ],
          "relationshipIds": [
            "rel-model-publication-uses-concept-project",
            "rel-model-publication-uses-concept-model",
            "rel-model-publication-uses-model-view",
            "rel-model-publication-uses-story-view",
            "rel-model-publication-to-concept-viewer",
            "rel-concept-viewer-consumes-project-models",
            "rel-concept-viewer-serves-human-users",
            "rel-concept-viewer-displays-concept-models",
            "rel-concept-viewer-displays-model-views",
            "rel-concept-viewer-displays-story-views"
          ]
        },
        {
          "id": "publication-lifecycle",
          "name": "Model publication lifecycle",
          "kind": "lifecycle",
          "description": "Lifecycle from having models in a concept project, through model publication, to a concept viewing session.",
          "conceptIds": [
            "concept-project",
            "concept-model",
            "model-view",
            "story-view",
            "model-publication",
            "concept-viewer",
            "concept-viewing-session"
          ],
          "relationshipIds": [
            "rel-model-publication-uses-concept-project",
            "rel-model-publication-uses-concept-model",
            "rel-model-publication-uses-model-view",
            "rel-model-publication-uses-story-view",
            "rel-model-publication-to-concept-viewer",
            "rel-model-publication-precedes-concept-viewing",
            "rel-concept-viewer-consumes-project-models"
          ]
        },
        {
          "id": "viewer-experience",
          "name": "Concept viewer experience",
          "kind": "other",
          "description": "What the concept viewer does with published artifacts and how it serves human users during exploration.",
          "conceptIds": [
            "concept-viewer",
            "concept-project",
            "concept-model",
            "model-view",
            "story-view",
            "human-user",
            "concept-viewing-session"
          ],
          "relationshipIds": [
            "rel-concept-viewer-consumes-project-models",
            "rel-concept-viewer-displays-concept-models",
            "rel-concept-viewer-displays-model-views",
            "rel-concept-viewer-displays-story-views",
            "rel-concept-viewer-serves-human-users",
            "rel-model-publication-precedes-concept-viewing"
          ]
        }
      ],
      "storyViews": [
        {
          "id": "human-explores-published-models",
          "name": "Human Explores Published Concept Models in a Viewer",
          "kind": "user_flow",
          "description": "A human user opens a concept viewer, which has received published models and views, and explores them through different visualizations and story views.",
          "tags": [
            "exploration",
            "viewing-session",
            "story-view"
          ],
          "focusConceptId": "concept-viewer",
          "steps": [
            {
              "id": "viewer-ready-with-published-models",
              "index": 0,
              "title": "Concept viewer is ready with published models",
              "narrative": "The model publication activity sends concept models, model views, and story views from a concept project to the concept viewer, preparing it for human exploration.",
              "conceptIds": [
                "model-publication",
                "concept-viewer",
                "concept-project",
                "concept-model",
                "model-view",
                "story-view"
              ],
              "relationshipIds": [
                "rel-model-publication-to-concept-viewer",
                "rel-model-publication-uses-concept-project",
                "rel-model-publication-uses-concept-model",
                "rel-model-publication-uses-model-view",
                "rel-model-publication-uses-story-view"
              ],
              "primaryConceptIds": [
                "model-publication",
                "concept-viewer"
              ],
              "primaryRelationshipIds": [
                "rel-model-publication-to-concept-viewer"
              ]
            },
            {
              "id": "viewer-receives-output",
              "index": 1,
              "title": "Concept viewer receives publication output",
              "narrative": "The concept viewer ingests the incoming publication output, associating the received models and views with the originating concept project.",
              "conceptIds": [
                "concept-viewer",
                "model-publication",
                "concept-project"
              ],
              "relationshipIds": [
                "rel-concept-viewer-receives-publication",
                "rel-concept-viewer-consumes-project-models"
              ],
              "primaryConceptIds": [
                "concept-viewer"
              ],
              "primaryRelationshipIds": [
                "rel-concept-viewer-receives-publication"
              ]
            },
            {
              "id": "human-opens-viewer",
              "index": 2,
              "title": "Human user opens the concept viewer",
              "narrative": "A human user starts a viewing session in the concept viewer, which is designed to serve their need to understand the project’s models.",
              "conceptIds": [
                "concept-viewer",
                "human-user",
                "concept-viewing-session"
              ],
              "relationshipIds": [
                "rel-concept-viewer-serves-human-users",
                "rel-model-publication-precedes-concept-viewing"
              ],
              "primaryConceptIds": [
                "human-user",
                "concept-viewer"
              ],
              "primaryRelationshipIds": [
                "rel-concept-viewer-serves-human-users"
              ]
            },
            {
              "id": "user-browses-model-structure",
              "index": 3,
              "title": "User browses the core concept models",
              "narrative": "Within the viewing session, the human user inspects the published concept models to understand the overall structure of the project.",
              "conceptIds": [
                "concept-viewer",
                "human-user",
                "concept-model"
              ],
              "relationshipIds": [
                "rel-concept-viewer-displays-concept-models"
              ],
              "primaryConceptIds": [
                "concept-viewer",
                "concept-model"
              ],
              "primaryRelationshipIds": [
                "rel-concept-viewer-displays-concept-models"
              ]
            },
            {
              "id": "user-switches-to-model-views",
              "index": 4,
              "title": "User switches to focused model views",
              "narrative": "The human user selects specific model views that highlight subsets or perspectives of the concept model, using the viewer’s display options.",
              "conceptIds": [
                "concept-viewer",
                "human-user",
                "model-view"
              ],
              "relationshipIds": [
                "rel-concept-viewer-displays-model-views"
              ],
              "primaryConceptIds": [
                "model-view"
              ],
              "primaryRelationshipIds": [
                "rel-concept-viewer-displays-model-views"
              ]
            },
            {
              "id": "user-follows-story-views",
              "index": 5,
              "title": "User follows narrative story views",
              "narrative": "To understand how concepts interact over time, the human user opens story views that the concept viewer presents as step-by-step narratives.",
              "conceptIds": [
                "concept-viewer",
                "human-user",
                "story-view"
              ],
              "relationshipIds": [
                "rel-concept-viewer-displays-story-views"
              ],
              "primaryConceptIds": [
                "story-view"
              ],
              "primaryRelationshipIds": [
                "rel-concept-viewer-displays-story-views"
              ]
            }
          ]
        },
        {
          "id": "system-publishes-models-to-viewer",
          "name": "System Publishes Models and Views to a Concept Viewer",
          "kind": "system_flow",
          "description": "The analysis system performs a model publication activity that gathers models, views, and stories from a project and sends them to a concept viewer for later human use.",
          "tags": [
            "publication",
            "system",
            "pipeline"
          ],
          "focusConceptId": "model-publication",
          "steps": [
            {
              "id": "collect-project-models",
              "index": 0,
              "title": "Model publication collects project models",
              "narrative": "The model publication activity identifies the relevant concept project and gathers its generated concept models, model views, and story views for export.",
              "conceptIds": [
                "model-publication",
                "concept-project",
                "concept-model",
                "model-view",
                "story-view"
              ],
              "relationshipIds": [
                "rel-model-publication-uses-concept-project",
                "rel-model-publication-uses-concept-model",
                "rel-model-publication-uses-model-view",
                "rel-model-publication-uses-story-view"
              ],
              "primaryConceptIds": [
                "model-publication",
                "concept-project"
              ],
              "primaryRelationshipIds": [
                "rel-model-publication-uses-concept-project"
              ]
            },
            {
              "id": "prepare-publication-package",
              "index": 1,
              "title": "Publication prepares a package for the viewer",
              "narrative": "The model publication activity bundles the collected artifacts into a format suitable for the target concept viewer, preserving links between models, views, and stories.",
              "conceptIds": [
                "model-publication",
                "concept-model",
                "model-view",
                "story-view"
              ],
              "relationshipIds": [
                "rel-model-publication-uses-concept-model",
                "rel-model-publication-uses-model-view",
                "rel-model-publication-uses-story-view"
              ],
              "primaryConceptIds": [
                "model-publication"
              ],
              "primaryRelationshipIds": [
                "rel-model-publication-uses-concept-model"
              ]
            },
            {
              "id": "send-to-concept-viewer",
              "index": 2,
              "title": "Publication sends models and views to the concept viewer",
              "narrative": "The model publication activity transmits the prepared package to the concept viewer, making the models and views available for consumption.",
              "conceptIds": [
                "model-publication",
                "concept-viewer"
              ],
              "relationshipIds": [
                "rel-model-publication-to-concept-viewer"
              ],
              "primaryConceptIds": [
                "model-publication",
                "concept-viewer"
              ],
              "primaryRelationshipIds": [
                "rel-model-publication-to-concept-viewer"
              ]
            },
            {
              "id": "viewer-receives-and-registers",
              "index": 3,
              "title": "Concept viewer receives and registers the publication",
              "narrative": "The concept viewer receives output from the model publication activity and registers the incoming models and views as part of its available content.",
              "conceptIds": [
                "concept-viewer",
                "model-publication",
                "concept-model",
                "model-view",
                "story-view"
              ],
              "relationshipIds": [
                "rel-concept-viewer-receives-publication",
                "rel-concept-viewer-displays-concept-models",
                "rel-concept-viewer-displays-model-views",
                "rel-concept-viewer-displays-story-views"
              ],
              "primaryConceptIds": [
                "concept-viewer"
              ],
              "primaryRelationshipIds": [
                "rel-concept-viewer-receives-publication"
              ]
            },
            {
              "id": "ready-for-future-viewing-session",
              "index": 4,
              "title": "Published content becomes available for future viewing sessions",
              "narrative": "With publication complete, the concept viewer is now ready to serve human users in future concept viewing sessions that will be preceded by this publication step.",
              "conceptIds": [
                "concept-viewer",
                "human-user",
                "concept-viewing-session",
                "model-publication"
              ],
              "relationshipIds": [
                "rel-concept-viewer-serves-human-users",
                "rel-model-publication-precedes-concept-viewing"
              ],
              "primaryConceptIds": [
                "concept-viewer",
                "model-publication"
              ],
              "primaryRelationshipIds": [
                "rel-model-publication-precedes-concept-viewing"
              ]
            }
          ]
        },
        {
          "id": "integration-across-multiple-projects",
          "name": "Concept Viewer Integrates Models from Multiple Projects",
          "kind": "integration_flow",
          "description": "Multiple model publication activities from different concept projects send their models and views to a single concept viewer, which then offers an integrated exploration experience to human users.",
          "tags": [
            "multi-project",
            "integration",
            "cross-project"
          ],
          "focusConceptId": "concept-viewer",
          "steps": [
            {
              "id": "first-project-publishes",
              "index": 0,
              "title": "First concept project publishes its models",
              "narrative": "A model publication activity for the first concept project publishes its concept models, model views, and story views and sends them to the concept viewer.",
              "conceptIds": [
                "model-publication",
                "concept-project",
                "concept-model",
                "model-view",
                "story-view",
                "concept-viewer"
              ],
              "relationshipIds": [
                "rel-model-publication-uses-concept-project",
                "rel-model-publication-uses-concept-model",
                "rel-model-publication-uses-model-view",
                "rel-model-publication-uses-story-view",
                "rel-model-publication-to-concept-viewer"
              ],
              "primaryConceptIds": [
                "model-publication",
                "concept-viewer"
              ],
              "primaryRelationshipIds": [
                "rel-model-publication-to-concept-viewer"
              ]
            },
            {
              "id": "viewer-consumes-first-project",
              "index": 1,
              "title": "Concept viewer consumes models from the first project",
              "narrative": "The concept viewer receives the first publication output and records that these models and views belong to the originating concept project.",
              "conceptIds": [
                "concept-viewer",
                "model-publication",
                "concept-project"
              ],
              "relationshipIds": [
                "rel-concept-viewer-receives-publication",
                "rel-concept-viewer-consumes-project-models"
              ],
              "primaryConceptIds": [
                "concept-viewer"
              ],
              "primaryRelationshipIds": [
                "rel-concept-viewer-consumes-project-models"
              ]
            },
            {
              "id": "second-project-publishes",
              "index": 2,
              "title": "Second concept project publishes its models",
              "narrative": "Later, another model publication activity for a different concept project publishes its own concept models, model views, and story views to the same concept viewer.",
              "conceptIds": [
                "model-publication",
                "concept-project",
                "concept-model",
                "model-view",
                "story-view",
                "concept-viewer"
              ],
              "relationshipIds": [
                "rel-model-publication-uses-concept-project",
                "rel-model-publication-uses-concept-model",
                "rel-model-publication-uses-model-view",
                "rel-model-publication-uses-story-view",
                "rel-model-publication-to-concept-viewer"
              ],
              "primaryConceptIds": [
                "model-publication"
              ],
              "primaryRelationshipIds": [
                "rel-model-publication-uses-concept-project"
              ]
            },
            {
              "id": "viewer-holds-multiple-projects",
              "index": 3,
              "title": "Concept viewer now holds models from multiple projects",
              "narrative": "The concept viewer has now consumed models from multiple concept projects, enabling cross-project navigation and comparison.",
              "conceptIds": [
                "concept-viewer",
                "concept-project",
                "concept-model"
              ],
              "relationshipIds": [
                "rel-concept-viewer-consumes-project-models",
                "rel-concept-viewer-displays-concept-models"
              ],
              "primaryConceptIds": [
                "concept-viewer"
              ],
              "primaryRelationshipIds": [
                "rel-concept-viewer-consumes-project-models"
              ]
            },
            {
              "id": "human-explores-cross-project",
              "index": 4,
              "title": "Human user explores integrated models and stories",
              "narrative": "A human user starts a concept viewing session in the concept viewer and explores concept models, model views, and story views from multiple projects in one place.",
              "conceptIds": [
                "concept-viewer",
                "human-user",
                "concept-viewing-session",
                "concept-model",
                "model-view",
                "story-view"
              ],
              "relationshipIds": [
                "rel-concept-viewer-serves-human-users",
                "rel-concept-viewer-displays-concept-models",
                "rel-concept-viewer-displays-model-views",
                "rel-concept-viewer-displays-story-views",
                "rel-model-publication-precedes-concept-viewing"
              ],
              "primaryConceptIds": [
                "human-user",
                "concept-viewer"
              ],
              "primaryRelationshipIds": [
                "rel-concept-viewer-serves-human-users"
              ]
            }
          ]
        }
      ]
    }
  ]
}