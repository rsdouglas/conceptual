{
  "id": "gcp-data-request",
  "name": "Slack-based Data Request and LLM Evaluation System",
  "summary": "A system where Slack conversations about data turn into structured data requests that are processed, reviewed, and evaluated using LLMs and configurable templates.",
  "description": "The system listens to Slack threads, detects when someone is asking for data, and turns those conversations into formal data requests. It uses LLMs guided by templates and checks to iterate on, review, and fulfill those requests, while recording debug information and test results. An evaluation UI lets people manage templates, define test cases and checks, and run batches of tests against LLM responses to improve quality over time.",
  "models": [
    {
      "id": "slack-data-request-flow",
      "title": "Slack Data Request Flow",
      "description": "How Slack conversations become structured data requests, are processed by LLMs, and feed back into Slack.",
      "concepts": [
        {
          "id": "slack-user",
          "label": "Slack user",
          "category": "role",
          "description": "A person participating in Slack who may ask for data, respond to the bot, or review results.",
          "aliases": [
            "slack-user",
            "user",
            "userId",
            "createdBy"
          ],
          "notes": "A Slack user is a human participant in a Slack workspace who interacts with the Slack-based data request and LLM evaluation system. In this model, the Slack user is primarily identified by their Slack user ID string (e.g., in EventEnvelope.user, TaskPayload.user). They can send messages that become events, trigger tasks, and receive bot responses in Slack threads. Separately, a userId or createdBy field may refer to a (possibly the same) human user in the broader system context (e.g., test execution initiator, prompt template author), but the core concept here is the Slack-side identity that participates in channels and threads."
        },
        {
          "id": "slack-channel",
          "label": "Slack channel",
          "category": "place",
          "description": "A Slack channel or conversation where data-related threads occur and the bot participates.",
          "aliases": [
            "slack-channel",
            "channel",
            "slack conversation",
            "slack thread parent channel"
          ],
          "notes": "A Slack channel is the Slack conversation identifier where data-related threads occur and where the bot participates. In this system it is always represented by Slack's channel ID string (e.g., 'C0123456'). It is used to route incoming events, to post bot responses into the correct conversation, and to associate debug/telemetry events with the correct Slack location."
        },
        {
          "id": "slack-thread",
          "label": "Slack thread",
          "category": "thing",
          "description": "A threaded Slack conversation that may contain a data request and subsequent clarifications.",
          "aliases": [
            "slack-thread",
            "thread",
            "threaded Slack conversation",
            "Slack conversation thread",
            "root thread",
            "thread_ts",
            "rootTs"
          ],
          "notes": "A Slack thread is a conversation anchored to a single root message in a Slack channel. In this system, a Slack thread is identified by the timestamp of its root message (rootTs / thread_ts). The thread is the unit of context for data requests and for the bot’s responses. Bot actions such as adding a robot reaction and posting greeting or follow-up messages are always tied to a specific thread via its root timestamp and channel."
        },
        {
          "id": "slack-message",
          "label": "Slack message",
          "category": "event",
          "description": "An individual message in a Slack thread that may express a data need or provide context.",
          "aliases": [
            "slack-message",
            "Slack message",
            "thread message",
            "outgoing Slack message",
            "thread greeting",
            "thread reply",
            "thread_ts message",
            "text message",
            "blocks message"
          ],
          "notes": "A Slack message is an individual post in a Slack channel or thread. In this system, the focus is on messages posted by the bot into an existing thread (identified by a root timestamp, rootTs). These messages can be plain-text or block-based and are used to greet users, respond in data request threads, and provide context. Each outgoing Slack message is also recorded as a debug event with metadata such as channel, thread timestamp, text, and message type."
        },
        {
          "id": "data-request",
          "label": "Data request",
          "category": "thing",
          "description": "A structured representation of what data a Slack user is asking for, derived from Slack threads and refined by LLMs.",
          "aliases": [
            "data-request",
            "data request",
            "request",
            "well documented request",
            "clear request",
            "artifacts.request"
          ],
          "notes": "A Data Request is the structured, LLM-derived representation of what a Slack user is asking the data team to provide in terms of actual data values, metrics, numbers, counts, or other specific data content. It is extracted from a Slack thread, iteratively refined by LLM prompts, and stored as part of a thread's artifacts (e.g., `artifacts.request`). It is distinct from meta questions about field meanings or data structures, which are handled as direct answers rather than data requests."
        },
        {
          "id": "data-request-iteration",
          "label": "Data request iteration",
          "category": "activity",
          "description": "The process of refining an initial, possibly vague, data request into a precise, actionable specification using LLM guidance.",
          "aliases": [
            "data-request-iteration",
            "iteration on a data request",
            "in-thread iteration on a data request",
            "continue data request iteration",
            "update data request artifacts",
            "refine data request"
          ],
          "notes": "Data request iteration is the repeated, in-thread process of updating and refining a Slack-based data request as the conversation evolves. An LLM reviews the full Slack thread, the latest user reply, and previously generated artifacts (structured request, clarifying questions, step-by-step self-service instructions, and/or a direct answer) and then produces updated artifacts that better reflect the newest information. The iteration may remove clarifying questions once they are answered, refine the request as it becomes clearer, add or update self-service Looker instructions when feasible, or switch to providing a direct answer for meta questions about data structures or terminology. Each iteration is scoped to a single Slack thread and builds on prior artifacts rather than starting from scratch."
        },
        {
          "id": "data-request-review",
          "label": "Data request review",
          "category": "activity",
          "description": "An LLM- or human-guided review of a data request to ensure it is clear, feasible, and compliant before execution.",
          "aliases": [
            "data request review",
            "review",
            "review_data_request",
            "LLM review of data request",
            "Slackbot AI assistant review"
          ],
          "notes": "A data request review is an LLM-guided (and potentially human-guided) analysis and reformulation of a user's Slack data request. The review produces a clearer, well-documented version of the request plus supporting artifacts: clarifying questions, step-by-step self-service instructions (for Looker explores), and a direct answer for meta questions about data definitions or structures. The review acts as an intermediary step between the requester and the data team to ensure the request is unambiguous, feasible, and aligned with available data before execution."
        },
        {
          "id": "thread-status",
          "label": "Thread status",
          "category": "state",
          "description": "The current processing state of a Slack thread (e.g., new, classified, in progress, completed, error).",
          "aliases": [
            "thread-status",
            "thread status",
            "status",
            "processing state of a Slack thread"
          ],
          "notes": "Thread status represents the current processing state of a Slack thread within the Slack-based Data Request and LLM Evaluation System. It is updated via the updateThreadStatus(rootTs, status) operation and is stored alongside the thread document (e.g., in Firestore under threads/<root_ts>). The description suggests typical values such as 'new', 'classified', 'in progress', 'completed', and 'error', indicating where in the processing pipeline a given Slack thread currently is."
        },
        {
          "id": "slack-bot-interaction",
          "label": "Slack bot interaction",
          "category": "activity",
          "description": "The back-and-forth between the bot and Slack users, including greetings, clarifications, and delivery of results.",
          "aliases": [
            "slack-bot-interaction",
            "Slack bot interaction",
            "Slack thread interaction",
            "outgoing Slack message",
            "thread greeting",
            "thread message",
            "thread blocks",
            "robot reaction"
          ],
          "notes": "Slack bot interaction is the conversational exchange between the Slack bot and users within a Slack channel thread, anchored by a root message timestamp (rootTs). It includes the bot acknowledging a request with a robot_face reaction, posting an initial greeting in the thread, and sending subsequent messages (plain text or block-based) as part of the back-and-forth. Each outgoing bot message is recorded as a debug event associated with the root thread."
        },
        {
          "id": "slack-security-verification",
          "label": "Slack security verification",
          "category": "activity",
          "description": "The act of verifying that incoming Slack requests are authentic and untampered.",
          "aliases": [
            "Slack security verification",
            "Slack signature verification",
            "verifySlackSignature",
            "Slack request verification",
            "Slack HMAC verification"
          ],
          "notes": "Slack security verification is the process of confirming that an incoming Slack HTTP request is authentic and untampered by validating its HMAC-based signature and timestamp against a shared Slack signing secret. It specifically checks that the request carries a valid v0-style Slack signature, that the timestamp is recent (within an allowed skew window), and that the computed HMAC over the raw request body matches the provided signature using a constant-time comparison to mitigate timing attacks."
        }
      ],
      "relationships": [
        {
          "id": "rel-slack-user-sends-event-envelope",
          "from": "slack-user",
          "to": "event-envelope",
          "phrase": "sends messages that are represented by",
          "category": "represents",
          "description": "When a Slack user posts a message in Slack, that incoming message is represented in the system as an EventEnvelope, which includes the user field holding the Slack user ID."
        },
        {
          "id": "rel-slack-user-triggers-task-payload",
          "from": "slack-user",
          "to": "task-payload",
          "phrase": "triggers creation of",
          "category": "causes",
          "description": "A Slack user's message or interaction can cause the system to create a TaskPayload, where the user field records which Slack user initiated the task."
        },
        {
          "id": "rel-slack-user-participates-in-channel",
          "from": "slack-user",
          "to": "slack-channel",
          "phrase": "participates in",
          "category": "part_of",
          "description": "A Slack user participates in one or more Slack channels where data requests and bot interactions occur; the channel field in EventEnvelope and TaskPayload indicates the shared context for the user and the bot."
        },
        {
          "id": "rel-slack-user-initiates-test-execution",
          "from": "slack-user",
          "to": "test-execution-task-payload",
          "phrase": "is recorded as initiator of",
          "category": "represents",
          "description": "The userId field in TestExecutionTaskPayload records the human user who initiated or owns a test execution batch, which may correspond to a Slack user who requested or configured the test."
        },
        {
          "id": "rel-slack-user-creates-prompt-template",
          "from": "slack-user",
          "to": "prompt-template",
          "phrase": "creates",
          "category": "causes",
          "description": "The createdBy field on a PromptTemplate records the user who authored or created the template, representing a human user who may also interact via Slack."
        },
        {
          "id": "rel-slack-user-receives-bot-messages",
          "from": "slack-user",
          "to": "outgoing-slack-message-debug-event",
          "phrase": "receives messages logged as",
          "category": "represents",
          "description": "When the system posts a thread message back into Slack, it is typically in response to a Slack user's message; these outgoing messages are recorded as debug events of type 'outgoing_slack_message', implicitly tied to the original user's interaction via the rootTs/thread context."
        },
        {
          "id": "rel-slack-channel-has-events",
          "from": "slack-channel",
          "to": "slack-event-envelope",
          "phrase": "has",
          "category": "part_of",
          "description": "Each EventEnvelope is associated with exactly one Slack channel where the event occurred."
        },
        {
          "id": "rel-slack-event-occurs-in-channel",
          "from": "slack-event-envelope",
          "to": "slack-channel",
          "phrase": "occurs in",
          "category": "part_of",
          "description": "A Slack event (wrapped in an EventEnvelope) occurs in a specific Slack channel."
        },
        {
          "id": "rel-slack-channel-has-tasks",
          "from": "slack-channel",
          "to": "task-payload",
          "phrase": "has",
          "category": "part_of",
          "description": "Each TaskPayload references the Slack channel in which the related Slack thread or message resides."
        },
        {
          "id": "rel-task-refers-to-channel",
          "from": "task-payload",
          "to": "slack-channel",
          "phrase": "refers to",
          "category": "uses",
          "description": "A TaskPayload uses the Slack channel ID to know where to post responses or perform actions."
        },
        {
          "id": "rel-slack-channel-has-threads",
          "from": "slack-channel",
          "to": "slack-thread",
          "phrase": "has",
          "category": "part_of",
          "description": "A Slack channel contains one or more Slack threads, each identified by a root timestamp (rootTs)."
        },
        {
          "id": "rel-slack-thread-lives-in-channel",
          "from": "slack-thread",
          "to": "slack-channel",
          "phrase": "lives in",
          "category": "part_of",
          "description": "Each Slack thread is contained within a single Slack channel."
        },
        {
          "id": "rel-slack-channel-receives-bot-messages",
          "from": "slack-channel",
          "to": "bot-message",
          "phrase": "receives",
          "category": "uses",
          "description": "The bot posts messages into a Slack channel, typically as replies in a thread."
        },
        {
          "id": "rel-bot-message-posted-in-channel",
          "from": "bot-message",
          "to": "slack-channel",
          "phrase": "is posted in",
          "category": "part_of",
          "description": "Each outgoing bot message is posted in a specific Slack channel."
        },
        {
          "id": "rel-slack-channel-has-debug-events",
          "from": "slack-channel",
          "to": "debug-event",
          "phrase": "has",
          "category": "part_of",
          "description": "Debug events about outgoing Slack messages are associated with the channel where the message was posted."
        },
        {
          "id": "rel-debug-event-refers-to-channel",
          "from": "debug-event",
          "to": "slack-channel",
          "phrase": "refers to",
          "category": "uses",
          "description": "A debug event for an outgoing Slack message records the channel ID to indicate where the message was sent."
        },
        {
          "id": "rel-slack-channel-enables-bot-reactions",
          "from": "slack-channel",
          "to": "slack-reaction",
          "phrase": "enables",
          "category": "enables",
          "description": "The bot adds reactions (such as a robot_face) to messages within a Slack channel."
        },
        {
          "id": "rel-slack-reaction-occurs-in-channel",
          "from": "slack-reaction",
          "to": "slack-channel",
          "phrase": "occurs in",
          "category": "part_of",
          "description": "Each bot reaction is attached to a message that exists in a specific Slack channel."
        },
        {
          "id": "rel-slack-thread-channel",
          "from": "slack-thread",
          "to": "slack-channel",
          "phrase": "occurs in",
          "category": "part_of",
          "description": "Each Slack thread occurs within a specific Slack channel, identified by the channel ID passed alongside the thread's root timestamp."
        },
        {
          "id": "rel-slack-thread-root-message",
          "from": "slack-thread",
          "to": "slack-message",
          "phrase": "is anchored by",
          "category": "part_of",
          "description": "A Slack thread is anchored by a single root Slack message whose timestamp (rootTs / ts) identifies the thread."
        },
        {
          "id": "rel-slack-thread-has-messages",
          "from": "slack-thread",
          "to": "slack-message",
          "phrase": "contains",
          "category": "part_of",
          "description": "A Slack thread contains one or more Slack messages, including the root message and any replies posted with the thread_ts set to the root message timestamp."
        },
        {
          "id": "rel-slack-thread-may-contain-data-request",
          "from": "slack-thread",
          "to": "data-request",
          "phrase": "may contain",
          "category": "other",
          "description": "A Slack thread may contain a data request expressed by a user in the root message or subsequent messages in the thread."
        },
        {
          "id": "rel-slack-thread-used-by-task-payload",
          "from": "task-payload",
          "to": "slack-thread",
          "phrase": "references",
          "category": "uses",
          "description": "A TaskPayload references a Slack thread via the rootTs field, indicating which thread the task is associated with."
        },
        {
          "id": "rel-slack-thread-used-by-event-envelope",
          "from": "event-envelope",
          "to": "slack-thread",
          "phrase": "may reference",
          "category": "uses",
          "description": "An EventEnvelope may reference a Slack thread via the threadTs field when the event belongs to a thread."
        },
        {
          "id": "rel-slack-thread-receives-bot-reaction",
          "from": "slack-bot",
          "to": "slack-thread",
          "phrase": "adds robot reaction to root message of",
          "category": "uses",
          "description": "The Slack bot adds a robot_face reaction to the root message of a Slack thread to mark that the system has recognized and is handling the thread."
        },
        {
          "id": "rel-slack-thread-receives-bot-greeting",
          "from": "slack-bot",
          "to": "slack-thread",
          "phrase": "posts greeting message in",
          "category": "uses",
          "description": "The Slack bot posts an initial greeting message as a reply in the Slack thread, using the root message timestamp as thread_ts."
        },
        {
          "id": "rel-slack-thread-receives-bot-messages",
          "from": "slack-bot",
          "to": "slack-thread",
          "phrase": "posts messages in",
          "category": "uses",
          "description": "The Slack bot posts text or block messages into a Slack thread, using the rootTs as thread_ts to keep all bot responses within the same conversation context."
        },
        {
          "id": "rel-slack-thread-has-debug-events",
          "from": "debug-event",
          "to": "slack-thread",
          "phrase": "is recorded for",
          "category": "represents",
          "description": "Debug events such as outgoing_slack_message and time_to_react are recorded with the thread's root timestamp, associating diagnostic information with a specific Slack thread."
        },
        {
          "id": "rel-slack-message-in-thread",
          "from": "slack-message",
          "to": "slack-thread",
          "phrase": "is posted in",
          "category": "part_of",
          "description": "Each Slack message handled here is posted within a Slack thread, identified by the root thread timestamp (rootTs) and associated with a specific channel."
        },
        {
          "id": "rel-slack-message-in-channel",
          "from": "slack-message",
          "to": "slack-channel",
          "phrase": "appears in",
          "category": "part_of",
          "description": "Each Slack message is associated with a Slack channel where the thread resides."
        },
        {
          "id": "rel-slack-message-has-content",
          "from": "slack-message",
          "to": "message-content",
          "phrase": "has",
          "category": "part_of",
          "description": "A Slack message has content, which may be plain text or structured blocks."
        },
        {
          "id": "rel-slack-message-recorded-as-debug-event",
          "from": "slack-message",
          "to": "debug-event",
          "phrase": "is recorded as",
          "category": "represents",
          "description": "Each outgoing Slack message sent by the bot is recorded as a debug event of type 'outgoing_slack_message' with associated metadata."
        },
        {
          "id": "rel-slack-message-sent-by-bot",
          "from": "slack-message",
          "to": "bot-user",
          "phrase": "is sent by",
          "category": "uses",
          "description": "The Slack messages created via this API are sent by the bot user using the bot token."
        },
        {
          "id": "rel-slack-message-uses-root-timestamp",
          "from": "slack-message",
          "to": "thread-root-timestamp",
          "phrase": "is anchored by",
          "category": "uses",
          "description": "Each thread message references a root thread timestamp (rootTs) to associate it with the correct Slack thread."
        },
        {
          "id": "rel-slack-message-may-trigger-reaction",
          "from": "slack-message",
          "to": "slack-reaction",
          "phrase": "may have",
          "category": "part_of",
          "description": "A Slack message in a thread may receive a robot_face reaction from the bot, indicating automated processing or acknowledgment."
        },
        {
          "id": "rel-data-request-from-thread",
          "from": "data-request",
          "to": "slack-thread",
          "phrase": "is derived from",
          "category": "represents",
          "description": "A Data Request is derived from the content of a Slack thread (`fullThread` and `specificMessage`), representing the user's underlying ask for data."
        },
        {
          "id": "rel-data-request-requester",
          "from": "data-request",
          "to": "slack-user",
          "phrase": "is requested by",
          "category": "other",
          "description": "A Data Request is initiated by a Slack user (the requester) who posts messages in a Slack channel or thread asking for data."
        },
        {
          "id": "rel-data-request-artifacts",
          "from": "data-request",
          "to": "request-artifacts",
          "phrase": "is represented within",
          "category": "part_of",
          "description": "A Data Request is represented as the `request` field within a set of artifacts that also include clarifying questions, step-by-step instructions, and possibly a direct answer."
        },
        {
          "id": "rel-artifacts-clarifying-questions",
          "from": "request-artifacts",
          "to": "clarifying-questions",
          "phrase": "may include",
          "category": "part_of",
          "description": "The artifacts associated with a Data Request may include clarifying questions that must be answered by the user before the request is considered clear."
        },
        {
          "id": "rel-artifacts-step-by-step",
          "from": "request-artifacts",
          "to": "self-service-instructions",
          "phrase": "may include",
          "category": "part_of",
          "description": "The artifacts associated with a Data Request may include step-by-step Looker instructions that enable the requester to self-serve the answer."
        },
        {
          "id": "rel-artifacts-direct-answer",
          "from": "request-artifacts",
          "to": "direct-answer",
          "phrase": "may include",
          "category": "part_of",
          "description": "The artifacts associated with a Data Request may include a direct answer when the user’s question is about field meanings, business terminology, or data structures rather than actual data values."
        },
        {
          "id": "rel-data-request-reviewed-by-llm",
          "from": "data-request",
          "to": "llm-review-process",
          "phrase": "is reviewed and refined by",
          "category": "uses",
          "description": "A Data Request is reviewed and refined by an LLM-based review process that produces a clear, well-documented request and related artifacts."
        },
        {
          "id": "rel-data-request-iteration",
          "from": "data-request",
          "to": "llm-iteration-process",
          "phrase": "is iteratively updated by",
          "category": "uses",
          "description": "A Data Request is iteratively updated by an LLM iteration process that incorporates new Slack messages and previously produced artifacts to refine the request and related fields."
        },
        {
          "id": "rel-thread-has-artifacts",
          "from": "slack-thread",
          "to": "request-artifacts",
          "phrase": "stores",
          "category": "part_of",
          "description": "A Slack thread document stores the artifacts for a Data Request, including the structured request, clarifying questions, and step-by-step instructions."
        },
        {
          "id": "rel-thread-has-status",
          "from": "slack-thread",
          "to": "data-request-status",
          "phrase": "has",
          "category": "part_of",
          "description": "A Slack thread that contains a Data Request has a status field (processing, accepted, rejected, unhandled) representing the handling state of the Data Request."
        },
        {
          "id": "rel-classification-identifies-data-request",
          "from": "llm-classification",
          "to": "data-request",
          "phrase": "determines whether a thread contains",
          "category": "causes",
          "description": "The LLM classification step (`isDataRequest`) determines whether a Slack thread should be treated as containing a Data Request."
        },
        {
          "id": "rel-data-request-iteration-updates-artifacts",
          "from": "data-request-iteration",
          "to": "data-request-artifacts",
          "phrase": "updates",
          "category": "uses",
          "description": "Data request iteration updates the set of artifacts associated with a data request (structured request, clarifying questions, step-by-step instructions, direct answer) to reflect the latest Slack thread context."
        },
        {
          "id": "rel-data-request-iteration-uses-slack-thread",
          "from": "data-request-iteration",
          "to": "slack-thread",
          "phrase": "uses",
          "category": "uses",
          "description": "Data request iteration uses the full Slack thread, including the latest user reply, as conversational context for refining the data request."
        },
        {
          "id": "rel-data-request-iteration-uses-prior-artifacts",
          "from": "data-request-iteration",
          "to": "prior-artifacts",
          "phrase": "builds on",
          "category": "uses",
          "description": "Data request iteration builds on prior artifacts (previous request text, clarifying questions, step-by-step instructions, and any direct answer) when producing updated artifacts."
        },
        {
          "id": "rel-data-request-iteration-invokes-llm",
          "from": "data-request-iteration",
          "to": "llm-model",
          "phrase": "invokes",
          "category": "uses",
          "description": "Data request iteration invokes a generative LLM model to interpret the Slack thread and prior artifacts and to generate updated artifacts."
        },
        {
          "id": "rel-data-request-iteration-refines-data-request",
          "from": "data-request-iteration",
          "to": "data-request",
          "phrase": "refines",
          "category": "causes",
          "description": "Data request iteration refines an initially vague or incomplete data request into a clearer, more actionable specification over multiple steps."
        },
        {
          "id": "rel-data-request-iteration-produces-clarifying-questions",
          "from": "data-request-iteration",
          "to": "clarifying-questions",
          "phrase": "produces or removes",
          "category": "causes",
          "description": "Data request iteration may produce clarifying questions when the request is unclear, and remove them once the Slack conversation has answered them."
        },
        {
          "id": "rel-data-request-iteration-produces-step-by-step-instructions",
          "from": "data-request-iteration",
          "to": "self-service-step-by-step-instructions",
          "phrase": "produces",
          "category": "causes",
          "description": "Data request iteration produces or updates step-by-step Looker self-service instructions when the request can be fulfilled by the requester directly."
        },
        {
          "id": "rel-data-request-iteration-produces-direct-answer",
          "from": "data-request-iteration",
          "to": "direct-answer",
          "phrase": "produces",
          "category": "causes",
          "description": "Data request iteration produces a direct answer artifact when the Slack message is a meta question about field meanings, business terminology, or data structures rather than a request for specific data values."
        },
        {
          "id": "rel-data-request-iteration-uses-context-templates",
          "from": "data-request-iteration",
          "to": "llm-context",
          "phrase": "uses",
          "category": "uses",
          "description": "Data request iteration may use shared LLM context files and templates to guide how the LLM interprets and refines data requests."
        },
        {
          "id": "rel-data-request-review-uses-data-request",
          "from": "data-request-review",
          "to": "data-request",
          "phrase": "analyzes and reformulates",
          "category": "uses",
          "description": "A data request review analyzes an incoming data request from a Slack user and reformulates it into a clearer, well-documented request."
        },
        {
          "id": "rel-data-request-review-uses-clarifying-questions",
          "from": "data-request-review",
          "to": "clarifying-questions",
          "phrase": "produces",
          "category": "causes",
          "description": "A data request review produces clarifying questions when the original request is ambiguous or incomplete; these questions are shown to the user to refine the request."
        },
        {
          "id": "rel-data-request-review-uses-step-by-step-instructions",
          "from": "data-request-review",
          "to": "step-by-step-instructions",
          "phrase": "produces",
          "category": "causes",
          "description": "A data request review produces step-by-step instructions describing how to use specific explores in Looker to self-serve the requested data when self-service is feasible."
        },
        {
          "id": "rel-data-request-review-uses-direct-answer",
          "from": "data-request-review",
          "to": "direct-answer",
          "phrase": "produces",
          "category": "causes",
          "description": "A data request review produces a direct answer when the user is asking a meta question about field meanings, business terminology, or data structures rather than about actual data values."
        },
        {
          "id": "rel-data-request-review-enables-data-team-execution",
          "from": "data-request-review",
          "to": "data-team-execution",
          "phrase": "prepares request for",
          "category": "enables",
          "description": "A data request review prepares a well-documented, unambiguous request that enables the data team to execute the request efficiently when self-service is not sufficient."
        },
        {
          "id": "rel-data-request-review-uses-llm",
          "from": "data-request-review",
          "to": "llm",
          "phrase": "is performed by",
          "category": "uses",
          "description": "A data request review is performed by an LLM-based Slackbot AI assistant that interprets the user's Slack message and generates review artifacts."
        },
        {
          "id": "rel-data-request-review-occurs-in-slack-data-request-flow",
          "from": "data-request-review",
          "to": "slack-data-request-flow",
          "phrase": "is a step in",
          "category": "part_of",
          "description": "A data request review is a distinct step within the overall Slack Data Request Flow, occurring after a user submits a request and before the user or data team acts on it."
        },
        {
          "id": "rel-thread-status-belongs-to-thread",
          "from": "thread-status",
          "to": "slack-thread",
          "phrase": "belongs to",
          "category": "part_of",
          "description": "Each thread status is associated with exactly one Slack thread, identified by its root_ts, and describes that thread's current processing state in the system."
        },
        {
          "id": "rel-thread-status-updated-by-worker",
          "from": "thread-status",
          "to": "worker-service",
          "phrase": "is updated by",
          "category": "uses",
          "description": "Thread status is updated by the worker service via the updateThreadStatus(rootTs, status) function as the system processes Slack threads."
        },
        {
          "id": "rel-thread-status-stored-in-threads-collection",
          "from": "thread-status",
          "to": "threads-collection",
          "phrase": "is stored in",
          "category": "part_of",
          "description": "Thread status is persisted as part of the thread document in the threads collection (threads/<root_ts>) in the backing data store."
        },
        {
          "id": "rel-slack-bot-interaction-uses-slack-thread",
          "from": "slack-bot-interaction",
          "to": "slack-thread",
          "phrase": "occurs in",
          "category": "part_of",
          "description": "Each Slack bot interaction occurs within a specific Slack thread, identified by a channel and a root message timestamp (rootTs) used as thread_ts."
        },
        {
          "id": "rel-slack-bot-interaction-uses-robot-reaction",
          "from": "slack-bot-interaction",
          "to": "slack-reaction",
          "phrase": "includes",
          "category": "part_of",
          "description": "A Slack bot interaction may include the bot adding a robot_face reaction to the root message to acknowledge the request."
        },
        {
          "id": "rel-slack-bot-interaction-uses-greeting",
          "from": "slack-bot-interaction",
          "to": "slack-thread-greeting",
          "phrase": "starts with",
          "category": "precedes",
          "description": "A Slack bot interaction may begin with the bot posting a greeting message in the thread associated with the root message."
        },
        {
          "id": "rel-slack-bot-interaction-uses-text-message",
          "from": "slack-bot-interaction",
          "to": "slack-thread-text-message",
          "phrase": "sends",
          "category": "uses",
          "description": "During a Slack bot interaction, the bot sends one or more text messages into the thread using chat.postMessage with a text payload."
        },
        {
          "id": "rel-slack-bot-interaction-uses-block-message",
          "from": "slack-bot-interaction",
          "to": "slack-thread-block-message",
          "phrase": "sends",
          "category": "uses",
          "description": "During a Slack bot interaction, the bot may send one or more block-based messages into the thread using chat.postMessage with blocks payload."
        },
        {
          "id": "rel-slack-bot-interaction-produces-debug-event",
          "from": "slack-bot-interaction",
          "to": "debug-event",
          "phrase": "produces",
          "category": "causes",
          "description": "Each outgoing Slack text message from the bot causes a debug event of type 'outgoing_slack_message' to be recorded, capturing channel, threadTs, text, and messageType."
        },
        {
          "id": "rel-debug-event-represents-slack-bot-message",
          "from": "debug-event",
          "to": "slack-bot-interaction",
          "phrase": "represents",
          "category": "represents",
          "description": "An outgoing_slack_message debug event represents a specific bot message within a Slack bot interaction, allowing later inspection of the interaction."
        },
        {
          "id": "rel-slack-verification-uses-signature",
          "from": "slack-security-verification",
          "to": "slack-request-signature",
          "phrase": "uses",
          "category": "uses",
          "description": "Slack security verification uses the Slack-provided request signature value to determine whether the request is authentic."
        },
        {
          "id": "rel-slack-verification-uses-timestamp",
          "from": "slack-security-verification",
          "to": "slack-request-timestamp",
          "phrase": "uses",
          "category": "uses",
          "description": "Slack security verification uses the Slack-provided request timestamp to detect and reject stale or replayed requests."
        },
        {
          "id": "rel-slack-verification-uses-raw-body",
          "from": "slack-security-verification",
          "to": "slack-raw-request-body",
          "phrase": "uses",
          "category": "uses",
          "description": "Slack security verification uses the exact raw HTTP request body as part of the base string for HMAC computation, ensuring that any tampering with the body invalidates the signature."
        },
        {
          "id": "rel-slack-verification-uses-signing-secret",
          "from": "slack-security-verification",
          "to": "slack-signing-secret",
          "phrase": "uses",
          "category": "uses",
          "description": "Slack security verification uses the shared Slack signing secret to compute the expected HMAC signature for comparison with the provided signature."
        },
        {
          "id": "rel-slack-verification-prevents-replay",
          "from": "slack-security-verification",
          "to": "slack-request-replay-attack",
          "phrase": "prevents",
          "category": "prevents",
          "description": "Slack security verification prevents replay attacks by rejecting requests whose timestamps are outside the allowed time window."
        },
        {
          "id": "rel-slack-verification-prevents-tampering",
          "from": "slack-security-verification",
          "to": "slack-request-tampering",
          "phrase": "prevents",
          "category": "prevents",
          "description": "Slack security verification prevents processing of tampered Slack requests by rejecting any request whose computed HMAC does not match the provided signature."
        },
        {
          "id": "rel-slack-verification-enables-trust",
          "from": "slack-security-verification",
          "to": "trusted-slack-request",
          "phrase": "enables",
          "category": "enables",
          "description": "Slack security verification enables classification of an incoming Slack request as trusted when the signature and timestamp checks succeed."
        }
      ],
      "rules": [
        {
          "id": "rule-slack-user-identified-by-id-string",
          "title": "Slack user is identified by a user ID string",
          "text": "Within the Slack Data Request Flow, a Slack user is represented by a user identifier string (e.g., EventEnvelope.user, TaskPayload.user, TestExecutionTaskPayload.userId, PromptTemplate.createdBy) rather than by a full user profile object.",
          "kind": "assumption",
          "conceptIds": [
            "slack-user"
          ]
        },
        {
          "id": "rule-slack-user-may-be-absent-on-events",
          "title": "Slack user may be missing on some events",
          "text": "EventEnvelope.user is optional, so some events may not be associated with a specific Slack user (for example, system-generated or bot-generated events).",
          "kind": "assumption",
          "conceptIds": [
            "slack-user"
          ]
        },
        {
          "id": "rule-channel-required-for-slack-actions",
          "title": "Channel is required for Slack actions",
          "text": "Any bot action that posts a message or adds a reaction in Slack must specify a valid Slack channel identifier.",
          "kind": "constraint",
          "conceptIds": [
            "slack-channel"
          ]
        },
        {
          "id": "rule-single-channel-per-event-envelope",
          "title": "EventEnvelope has exactly one channel",
          "text": "Each EventEnvelope is associated with exactly one Slack channel, represented by its channel ID string.",
          "kind": "invariant",
          "conceptIds": [
            "slack-channel"
          ]
        },
        {
          "id": "rule-single-channel-per-task-payload",
          "title": "TaskPayload has exactly one channel",
          "text": "Each TaskPayload references exactly one Slack channel where the related thread or message exists.",
          "kind": "invariant",
          "conceptIds": [
            "slack-channel"
          ]
        },
        {
          "id": "rule-slack-thread-identified-by-rootts",
          "title": "Slack thread is identified by root timestamp within a channel",
          "text": "Within this system, a Slack thread is uniquely identified by the combination of its channel ID and the timestamp of its root message (rootTs / thread_ts). All bot actions and debug events related to a thread must use this pair.",
          "kind": "invariant",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-slack-thread-bot-messages-use-thread-ts",
          "title": "Bot messages in a thread must set thread_ts to the root message timestamp",
          "text": "When the bot posts a message intended to belong to a Slack thread, it must set the thread_ts field to the root message timestamp so that Slack associates the message with the correct thread.",
          "kind": "constraint",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-slack-thread-robot-reaction-on-root",
          "title": "Robot reaction is applied to the root message of the thread",
          "text": "When marking a Slack thread as being handled by the system, the robot_face reaction is added to the root message timestamp of that thread, not to replies.",
          "kind": "policy",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-slack-thread-debug-events-keyed-by-rootts",
          "title": "Debug events for a thread are keyed by the thread root timestamp",
          "text": "All debug events related to a Slack thread, such as outgoing Slack messages, must be recorded using the thread's root timestamp as the primary identifier to correlate events with the thread.",
          "kind": "assumption",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-slack-message-requires-bot-token",
          "title": "Outgoing Slack messages require a valid bot token",
          "text": "A Slack message can only be posted by the system if a valid Slack bot token (SLACK_BOT_TOKEN) is configured; otherwise, message posting fails.",
          "kind": "constraint",
          "conceptIds": [
            "slack-message"
          ]
        },
        {
          "id": "rule-slack-message-must-specify-channel-and-thread",
          "title": "Slack thread messages must specify channel and root thread timestamp",
          "text": "When the system posts a Slack message into a thread, it must include both the channel identifier and the root thread timestamp (rootTs) to correctly associate the message with the thread.",
          "kind": "invariant",
          "conceptIds": [
            "slack-message"
          ]
        },
        {
          "id": "rule-slack-message-debug-event-recording",
          "title": "Outgoing Slack messages are recorded as debug events",
          "text": "For each outgoing Slack message posted by the system, a corresponding debug event of type 'outgoing_slack_message' should be recorded with timestamp, channel, threadTs, text, and messageType, unless recording fails.",
          "kind": "policy",
          "conceptIds": [
            "slack-message"
          ]
        },
        {
          "id": "rule-slack-message-error-handling",
          "title": "Slack message posting must handle Slack API errors",
          "text": "If the Slack API returns a non-OK HTTP status or an error response (other than 'already_reacted'), the system treats this as a failure to post or react to a Slack message.",
          "kind": "assumption",
          "conceptIds": [
            "slack-message"
          ]
        },
        {
          "id": "rule-data-vs-meta",
          "title": "Data Request vs Meta Question",
          "text": "If a user question is about actual data values, metrics, numbers, counts, or specific data content, it must be treated as a Data Request. If a question is only about field meanings, business terminology, or data structures and does not ask for specific data values, it must be treated as a direct answer and not as a Data Request.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-clarifying-questions-gate",
          "title": "Clarifying Questions Gate Visibility",
          "text": "When clarifying questions exist for a Data Request, only the clarifying questions are shown to the user; the well-documented request and other artifacts are kept internal until the clarifying questions are resolved.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-no-clarifying-questions-display",
          "title": "Display Instructions or Request When Clear",
          "text": "When a Data Request has no remaining clarifying questions, the system shows the user step-by-step self-service instructions if available; otherwise, it shows the well-documented request.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-iteration-updates-artifacts",
          "title": "Iteration Must Update Artifacts",
          "text": "Each iteration on a Data Request must update the artifacts (request, clarifying questions, step-by-step instructions, direct answer) to reflect the latest Slack thread messages and previously produced artifacts, removing clarifying questions that have been fully answered.",
          "kind": "assumption",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-request-should-be-unambiguous",
          "title": "Request Should Be Well Documented and Unambiguous",
          "text": "The LLM review process must aim to produce a clear, well-documented, and unambiguous Data Request that refers to existing data in a way that makes it simple for an analyst to extract the required data, explicitly calling out any assumptions.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-data-request-iteration-removes-answered-questions",
          "title": "Remove clarifying questions once fully answered",
          "text": "During a data request iteration, if clarifying questions have been fully answered in the Slack thread, the updated artifacts must remove those clarifying questions.",
          "kind": "invariant",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "rule-data-request-iteration-refines-clear-request",
          "title": "Refine request when it becomes clear",
          "text": "During a data request iteration, if the data request is now clear based on the latest Slack messages, the iteration must refine and update the request artifact to reflect that clarity.",
          "kind": "invariant",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "rule-data-request-iteration-adds-self-service-when-possible",
          "title": "Provide self-service instructions when feasible",
          "text": "During a data request iteration, if the request can be satisfied via self-service in Looker, the iteration should provide or update step-by-step Looker instructions in the artifacts.",
          "kind": "policy",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "rule-data-request-iteration-direct-answer-scope",
          "title": "Direct answers only for meta questions",
          "text": "During a data request iteration, a direct answer artifact may be produced only for meta questions about field meanings, business terminology, data structure explanations, or how data is organized, and must not be used for questions about actual data values, metrics, numbers, counts, or specific data content.",
          "kind": "constraint",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "rule-data-request-iteration-data-questions-treated-as-requests",
          "title": "Treat data-value questions as data requests",
          "text": "During a data request iteration, if the user question involves actual data values, metrics, numbers, counts, or specific data content, the iteration must treat it as a data request and use the request and step-by-step instructions artifacts instead of a direct answer artifact.",
          "kind": "constraint",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "rule-data-request-iteration-uses-full-thread-and-latest-reply",
          "title": "Iteration must consider full Slack thread and latest reply",
          "text": "Each data request iteration must consider the full Slack thread so far and the latest user reply when updating artifacts, ensuring that new information and answers are incorporated.",
          "kind": "assumption",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "rule-data-request-iteration-updates-not-recreates",
          "title": "Iteration updates existing artifacts rather than starting from scratch",
          "text": "A data request iteration should update the latest artifacts it previously produced (request, clarifying questions, self-service steps, direct answer) instead of discarding them and generating unrelated artifacts.",
          "kind": "policy",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "rule-data-request-review-must-produce-structured-output",
          "title": "Data request review must produce all review artifacts in structured form",
          "text": "A data request review must return a structured result containing four fields: a well-documented request, clarifying questions, step-by-step instructions for self-service (if applicable), and a direct answer for meta questions.",
          "kind": "constraint",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-data-request-review-shows-only-clarifying-questions-when-present",
          "title": "Clarifying questions take precedence in user-facing output",
          "text": "If a data request review produces any clarifying questions, only those clarifying questions are shown to the user at that stage; the other artifacts are retained for later iteration after the user responds.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-data-request-review-shows-instructions-or-request-when-no-questions",
          "title": "Instructions or well-documented request are shown when no clarifying questions remain",
          "text": "When a data request review produces no clarifying questions, the system shows the user the step-by-step self-service instructions if they are available; otherwise, it shows the well-documented request produced by the review.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-data-request-review-direct-answer-scope",
          "title": "Direct answers limited to meta questions",
          "text": "A data request review may provide a direct answer only for meta questions about field meanings, business terminology, or data structures, and must not directly answer questions about actual data values, metrics, or numbers.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-data-request-review-must-call-out-assumptions",
          "title": "Assumptions must be explicit",
          "text": "During a data request review, the reviewer may make reasonable assumptions to clarify the request but must explicitly call out those assumptions so they can be corrected if wrong.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-thread-status-requires-thread-identifier",
          "title": "Thread status is always tied to a specific root_ts",
          "text": "A thread status must always be associated with a specific Slack thread, identified by its root_ts; updating thread status requires providing this root_ts.",
          "kind": "constraint",
          "conceptIds": [
            "thread-status"
          ]
        },
        {
          "id": "rule-thread-status-represents-processing-state",
          "title": "Thread status reflects processing progress",
          "text": "Thread status must represent the current processing state of the Slack thread within the system's pipeline (e.g., new, classified, in progress, completed, error).",
          "kind": "assumption",
          "conceptIds": [
            "thread-status"
          ]
        },
        {
          "id": "rule-slack-bot-interaction-requires-bot-token",
          "title": "Slack bot interaction requires a configured bot token",
          "text": "A Slack bot interaction can only proceed if a valid Slack bot token (SLACK_BOT_TOKEN) is configured; otherwise, Slack API calls for reactions and messages must not be executed.",
          "kind": "constraint",
          "conceptIds": [
            "slack-bot-interaction"
          ]
        },
        {
          "id": "rule-slack-bot-interaction-anchored-by-root-message",
          "title": "Slack bot interaction is anchored by a root message",
          "text": "Every Slack bot interaction is anchored to a root Slack message identified by a root timestamp (rootTs), which is used as the thread_ts for all bot messages and reactions in that interaction.",
          "kind": "invariant",
          "conceptIds": [
            "slack-bot-interaction"
          ]
        },
        {
          "id": "rule-slack-bot-interaction-records-outgoing-text-messages",
          "title": "Outgoing text messages are recorded as debug events",
          "text": "For each outgoing text message the bot posts to a Slack thread, the system should attempt to record a corresponding outgoing_slack_message debug event with channel, threadTs, text, messageType, and timestamp.",
          "kind": "policy",
          "conceptIds": [
            "slack-bot-interaction"
          ]
        },
        {
          "id": "rule-slack-bot-interaction-ignores-already-reacted-error",
          "title": "Robot reaction ignores 'already_reacted' Slack error",
          "text": "When adding a robot_face reaction as part of a Slack bot interaction, the system must treat the Slack 'already_reacted' error as non-fatal and continue the interaction.",
          "kind": "policy",
          "conceptIds": [
            "slack-bot-interaction"
          ]
        },
        {
          "id": "rule-slack-verification-requires-inputs",
          "title": "Slack verification requires all security inputs",
          "text": "Slack security verification must treat a Slack request as unverified if any of the required security inputs (signature, timestamp, raw body, or signing secret) are missing or empty.",
          "kind": "constraint",
          "conceptIds": [
            "slack-security-verification"
          ]
        },
        {
          "id": "rule-slack-verification-timestamp-window",
          "title": "Slack verification enforces a 5-minute timestamp window",
          "text": "Slack security verification must reject Slack requests whose timestamps differ from the current server time by more than five minutes, in order to limit replay and stale requests.",
          "kind": "policy",
          "conceptIds": [
            "slack-security-verification"
          ]
        },
        {
          "id": "rule-slack-verification-valid-timestamp",
          "title": "Slack verification requires a valid numeric timestamp",
          "text": "Slack security verification must treat a Slack request as unverified if the provided timestamp cannot be interpreted as a finite numeric Unix timestamp in seconds.",
          "kind": "constraint",
          "conceptIds": [
            "slack-security-verification"
          ]
        },
        {
          "id": "rule-slack-verification-hmac-match",
          "title": "Slack verification requires HMAC signature match",
          "text": "Slack security verification must reject a Slack request if the HMAC-based expected signature computed from the timestamp, raw body, and signing secret does not exactly match the provided Slack signature.",
          "kind": "invariant",
          "conceptIds": [
            "slack-security-verification"
          ]
        },
        {
          "id": "rule-slack-verification-constant-time-compare",
          "title": "Slack verification uses constant-time comparison",
          "text": "Slack security verification must compare the provided Slack signature and the expected signature using a constant-time comparison to reduce susceptibility to timing attacks.",
          "kind": "policy",
          "conceptIds": [
            "slack-security-verification"
          ]
        },
        {
          "id": "rule-slack-verification-binary-result",
          "title": "Slack verification yields a binary decision",
          "text": "Slack security verification must yield a binary outcome indicating whether the Slack request is verified (true) or not verified (false).",
          "kind": "invariant",
          "conceptIds": [
            "slack-security-verification"
          ]
        }
      ],
      "lifecycles": [
        {
          "id": "lifecycle-data-request-status",
          "subjectConceptId": "data-request",
          "stateConceptIds": [
            "data-request-processing",
            "data-request-accepted",
            "data-request-rejected",
            "data-request-unhandled"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "data-request-processing",
          "terminalStateIds": [
            "data-request-accepted",
            "data-request-rejected",
            "data-request-unhandled"
          ]
        },
        {
          "id": "lifecycle-data-request-review-basic",
          "subjectConceptId": "data-request-review",
          "stateConceptIds": [
            "data-request-review-with-clarifying-questions",
            "data-request-review-without-clarifying-questions"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "data-request-review-with-clarifying-questions",
          "terminalStateIds": [
            "data-request-review-without-clarifying-questions"
          ]
        },
        {
          "id": "lifecycle-thread-status-processing",
          "subjectConceptId": "thread-status",
          "stateConceptIds": [
            "thread-status-new",
            "thread-status-classified",
            "thread-status-in-progress",
            "thread-status-completed",
            "thread-status-error"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "thread-status-new",
          "terminalStateIds": [
            "thread-status-completed",
            "thread-status-error"
          ]
        },
        {
          "id": "lifecycle-slack-verification-decision",
          "subjectConceptId": "slack-security-verification",
          "stateConceptIds": [
            "slack-request-unverified",
            "slack-request-verified",
            "slack-request-rejected"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "slack-request-unverified",
          "terminalStateIds": [
            "slack-request-verified",
            "slack-request-rejected"
          ]
        }
      ],
      "views": [
        {
          "id": "slack-conversation-overview",
          "name": "Slack conversation overview",
          "description": "High-level view of how Slack users, channels, threads, and messages relate, and where data requests and bot interactions appear.",
          "conceptIds": [
            "slack-user",
            "slack-channel",
            "slack-thread",
            "slack-message",
            "data-request",
            "thread-status",
            "slack-bot-interaction"
          ],
          "relationshipIds": [
            "rel-slack-user-participates-in-channel",
            "rel-slack-channel-has-threads",
            "rel-slack-thread-lives-in-channel",
            "rel-slack-thread-channel",
            "rel-slack-thread-root-message",
            "rel-slack-thread-has-messages",
            "rel-slack-message-in-thread",
            "rel-slack-message-in-channel",
            "rel-slack-thread-may-contain-data-request",
            "rel-data-request-from-thread",
            "rel-data-request-requester",
            "rel-thread-status-belongs-to-thread",
            "rel-slack-bot-interaction-uses-slack-thread"
          ],
          "layout": {
            "groups": [
              {
                "id": "slack-zone",
                "title": "Slack",
                "x": 80,
                "y": 60,
                "width": 520,
                "height": 520,
                "conceptIds": [
                  "slack-user",
                  "slack-channel",
                  "slack-thread",
                  "slack-message",
                  "slack-bot-interaction",
                  "thread-status"
                ]
              },
              {
                "id": "data-request-zone",
                "title": "Data request (structured)",
                "x": 640,
                "y": 220,
                "width": 260,
                "height": 220,
                "conceptIds": [
                  "data-request"
                ]
              }
            ]
          }
        },
        {
          "id": "slack-bot-interaction-view",
          "name": "Slack bot interaction",
          "description": "Focused view on how the bot interacts in Slack threads, including greetings, reactions, and debug logging.",
          "conceptIds": [
            "slack-thread",
            "slack-message",
            "slack-bot-interaction",
            "slack-reaction",
            "slack-thread-greeting",
            "slack-thread-text-message",
            "slack-thread-block-message",
            "debug-event"
          ],
          "relationshipIds": [
            "rel-slack-thread-has-messages",
            "rel-slack-message-in-thread",
            "rel-slack-bot-interaction-uses-slack-thread",
            "rel-slack-bot-interaction-uses-robot-reaction",
            "rel-slack-bot-interaction-uses-greeting",
            "rel-slack-bot-interaction-uses-text-message",
            "rel-slack-bot-interaction-uses-block-message",
            "rel-slack-bot-interaction-produces-debug-event",
            "rel-debug-event-represents-slack-bot-message",
            "rel-slack-message-may-trigger-reaction"
          ],
          "layout": {
            "groups": [
              {
                "id": "thread-zone",
                "title": "Slack thread",
                "x": 80,
                "y": 60,
                "width": 420,
                "height": 420,
                "conceptIds": [
                  "slack-thread",
                  "slack-message",
                  "slack-reaction",
                  "slack-thread-greeting",
                  "slack-thread-text-message",
                  "slack-thread-block-message"
                ]
              },
              {
                "id": "bot-zone",
                "title": "Bot interaction + logging",
                "x": 540,
                "y": 120,
                "width": 320,
                "height": 320,
                "conceptIds": [
                  "slack-bot-interaction",
                  "debug-event"
                ]
              }
            ]
          }
        },
        {
          "id": "data-request-lifecycle",
          "name": "Data request lifecycle",
          "description": "How a data request is derived from a Slack thread, iterated on by LLMs, and reviewed before execution.",
          "conceptIds": [
            "slack-thread",
            "slack-user",
            "data-request",
            "data-request-iteration",
            "data-request-review",
            "request-artifacts",
            "clarifying-questions",
            "self-service-instructions",
            "direct-answer",
            "llm-review-process",
            "llm-iteration-process",
            "llm-model",
            "llm-context",
            "prior-artifacts",
            "data-team-execution"
          ],
          "relationshipIds": [
            "rel-slack-thread-may-contain-data-request",
            "rel-data-request-from-thread",
            "rel-data-request-requester",
            "rel-data-request-artifacts",
            "rel-artifacts-clarifying-questions",
            "rel-artifacts-step-by-step",
            "rel-artifacts-direct-answer",
            "rel-data-request-reviewed-by-llm",
            "rel-data-request-iteration",
            "rel-data-request-iteration-updates-artifacts",
            "rel-data-request-iteration-uses-slack-thread",
            "rel-data-request-iteration-uses-prior-artifacts",
            "rel-data-request-iteration-invokes-llm",
            "rel-data-request-iteration-refines-data-request",
            "rel-data-request-iteration-produces-clarifying-questions",
            "rel-data-request-iteration-produces-step-by-step-instructions",
            "rel-data-request-iteration-produces-direct-answer",
            "rel-data-request-iteration-uses-context-templates",
            "rel-data-request-review-uses-data-request",
            "rel-data-request-review-uses-clarifying-questions",
            "rel-data-request-review-uses-step-by-step-instructions",
            "rel-data-request-review-uses-direct-answer",
            "rel-data-request-review-enables-data-team-execution",
            "rel-data-request-review-uses-llm"
          ],
          "layout": {
            "groups": [
              {
                "id": "slack-origin-zone",
                "title": "Slack origin",
                "x": 60,
                "y": 80,
                "width": 260,
                "height": 260,
                "conceptIds": [
                  "slack-thread",
                  "slack-user"
                ]
              },
              {
                "id": "request-core-zone",
                "title": "Data request",
                "x": 360,
                "y": 80,
                "width": 260,
                "height": 260,
                "conceptIds": [
                  "data-request",
                  "request-artifacts",
                  "clarifying-questions",
                  "self-service-instructions",
                  "direct-answer"
                ]
              },
              {
                "id": "iteration-zone",
                "title": "LLM iteration",
                "x": 60,
                "y": 380,
                "width": 360,
                "height": 260,
                "conceptIds": [
                  "data-request-iteration",
                  "llm-iteration-process",
                  "llm-model",
                  "llm-context",
                  "prior-artifacts"
                ]
              },
              {
                "id": "review-zone",
                "title": "Review & execution",
                "x": 460,
                "y": 380,
                "width": 360,
                "height": 260,
                "conceptIds": [
                  "data-request-review",
                  "llm-review-process",
                  "data-team-execution"
                ]
              }
            ]
          }
        },
        {
          "id": "thread-status-and-storage",
          "name": "Thread status and storage",
          "description": "How thread status is maintained and stored, and how artifacts and status attach to threads.",
          "conceptIds": [
            "slack-thread",
            "thread-status",
            "request-artifacts",
            "data-request-status",
            "worker-service",
            "threads-collection"
          ],
          "relationshipIds": [
            "rel-thread-status-belongs-to-thread",
            "rel-thread-status-updated-by-worker",
            "rel-thread-status-stored-in-threads-collection",
            "rel-thread-has-artifacts",
            "rel-thread-has-status"
          ],
          "layout": {
            "groups": [
              {
                "id": "slack-thread-zone",
                "title": "Slack thread",
                "x": 80,
                "y": 120,
                "width": 260,
                "height": 260,
                "conceptIds": [
                  "slack-thread",
                  "thread-status",
                  "request-artifacts",
                  "data-request-status"
                ]
              },
              {
                "id": "backend-zone",
                "title": "Backend worker & storage",
                "x": 420,
                "y": 80,
                "width": 360,
                "height": 320,
                "conceptIds": [
                  "worker-service",
                  "threads-collection"
                ]
              }
            ]
          }
        },
        {
          "id": "slack-integration-and-security",
          "name": "Slack integration and security",
          "description": "How Slack events and tasks relate to channels and threads, and how incoming Slack requests are verified for security.",
          "conceptIds": [
            "slack-user",
            "slack-channel",
            "slack-thread",
            "slack-event-envelope",
            "event-envelope",
            "task-payload",
            "test-execution-task-payload",
            "prompt-template",
            "outgoing-slack-message-debug-event",
            "bot-message",
            "debug-event",
            "slack-reaction",
            "slack-security-verification",
            "slack-request-signature",
            "slack-request-timestamp",
            "slack-raw-request-body",
            "slack-signing-secret",
            "slack-request-replay-attack",
            "slack-request-tampering",
            "trusted-slack-request"
          ],
          "relationshipIds": [
            "rel-slack-user-sends-event-envelope",
            "rel-slack-user-triggers-task-payload",
            "rel-slack-user-participates-in-channel",
            "rel-slack-user-initiates-test-execution",
            "rel-slack-user-creates-prompt-template",
            "rel-slack-user-receives-bot-messages",
            "rel-slack-channel-has-events",
            "rel-slack-event-occurs-in-channel",
            "rel-slack-channel-has-tasks",
            "rel-task-refers-to-channel",
            "rel-slack-channel-has-threads",
            "rel-slack-thread-lives-in-channel",
            "rel-slack-thread-channel",
            "rel-slack-channel-receives-bot-messages",
            "rel-bot-message-posted-in-channel",
            "rel-slack-channel-has-debug-events",
            "rel-debug-event-refers-to-channel",
            "rel-slack-channel-enables-bot-reactions",
            "rel-slack-reaction-occurs-in-channel",
            "rel-slack-thread-used-by-task-payload",
            "rel-slack-thread-used-by-event-envelope",
            "rel-slack-thread-has-debug-events",
            "rel-slack-message-recorded-as-debug-event",
            "rel-slack-verification-uses-signature",
            "rel-slack-verification-uses-timestamp",
            "rel-slack-verification-uses-raw-body",
            "rel-slack-verification-uses-signing-secret",
            "rel-slack-verification-prevents-replay",
            "rel-slack-verification-prevents-tampering",
            "rel-slack-verification-enables-trust"
          ],
          "layout": {
            "groups": [
              {
                "id": "slack-surface-zone",
                "title": "Slack surface",
                "x": 60,
                "y": 60,
                "width": 360,
                "height": 520,
                "conceptIds": [
                  "slack-user",
                  "slack-channel",
                  "slack-thread",
                  "slack-reaction",
                  "bot-message"
                ]
              },
              {
                "id": "integration-zone",
                "title": "Events, tasks, and debug",
                "x": 460,
                "y": 60,
                "width": 360,
                "height": 320,
                "conceptIds": [
                  "slack-event-envelope",
                  "event-envelope",
                  "task-payload",
                  "test-execution-task-payload",
                  "prompt-template",
                  "outgoing-slack-message-debug-event",
                  "debug-event"
                ]
              },
              {
                "id": "security-zone",
                "title": "Slack security verification",
                "x": 460,
                "y": 400,
                "width": 360,
                "height": 220,
                "conceptIds": [
                  "slack-security-verification",
                  "slack-request-signature",
                  "slack-request-timestamp",
                  "slack-raw-request-body",
                  "slack-signing-secret",
                  "slack-request-replay-attack",
                  "slack-request-tampering",
                  "trusted-slack-request"
                ]
              }
            ]
          }
        }
      ]
    }
  ]
}