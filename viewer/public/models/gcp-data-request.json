{
  "repoRoot": "/Users/rs/repos/gcp-data-request",
  "generatedAt": "2025-11-26T20:22:18.198Z",
  "projectOverview": {
    "summary": "This project implements a system for managing, executing, and evaluating data requests and test templates using generative AI models. It integrates with Slack for communication and uses Firestore as a backend, providing a web interface for users to create, manage, and review data requests and test executions.",
    "systemContext": {
      "externalSystems": [
        {
          "name": "Slack",
          "description": "Used for notifications, interactions, and thread messaging related to data requests and test results",
          "direction": "bidirectional"
        },
        {
          "name": "Google Cloud Firestore",
          "description": "Primary database for storing data requests, templates, test cases, and execution results",
          "direction": "bidirectional"
        },
        {
          "name": "Google Cloud Functions",
          "description": "Serverless backend functions for executing tests, managing batches, and processing requests",
          "direction": "inbound"
        },
        {
          "name": "Google Cloud Tasks",
          "description": "Queue system for managing asynchronous test execution and batch processing",
          "direction": "inbound"
        },
        {
          "name": "Generative AI Models (Vertex AI or similar)",
          "description": "Used to execute prompts and generate responses for data requests and test evaluations",
          "direction": "outbound"
        }
      ],
      "userRoles": [
        {
          "name": "End User",
          "description": "Users who create and manage data requests and templates via the web UI"
        },
        {
          "name": "Admin/Template Manager",
          "description": "Users responsible for managing templates, test cases, and overseeing test executions"
        },
        {
          "name": "System Worker",
          "description": "Background processes and workers that execute tests, process batches, and interact with external APIs"
        }
      ],
      "keyDependencies": [
        "React",
        "TypeScript",
        "Firebase (Firestore, Auth, Functions)",
        "Google Cloud Platform (Cloud Functions, Cloud Tasks, Vertex AI)",
        "Slack API",
        "CodeMirror",
        "EJS templating"
      ]
    },
    "containers": {
      "services": [
        "Cloud Functions backend (apps/evals-functions)",
        "Worker service for test execution and LLM jobs (apps/worker)"
      ],
      "userInterfaces": [
        "React web application for evaluations and data request management (apps/evals)"
      ],
      "dataStores": [
        "Firestore database",
        "Slack API for messaging and reactions",
        "Generative AI model APIs (Vertex AI or similar)"
      ],
      "backgroundJobs": [
        "Test execution jobs",
        "LLM prompt execution jobs",
        "Batch processing and cancellation jobs",
        "Slack event ingestion and processing (apps/ingest)"
      ],
      "deploymentTargets": [
        "Google Cloud Platform (Cloud Functions, Cloud Tasks, Firestore)",
        "Vercel or similar for React frontend (inferred)",
        "Local development environments"
      ]
    },
    "modules": {
      "boundaries": [
        "apps/evals - React frontend application for UI components, pages, and hooks",
        "apps/evals-functions - Cloud Functions backend handling test execution, template rendering, and LLM interactions",
        "apps/ingest - Slack event ingestion and processing adapters",
        "apps/worker - Background worker service for executing LLM jobs and test executions",
        "packages/shared-runtime - Shared runtime utilities, types, and logic for checks, templates, and LLM",
        "packages/shared-types - Shared TypeScript types and error handling utilities",
        "tests/helpers - Test mocks and helpers"
      ],
      "responsibilities": [
        "apps/evals: Provide user interface for managing data requests, templates, test cases, and viewing results",
        "apps/evals-functions: Implement serverless functions to execute tests, manage batches, render templates, and interact with AI models",
        "apps/ingest: Handle Slack event ingestion, verification, and enqueue work for processing",
        "apps/worker: Run background jobs for LLM prompt execution, test execution, and Slack messaging",
        "packages/shared-runtime: Define shared domain logic, types, and utilities for checks, templates, LLM requests/responses, and debugging",
        "packages/shared-types: Define shared TypeScript types, error handling, and logging utilities",
        "tests/helpers: Provide mocks and utilities for testing worker and other modules"
      ],
      "domainFocus": "The system focuses on managing data requests and test templates that leverage generative AI models to evaluate and automate data workflows, integrated tightly with Slack for communication and Google Cloud for backend infrastructure."
    }
  },
  "concepts": [
    {
      "metadata": {
        "name": "DataRequest",
        "type": "Aggregate Root",
        "criticality": "Core",
        "boundedContext": "Data Request Management",
        "aggregateRoot": true
      },
      "definition": {
        "shortDescription": "Represents a user-initiated request for data that is managed, executed, and evaluated within the system, often involving generative AI models and Slack communication.",
        "ubiquitousLanguage": "DataRequest refers specifically to a request initiated by an end user for data retrieval or clarification, processed through AI-assisted workflows and Slack integration. Synonyms like 'thread' or 'request' may be used informally but DataRequest is the formal domain term. It excludes internal system messages or non-data-related Slack threads."
      },
      "structure": {
        "fields": [
          {
            "name": "id",
            "type": "string",
            "description": "Unique identifier for the DataRequest, typically the Firestore document ID or Slack thread ID."
          },
          {
            "name": "status",
            "type": "string",
            "description": "Current processing state of the DataRequest, e.g., 'processing', 'accepted', 'rejected', 'unhandled'."
          },
          {
            "name": "channel",
            "type": "string",
            "description": "Slack channel identifier where the request originated."
          },
          {
            "name": "createdAt",
            "type": "string",
            "description": "Timestamp when the DataRequest was created."
          },
          {
            "name": "updatedAt",
            "type": "string",
            "description": "Timestamp of the last update to the DataRequest."
          },
          {
            "name": "requester",
            "type": "string",
            "description": "User ID or handle of the person who initiated the request."
          },
          {
            "name": "requesterName",
            "type": "string",
            "description": "Display name of the requester."
          },
          {
            "name": "requesterHandle",
            "type": "string",
            "description": "Slack handle of the requester."
          },
          {
            "name": "rootMessage",
            "type": "string",
            "description": "The initial message text that started the data request thread."
          },
          {
            "name": "rejectionReason",
            "type": "string",
            "description": "Reason provided if the request was rejected."
          },
          {
            "name": "confidence",
            "type": "number",
            "description": "Confidence score from AI classification indicating likelihood this is a valid data request."
          },
          {
            "name": "artifacts",
            "type": "object",
            "description": "AI-generated artifacts related to the request, including 'request' (refined data request), 'clarifyingQuestions', and 'stepByStepInstructions'."
          },
          {
            "name": "lastEventTs",
            "type": "string",
            "description": "Timestamp of the last event or message in the request thread."
          },
          {
            "name": "reacted",
            "type": "boolean",
            "description": "Indicates if the system or users have reacted to the request in Slack."
          },
          {
            "name": "greeted",
            "type": "boolean",
            "description": "Indicates if the system has greeted or acknowledged the request."
          }
        ],
        "relationships": [
          {
            "description": "Belongs to a Slack channel where the request was initiated."
          },
          {
            "description": "Associated with a requester user who initiated the request."
          },
          {
            "description": "Contains AI-generated artifacts produced by generative AI models during evaluation and iteration."
          },
          {
            "description": "Interacts with Slack API for messaging, reactions, and thread management."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "unhandled",
          "processing",
          "accepted",
          "rejected"
        ],
        "validTransitions": [
          "unhandled → processing",
          "processing → accepted",
          "processing → rejected",
          "unhandled → rejected"
        ]
      },
      "invariants": [
        {
          "rule": "A DataRequest must have a unique identifier."
        },
        {
          "rule": "Status must be one of the defined lifecycle states."
        },
        {
          "rule": "Confidence score must be between 0 and 1 if present."
        },
        {
          "rule": "Rejected requests must have a rejectionReason."
        },
        {
          "rule": "Artifacts must be consistent with the current status and AI evaluation results."
        }
      ],
      "commands": [
        {
          "name": "CreateDataRequest",
          "description": "Initiate a new data request from a Slack thread or user input."
        },
        {
          "name": "ClassifyDataRequest",
          "description": "Use AI to determine if a Slack thread or message qualifies as a data request."
        },
        {
          "name": "IterateDataRequest",
          "description": "Update the data request artifacts based on new user input or AI refinement."
        },
        {
          "name": "ReviewDataRequest",
          "description": "Evaluate and produce a clear, unambiguous data request with clarifying questions or instructions."
        },
        {
          "name": "AcceptDataRequest",
          "description": "Mark the request as accepted for execution or further processing."
        },
        {
          "name": "RejectDataRequest",
          "description": "Mark the request as rejected with a reason."
        },
        {
          "name": "ReactToDataRequest",
          "description": "Add Slack reactions or acknowledgments to the request thread."
        }
      ],
      "events": [
        {
          "name": "DataRequestCreated",
          "description": "Emitted when a new data request is created."
        },
        {
          "name": "DataRequestClassified",
          "description": "Emitted after AI classification determines if the thread is a data request."
        },
        {
          "name": "DataRequestIterated",
          "description": "Emitted when the data request artifacts are updated."
        },
        {
          "name": "DataRequestReviewed",
          "description": "Emitted after a review produces clarifying questions or instructions."
        },
        {
          "name": "DataRequestAccepted",
          "description": "Emitted when a request is accepted."
        },
        {
          "name": "DataRequestRejected",
          "description": "Emitted when a request is rejected."
        },
        {
          "name": "DataRequestReacted",
          "description": "Emitted when a reaction or acknowledgment is added in Slack."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "React UI DataRequestsList component",
          "path": "apps/evals/src/pages/DataRequestsList.tsx"
        },
        {
          "kind": "file",
          "label": "React UI DataRequestDetail component",
          "path": "apps/evals/src/pages/DataRequestDetail.tsx"
        },
        {
          "kind": "file",
          "label": "React UI DataRequestDetail subcomponent",
          "path": "apps/evals/src/components/DataRequestDetail.tsx"
        },
        {
          "kind": "file",
          "label": "Worker LLM classification logic for DataRequest",
          "path": "apps/worker/src/llm/is_data_request.ts"
        },
        {
          "kind": "file",
          "label": "Worker LLM iteration logic for DataRequest",
          "path": "apps/worker/src/llm/iterate_data_request.ts"
        },
        {
          "kind": "file",
          "label": "Worker LLM review logic for DataRequest",
          "path": "apps/worker/src/llm/review_data_request.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "TestTemplate",
        "type": "Aggregate Root",
        "criticality": "Core",
        "boundedContext": "Test Template Management",
        "aggregateRoot": true
      },
      "definition": {
        "shortDescription": "Defines reusable, versioned templates for tests and checks that evaluate data requests or workflows, including execution logic and metadata.",
        "ubiquitousLanguage": "TestTemplate refers specifically to the domain concept of a reusable test/check template with versioning and activation states. Synonyms like 'PromptTemplate' or 'TemplateVersion' refer to specific versions or instances but not the aggregate root itself."
      },
      "structure": {
        "fields": [
          {
            "name": "id",
            "type": "string",
            "description": "Unique identifier of the TestTemplate aggregate."
          },
          {
            "name": "name",
            "type": "string",
            "description": "Human-readable name of the template."
          },
          {
            "name": "description",
            "type": "string",
            "description": "Optional detailed description of the template's purpose."
          },
          {
            "name": "tags",
            "type": "string[]",
            "description": "Optional list of tags for categorization and search."
          },
          {
            "name": "activeVersion",
            "type": "number",
            "description": "The version number of the currently active template version."
          },
          {
            "name": "updatedAt",
            "type": "string",
            "description": "Timestamp of the last update to the template aggregate."
          },
          {
            "name": "model",
            "type": "string",
            "description": "Optional AI model identifier associated with the template (e.g., 'gemini-2.5-flash')."
          }
        ],
        "relationships": [
          {
            "description": "Has many TemplateVersions representing historical and current versions of the template."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "draft",
          "saved",
          "active",
          "archived"
        ],
        "validTransitions": [
          "draft → saved",
          "saved → active",
          "active → archived",
          "archived → draft"
        ]
      },
      "invariants": [
        {
          "rule": "Only one TemplateVersion per TestTemplate can be active at a time.",
          "notes": "Activation requires explicit action; saving a new version does not auto-activate."
        },
        {
          "rule": "ActiveVersion must reference an existing TemplateVersion.",
          "notes": "Ensures consistency between aggregate root and version data."
        },
        {
          "rule": "TemplateVersion version numbers must increment sequentially.",
          "notes": "Prevents version conflicts and maintains history integrity."
        }
      ],
      "commands": [
        {
          "name": "CreateTemplate",
          "description": "Create a new TestTemplate aggregate with initial metadata."
        },
        {
          "name": "SaveTemplateVersion",
          "description": "Create and save a new TemplateVersion under the TestTemplate without activating it."
        },
        {
          "name": "ActivateTemplateVersion",
          "description": "Set a specific TemplateVersion as the active version for the TestTemplate."
        },
        {
          "name": "ArchiveTemplate",
          "description": "Mark the TestTemplate as archived, disabling further use."
        },
        {
          "name": "UpdateTemplateMetadata",
          "description": "Modify name, description, tags, or associated model of the TestTemplate."
        }
      ],
      "events": [
        {
          "name": "TemplateCreated",
          "description": "Emitted when a new TestTemplate aggregate is created."
        },
        {
          "name": "TemplateVersionSaved",
          "description": "Emitted when a new TemplateVersion is saved under a TestTemplate."
        },
        {
          "name": "TemplateVersionActivated",
          "description": "Emitted when a TemplateVersion is marked as active."
        },
        {
          "name": "TemplateArchived",
          "description": "Emitted when a TestTemplate is archived."
        },
        {
          "name": "TemplateMetadataUpdated",
          "description": "Emitted when metadata fields of the TestTemplate are updated."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "Template fetching and caching logic",
          "path": "apps/worker/src/templates.ts"
        },
        {
          "kind": "file",
          "label": "Template editor UI components",
          "path": "apps/evals/src/components/template/TemplateEditorTab.tsx"
        },
        {
          "kind": "file",
          "label": "Template version sidebar UI",
          "path": "apps/evals/src/components/template/TemplateVersionSidebar.tsx"
        },
        {
          "kind": "file",
          "label": "Template management page with Firestore integration",
          "path": "apps/evals/src/pages/TemplateManager.tsx"
        },
        {
          "kind": "symbol",
          "label": "PromptTemplate Type Definition",
          "path": "packages/shared-runtime/src/types.ts (PromptTemplate)"
        }
      ]
    },
    {
      "metadata": {
        "name": "TestExecution",
        "type": "domain_service",
        "criticality": "core",
        "boundedContext": "Test Execution and Evaluation",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Handles the orchestration, execution, result collection, and cancellation of tests and test batches against data requests or templates.",
        "ubiquitousLanguage": "TestExecution refers specifically to the process and service responsible for running individual tests or batches of tests, collecting their results, and managing their lifecycle. Synonyms like 'Test Runner' or 'Test Orchestrator' may be used internally but 'TestExecution' is the preferred term. It excludes test definition or template management."
      },
      "structure": {
        "fields": [
          {
            "name": "batchId",
            "type": "string",
            "description": "Identifier for a batch of tests executed together."
          },
          {
            "name": "testCaseId",
            "type": "string",
            "description": "Identifier for the individual test case to execute."
          },
          {
            "name": "templateId",
            "type": "string",
            "description": "Identifier for the prompt template used in the test."
          },
          {
            "name": "userId",
            "type": "string",
            "description": "Identifier of the user who initiated the test execution."
          },
          {
            "name": "inputVariables",
            "type": "Record<string, any>",
            "description": "Input variables used to render the test template."
          },
          {
            "name": "testRunResultId",
            "type": "string",
            "description": "Unique identifier for the test run result."
          },
          {
            "name": "overallStatus",
            "type": "'pass' | 'fail'",
            "description": "Overall outcome status of the test execution."
          },
          {
            "name": "executedAt",
            "type": "string",
            "description": "Timestamp when the test was executed."
          },
          {
            "name": "checkResults",
            "type": "any[]",
            "description": "Optional detailed results of individual checks performed during test execution."
          }
        ],
        "relationships": [
          {
            "description": "TestExecution operates on TestCases which belong to PromptTemplates."
          },
          {
            "description": "TestExecution results are stored and associated with TestBatches."
          },
          {
            "description": "TestExecution interacts with Generative AI Models to execute prompts."
          },
          {
            "description": "TestExecution is initiated by Users and may be cancelled or managed by System Workers."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "pending",
          "in_progress",
          "completed",
          "cancelled",
          "failed"
        ],
        "validTransitions": [
          "pending → in_progress",
          "in_progress → completed",
          "in_progress → failed",
          "pending → cancelled",
          "in_progress → cancelled"
        ]
      },
      "invariants": [
        {
          "rule": "A test execution must be associated with a valid active template and test case.",
          "notes": "Execution cannot proceed if template or test case is missing or inactive."
        },
        {
          "rule": "Cancelled test batches must not execute any further test cases.",
          "notes": "Prevents wasted compute and inconsistent results."
        },
        {
          "rule": "Test execution results must include an overall status of either 'pass' or 'fail'."
        },
        {
          "rule": "Only authenticated users can initiate test executions."
        }
      ],
      "commands": [
        {
          "name": "ExecuteTest",
          "description": "Initiate execution of a single test case against a template with given input variables."
        },
        {
          "name": "ExecuteTestBatch",
          "description": "Orchestrate execution of multiple test cases as a batch."
        },
        {
          "name": "CancelTestBatch",
          "description": "Cancel an ongoing test batch to stop further executions."
        }
      ],
      "events": [
        {
          "name": "TestExecutionStarted",
          "description": "Emitted when a test execution begins."
        },
        {
          "name": "TestExecutionCompleted",
          "description": "Emitted when a test execution finishes with results."
        },
        {
          "name": "TestBatchCancelled",
          "description": "Emitted when a test batch is cancelled."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "Shared runtime test execution logic",
          "path": "packages/shared-runtime/src/test-execution.ts"
        },
        {
          "kind": "file",
          "label": "Worker job processing test executions",
          "path": "apps/worker/src/jobs/test-execution.ts"
        },
        {
          "kind": "file",
          "label": "Cloud Functions backend for test execution API",
          "path": "apps/evals-functions/src/index.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "GenerativeAIModel",
        "type": "Domain Service",
        "criticality": "Core",
        "boundedContext": "Generative AI Integration",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "An abstraction and integration layer for generative AI models used to generate responses, evaluate data requests, and execute prompts.",
        "ubiquitousLanguage": "Also referred to as 'LLM Model' or 'Generative Model'. Excludes non-generative AI services or models not used for prompt-based generation."
      },
      "structure": {
        "fields": [
          {
            "name": "modelName",
            "type": "string",
            "description": "The identifier of the generative AI model to use, e.g., 'gemini-3-pro-preview'."
          },
          {
            "name": "projectId",
            "type": "string",
            "description": "Google Cloud project identifier used to instantiate the Vertex AI client."
          },
          {
            "name": "location",
            "type": "string",
            "description": "Geographic location or region for the model endpoint, e.g., 'global' or a configured region."
          },
          {
            "name": "modelCache",
            "type": "Record<string, ModelInstance>",
            "description": "In-memory cache of instantiated generative model clients keyed by model name to optimize reuse."
          }
        ],
        "relationships": [
          {
            "description": "Uses Google Cloud Vertex AI service to instantiate and interact with generative AI models."
          },
          {
            "description": "Interacts with domain components that issue prompts and consume generated responses, such as test execution workers and evaluation functions."
          },
          {
            "description": "Integrates with debugging and telemetry subsystems to record LLM request events."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "uninitialized",
          "model instantiated",
          "model cached",
          "prompt executed",
          "response received",
          "error"
        ],
        "validTransitions": [
          "uninitialized → model instantiated",
          "model instantiated → model cached",
          "model cached → prompt executed",
          "prompt executed → response received",
          "any → error"
        ]
      },
      "invariants": [
        {
          "rule": "Model instances must be cached per modelName to avoid redundant client creation.",
          "notes": "Ensures efficient resource usage and consistent model interaction."
        },
        {
          "rule": "Model location must be correctly determined based on modelName (e.g., Gemini 3 models use 'global').",
          "notes": "Prevents misrouting requests to unsupported regions."
        },
        {
          "rule": "All prompt executions must record debug events if debug context is provided.",
          "notes": "Supports observability and troubleshooting."
        }
      ],
      "commands": [
        {
          "name": "getGenerativeModel",
          "description": "Retrieve or instantiate a cached generative AI model client by model name."
        },
        {
          "name": "executePrompt",
          "description": "Send a prompt to the generative AI model and receive generated content."
        }
      ],
      "events": [
        {
          "name": "LLMRequestRecorded",
          "description": "Emitted when a prompt request is logged for debugging and telemetry."
        },
        {
          "name": "PromptExecutionSucceeded",
          "description": "Emitted when a prompt is successfully executed and a response is received."
        },
        {
          "name": "PromptExecutionFailed",
          "description": "Emitted when an error occurs during prompt execution."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "Vertex AI model integration (evals-functions)",
          "path": "apps/evals-functions/src/vertex.ts"
        },
        {
          "kind": "file",
          "label": "Vertex AI model integration (worker service)",
          "path": "apps/worker/src/llm/vertex.ts"
        },
        {
          "kind": "file",
          "label": "LLM prompt execution and debug recording",
          "path": "packages/shared-runtime/src/llm.ts"
        },
        {
          "kind": "file",
          "label": "LLM prompt execution with Firestore debug context",
          "path": "apps/evals-functions/src/shared.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "SlackIntegration",
        "type": "Domain Service",
        "criticality": "Supporting",
        "boundedContext": "Communication and Collaboration",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Handles communication with Slack including posting messages, adding/removing reactions, fetching thread messages, and verifying Slack events.",
        "ubiquitousLanguage": "SlackIntegration refers specifically to the domain service responsible for all interactions with Slack's API such as messaging, reactions, and event verification. Synonyms like SlackClient or SlackAPIWrapper are not used to avoid confusion with lower-level API clients."
      },
      "structure": {
        "fields": [
          {
            "name": "botToken",
            "type": "string",
            "description": "Authentication token used to authorize Slack API calls."
          },
          {
            "name": "signingSecret",
            "type": "string",
            "description": "Secret used to verify incoming Slack event signatures."
          }
        ],
        "relationships": [
          {
            "description": "Interacts with Slack external system via Slack Web API."
          },
          {
            "description": "Used by system components such as Worker service and Ingest adapters to send and verify Slack messages and events."
          }
        ]
      },
      "lifecycle": {
        "states": [],
        "validTransitions": []
      },
      "invariants": [
        {
          "rule": "Slack event signatures must be verified using HMAC SHA256 with the signing secret before processing events.",
          "notes": "Prevents unauthorized or replayed Slack events."
        },
        {
          "rule": "Slack API calls must include a valid bot token and handle errors gracefully, including ignoring 'already_reacted' errors on reactions."
        }
      ],
      "commands": [
        {
          "name": "postThreadMessage",
          "description": "Posts a text message to a Slack thread."
        },
        {
          "name": "postThreadBlocks",
          "description": "Posts a block-structured message to a Slack thread."
        },
        {
          "name": "addRobotReaction",
          "description": "Adds a robot_face reaction emoji to a Slack message."
        },
        {
          "name": "verifySlackSignature",
          "description": "Verifies the authenticity of incoming Slack event requests."
        }
      ],
      "events": [
        {
          "name": "OutgoingSlackMessageRecorded",
          "description": "Emitted when a Slack message is successfully posted and a debug event is recorded."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "Slack API client and reaction/posting functions (worker)",
          "path": "apps/worker/src/slack/api.ts"
        },
        {
          "kind": "file",
          "label": "Slack event signature verification utility",
          "path": "apps/ingest/src/slack/verify.ts"
        },
        {
          "kind": "file",
          "label": "Slack API placeholders for reaction and greeting (ingest)",
          "path": "apps/ingest/src/slack/api.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "Check",
        "type": "Value Object",
        "criticality": "Core",
        "boundedContext": "Test Execution and Evaluation",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Represents a single test check or assertion within a test template, including its execution result and evaluation logic.",
        "ubiquitousLanguage": "A 'Check' is a defined assertion or validation criterion applied to test outputs to determine pass/fail status. Synonyms like 'Test Check' or 'Assertion' may be used internally, but 'Check' is the preferred term. It excludes the entire test template or test run, focusing on individual assertions."
      },
      "structure": {
        "fields": [
          {
            "name": "id",
            "type": "string",
            "description": "Unique identifier of the check"
          },
          {
            "name": "name",
            "type": "string",
            "description": "Human-readable name of the check"
          },
          {
            "name": "criteria",
            "type": "string",
            "description": "The assertion or validation logic expressed as criteria text"
          },
          {
            "name": "model",
            "type": "string",
            "description": "Identifier of the generative AI model used to evaluate this check"
          },
          {
            "name": "createdBy",
            "type": "string",
            "description": "User identifier who created the check"
          },
          {
            "name": "createdAt",
            "type": "string (ISO timestamp)",
            "description": "Timestamp when the check was created"
          },
          {
            "name": "updatedAt",
            "type": "string (ISO timestamp)",
            "description": "Timestamp when the check was last updated"
          }
        ],
        "relationships": [
          {
            "description": "Belongs to a Test Template which groups multiple Checks"
          },
          {
            "description": "Referenced by Test Runs and Test Executions to evaluate outputs"
          }
        ]
      },
      "lifecycle": {
        "states": [
          "defined",
          "active",
          "archived"
        ],
        "validTransitions": [
          "defined → active",
          "active → archived",
          "archived → active"
        ]
      },
      "invariants": [
        {
          "rule": "Check must have a non-empty name",
          "notes": "Ensures meaningful identification in UI and logs"
        },
        {
          "rule": "Check criteria must be a non-empty string",
          "notes": "Defines the assertion logic to be evaluated"
        },
        {
          "rule": "Model must be one of the supported generative AI models",
          "notes": "Ensures compatibility with evaluation execution"
        }
      ],
      "commands": [
        {
          "name": "CreateCheck",
          "description": "Create a new Check with specified name, criteria, and model"
        },
        {
          "name": "UpdateCheck",
          "description": "Modify properties of an existing Check"
        },
        {
          "name": "DeleteCheck",
          "description": "Remove a Check from the system"
        }
      ],
      "events": [
        {
          "name": "CheckCreated",
          "description": "Emitted when a new Check is created"
        },
        {
          "name": "CheckUpdated",
          "description": "Emitted when an existing Check is updated"
        },
        {
          "name": "CheckDeleted",
          "description": "Emitted when a Check is deleted"
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "Check React UI Component",
          "path": "apps/evals/src/components/template/components/CheckItem.tsx"
        },
        {
          "kind": "file",
          "label": "Check Form React Component",
          "path": "apps/evals/src/components/template/components/CheckForm.tsx"
        },
        {
          "kind": "file",
          "label": "Check Hooks for CRUD operations",
          "path": "apps/evals/src/components/template/hooks/useChecks.ts"
        },
        {
          "kind": "file",
          "label": "Check Execution Logic",
          "path": "packages/shared-runtime/src/checks.ts"
        },
        {
          "kind": "symbol",
          "label": "Check Type Definition",
          "path": "packages/shared-types"
        }
      ]
    },
    {
      "metadata": {
        "name": "TestBatch",
        "type": "Aggregate Root",
        "criticality": "Core",
        "boundedContext": "Test Execution and Evaluation",
        "aggregateRoot": true
      },
      "definition": {
        "shortDescription": "Represents a batch of test executions grouped together for processing, tracking progress, results, and cancellation.",
        "ubiquitousLanguage": "TestBatch refers specifically to a collection of test executions initiated together, managed as a single unit for execution and result aggregation. Synonyms like 'batch job' or 'test run batch' may be used internally but 'TestBatch' is the canonical term."
      },
      "structure": {
        "fields": [
          {
            "name": "id",
            "type": "string",
            "description": "Unique identifier for the TestBatch"
          },
          {
            "name": "status",
            "type": "string",
            "description": "Current lifecycle state of the batch (e.g., running, completed, cancelled, failed)"
          },
          {
            "name": "totalTestCases",
            "type": "number",
            "description": "Total number of test cases included in the batch"
          },
          {
            "name": "completedCount",
            "type": "number",
            "description": "Number of test cases completed so far"
          },
          {
            "name": "initiatedAt",
            "type": "string",
            "description": "ISO timestamp when the batch was created"
          },
          {
            "name": "cancelledAt",
            "type": "string",
            "description": "ISO timestamp when the batch was cancelled, if applicable"
          },
          {
            "name": "results",
            "type": "TestBatchResult[]",
            "description": "Collection of results for individual test executions within the batch"
          },
          {
            "name": "userId",
            "type": "string",
            "description": "Identifier of the user who initiated the batch"
          }
        ],
        "relationships": [
          {
            "description": "Contains many TestExecutions or TestCases that are executed as part of the batch"
          },
          {
            "description": "Associated with a User who initiates and manages the batch"
          },
          {
            "description": "Related to PromptTemplates used for test execution"
          }
        ]
      },
      "lifecycle": {
        "states": [
          "running",
          "completed",
          "cancelled",
          "failed"
        ],
        "validTransitions": [
          "running → completed",
          "running → cancelled",
          "running → failed"
        ]
      },
      "invariants": [
        {
          "rule": "completedCount must never exceed totalTestCases",
          "notes": "Ensures progress tracking is accurate"
        },
        {
          "rule": "A batch cannot transition from completed or cancelled back to running",
          "notes": "Prevents restarting finished or cancelled batches"
        },
        {
          "rule": "Cancelled batches must have a cancelledAt timestamp",
          "notes": "Tracks when cancellation occurred"
        }
      ],
      "commands": [
        {
          "name": "CreateTestBatch",
          "description": "Initialize a new TestBatch with a set of test cases and user context"
        },
        {
          "name": "CancelTestBatch",
          "description": "Request cancellation of a running TestBatch"
        },
        {
          "name": "UpdateTestBatchProgress",
          "description": "Update the completedCount and status as test executions complete"
        },
        {
          "name": "CompleteTestBatch",
          "description": "Mark the batch as completed when all test cases finish"
        }
      ],
      "events": [
        {
          "name": "TestBatchCreated",
          "description": "Emitted when a new TestBatch is created"
        },
        {
          "name": "TestBatchCancelled",
          "description": "Emitted when a TestBatch is cancelled"
        },
        {
          "name": "TestBatchProgressUpdated",
          "description": "Emitted when progress (completedCount) changes"
        },
        {
          "name": "TestBatchCompleted",
          "description": "Emitted when the batch completes all test executions"
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "TestBatch type definitions and shared types",
          "path": "packages/shared-types/src/types.ts"
        },
        {
          "kind": "file",
          "label": "Batch progress UI component",
          "path": "apps/evals/src/components/template/components/BatchProgressIndicator.tsx"
        },
        {
          "kind": "file",
          "label": "Batch detail modal UI component",
          "path": "apps/evals/src/components/template/components/BatchDetailModal.tsx"
        },
        {
          "kind": "file",
          "label": "Cloud Function handling test execution and batch creation",
          "path": "apps/evals-functions/src/index.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "DebugEvent",
        "type": "Value Object",
        "criticality": "Supporting",
        "boundedContext": "Test Execution and Evaluation",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Represents debug information and events recorded during test execution or AI prompt processing for diagnostics and traceability.",
        "ubiquitousLanguage": "DebugEvent refers specifically to structured diagnostic events such as errors, LLM requests, classification results, and reaction timings captured to aid troubleshooting and traceability. It excludes raw logs or unrelated telemetry."
      },
      "structure": {
        "fields": [
          {
            "name": "type",
            "type": "string",
            "description": "The category or kind of debug event, e.g., 'error_occurred', 'llm_request', 'time_to_react', 'llm_classification'."
          },
          {
            "name": "timestamp",
            "type": "string (ISO 8601 datetime)",
            "description": "The exact time when the debug event was recorded."
          },
          {
            "name": "data",
            "type": "object",
            "description": "Event-specific payload containing detailed debug information relevant to the event type."
          }
        ],
        "relationships": [
          {
            "description": "Associated with a root test execution or AI prompt processing context identified by a root timestamp (rootTs)."
          },
          {
            "description": "Stored as subdocuments under a 'debugEvents' collection within a 'threads' document in Firestore."
          }
        ]
      },
      "lifecycle": {
        "states": [],
        "validTransitions": []
      },
      "invariants": [
        {
          "rule": "Each DebugEvent must have a valid ISO 8601 timestamp.",
          "notes": "Ensures temporal ordering and traceability."
        },
        {
          "rule": "The 'type' field must be one of the predefined event types supported by the system.",
          "notes": "Prevents invalid or unknown debug event categories."
        },
        {
          "rule": "DebugEvent instances are immutable once created.",
          "notes": "Preserves integrity of diagnostic data."
        }
      ],
      "commands": [],
      "events": [],
      "implementation": [
        {
          "kind": "file",
          "label": "DebugEvent Type Definitions and Utilities",
          "path": "packages/shared-types/src/types.ts"
        },
        {
          "kind": "file",
          "label": "Debug Event Recording Functions",
          "path": "packages/shared-runtime/src/debug.ts"
        },
        {
          "kind": "file",
          "label": "LLM Prompt Execution with DebugEvent Recording",
          "path": "apps/evals-functions/src/shared.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "TestCase",
        "type": "Entity",
        "criticality": "Core",
        "boundedContext": "Test Template Management",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Represents an individual test case within a test template, including input parameters and expected outcomes for evaluation.",
        "ubiquitousLanguage": "TestCase refers specifically to a defined scenario with inputs and associated checks to validate template behavior. Synonyms like 'test scenario' or 'test instance' may be used informally but 'TestCase' is the canonical term. It excludes test runs or executions, which are separate concepts."
      },
      "structure": {
        "fields": [
          {
            "name": "id",
            "type": "string",
            "description": "Unique identifier for the test case."
          },
          {
            "name": "name",
            "type": "string",
            "description": "Human-readable name of the test case."
          },
          {
            "name": "description",
            "type": "string | undefined",
            "description": "Optional detailed description of the test case purpose."
          },
          {
            "name": "inputVariables",
            "type": "Record<string, unknown>",
            "description": "Key-value pairs representing input parameters for the test case."
          },
          {
            "name": "tags",
            "type": "string[] | undefined",
            "description": "Optional list of tags for categorization or filtering."
          },
          {
            "name": "checkIds",
            "type": "string[]",
            "description": "List of identifiers for checks to run against this test case."
          },
          {
            "name": "createdBy",
            "type": "string",
            "description": "Identifier of the user who created the test case."
          },
          {
            "name": "createdAt",
            "type": "string",
            "description": "Timestamp of when the test case was created."
          },
          {
            "name": "updatedAt",
            "type": "string",
            "description": "Timestamp of the last update to the test case."
          }
        ],
        "relationships": [
          {
            "description": "Belongs to a Test Template (not shown in this snippet but implied by context)."
          },
          {
            "description": "Associated with multiple Checks via checkIds to validate outputs."
          },
          {
            "description": "Executed by Users who create or run test cases."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "draft",
          "active",
          "archived"
        ],
        "validTransitions": [
          "draft → active",
          "active → archived",
          "archived → active"
        ]
      },
      "invariants": [
        {
          "rule": "Each TestCase must have a unique id.",
          "notes": "Ensures identity and traceability."
        },
        {
          "rule": "Input variables must include all required variables defined by the associated template version.",
          "notes": "Prevents incomplete test scenarios."
        },
        {
          "rule": "checkIds must reference existing checks valid for the template.",
          "notes": "Ensures test case can be properly evaluated."
        },
        {
          "rule": "createdAt must be earlier or equal to updatedAt.",
          "notes": "Maintains temporal consistency."
        }
      ],
      "commands": [
        {
          "name": "CreateTestCase",
          "description": "Create a new test case with specified inputs and checks."
        },
        {
          "name": "UpdateTestCase",
          "description": "Modify existing test case details or inputs."
        },
        {
          "name": "DeleteTestCase",
          "description": "Remove a test case from the system."
        },
        {
          "name": "ExecuteTestCase",
          "description": "Trigger execution of the test case against a template."
        }
      ],
      "events": [
        {
          "name": "TestCaseCreated",
          "description": "Emitted when a new test case is created."
        },
        {
          "name": "TestCaseUpdated",
          "description": "Emitted when a test case is modified."
        },
        {
          "name": "TestCaseDeleted",
          "description": "Emitted when a test case is removed."
        },
        {
          "name": "TestCaseExecuted",
          "description": "Emitted when a test case execution is triggered."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "TestCase Type Definition",
          "path": "apps/evals/src/lib/types.ts"
        },
        {
          "kind": "file",
          "label": "TestCasesList UI Component",
          "path": "apps/evals/src/components/template/components/TestCasesList.tsx"
        },
        {
          "kind": "file",
          "label": "TestCaseForm UI Component",
          "path": "apps/evals/src/components/template/components/TestCaseForm.tsx"
        },
        {
          "kind": "file",
          "label": "TestCasesTab UI Container",
          "path": "apps/evals/src/components/template/TestCasesTab.tsx"
        }
      ]
    },
    {
      "metadata": {
        "name": "TestExecutionResult",
        "type": "Value Object",
        "criticality": "Core",
        "boundedContext": "Test Execution and Evaluation",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Encapsulates the outcome of a test execution, including pass/fail status, errors, and detailed check results.",
        "ubiquitousLanguage": "TestExecutionResult refers specifically to the immutable result produced after running a test case against a template using generative AI models. It includes overall status, timing, and detailed check outcomes. Synonyms like TestRunResult or ExecutionOutcome may appear but TestExecutionResult is preferred for clarity."
      },
      "structure": {
        "fields": [
          {
            "name": "text",
            "type": "string",
            "description": "The raw or processed output text generated by the test execution."
          },
          {
            "name": "modelName",
            "type": "string",
            "description": "The name of the generative AI model used for the test execution."
          },
          {
            "name": "testRunResultId",
            "type": "string",
            "description": "Unique identifier for this specific test run result."
          },
          {
            "name": "overallStatus",
            "type": "'pass' | 'fail'",
            "description": "The overall pass or fail status of the test execution."
          },
          {
            "name": "executedAt",
            "type": "string",
            "description": "Timestamp when the test execution was performed."
          },
          {
            "name": "checkResults",
            "type": "CheckResult[] | undefined",
            "description": "Optional detailed results of individual checks run as part of the test execution."
          }
        ],
        "relationships": [
          {
            "description": "Associated with a TestCase by testCaseId (not directly included here but implied)."
          },
          {
            "description": "Related to a Template by templateId and templateVersion (contextual linkage)."
          },
          {
            "description": "Contains multiple CheckResults representing individual validation checks."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "pass",
          "fail",
          "error"
        ],
        "validTransitions": [
          "error → pass",
          "error → fail",
          "pass → fail",
          "fail → pass"
        ]
      },
      "invariants": [
        {
          "rule": "overallStatus must be either 'pass' or 'fail'.",
          "notes": "Error states are handled separately and may not produce a valid TestExecutionResult."
        },
        {
          "rule": "checkResults must be present if overallStatus is 'fail'.",
          "notes": "Check results provide detailed failure reasons."
        },
        {
          "rule": "testRunResultId must be unique per test execution."
        },
        {
          "rule": "executedAt must be a valid timestamp representing when the test was run."
        }
      ],
      "commands": [],
      "events": [],
      "implementation": [
        {
          "kind": "symbol",
          "label": "TestExecutionResult interface",
          "path": "packages/shared-runtime/src/test-execution.ts"
        },
        {
          "kind": "function",
          "label": "executeTest function returning TestExecutionResult",
          "path": "packages/shared-runtime/src/test-execution.ts"
        },
        {
          "kind": "type",
          "label": "CheckResult interface",
          "path": "apps/evals/src/lib/types.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "SlackThread",
        "type": "Entity",
        "criticality": "Supporting",
        "boundedContext": "Communication and Collaboration",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Represents a Slack conversation thread used for communication and coordination around data requests and test executions.",
        "ubiquitousLanguage": "Also referred to as 'thread' or 'Slack conversation thread'; excludes unrelated Slack channels or direct messages outside the context of data request/test execution workflows."
      },
      "structure": {
        "fields": [
          {
            "name": "rootTs",
            "type": "string",
            "description": "The root timestamp identifier of the Slack thread, uniquely identifying the thread."
          },
          {
            "name": "status",
            "type": "string",
            "description": "Current status of the thread, e.g., active, completed, or other workflow states."
          },
          {
            "name": "flags",
            "type": "{ reacted?: boolean; greeted?: boolean }",
            "description": "Per-thread flags indicating Slack interaction states such as whether the thread has been reacted to or greeted."
          },
          {
            "name": "channelId",
            "type": "string",
            "description": "Identifier of the Slack channel where the thread exists."
          },
          {
            "name": "userId",
            "type": "string",
            "description": "Identifier of the user who initiated or is primarily associated with the thread."
          },
          {
            "name": "text",
            "type": "string",
            "description": "Initial or summary text content of the thread."
          }
        ],
        "relationships": [
          {
            "description": "Belongs to a Slack Channel identified by channelId."
          },
          {
            "description": "Associated with one or more Users participating in the thread."
          },
          {
            "description": "Linked to Data Requests and Test Executions as the communication context."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "initialized",
          "active",
          "reacted",
          "greeted",
          "completed",
          "archived"
        ],
        "validTransitions": [
          "initialized → active",
          "active → reacted",
          "active → greeted",
          "reacted → completed",
          "greeted → completed",
          "completed → archived"
        ]
      },
      "invariants": [
        {
          "rule": "Each SlackThread must have a unique rootTs identifier.",
          "notes": "Ensures thread identity and consistency in Firestore."
        },
        {
          "rule": "Flags such as 'reacted' and 'greeted' can only be set once per thread.",
          "notes": "Prevents duplicate Slack reactions or greetings."
        },
        {
          "rule": "SlackThread must be associated with a valid Slack channel and at least one user.",
          "notes": "Ensures meaningful communication context."
        }
      ],
      "commands": [
        {
          "name": "updateThreadStatus",
          "description": "Update the status of the SlackThread, e.g., marking it as active or completed."
        },
        {
          "name": "setFlagsOnce",
          "description": "Set interaction flags such as 'reacted' or 'greeted' on the thread, ensuring idempotency."
        },
        {
          "name": "fetchUserInfo",
          "description": "Retrieve Slack user information related to the thread participants."
        },
        {
          "name": "fetchChannelInfo",
          "description": "Retrieve Slack channel information where the thread resides."
        }
      ],
      "events": [
        {
          "name": "ThreadStatusUpdated",
          "description": "Emitted when the status of a SlackThread changes."
        },
        {
          "name": "ThreadFlagSet",
          "description": "Emitted when a per-thread flag such as 'reacted' or 'greeted' is set."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "Thread status update placeholder",
          "path": "apps/worker/src/adapters/threads.ts"
        },
        {
          "kind": "file",
          "label": "Slack thread flags management and Slack API helpers",
          "path": "apps/ingest/src/adapters/threads.ts"
        },
        {
          "kind": "file",
          "label": "Shared Slack-related types",
          "path": "packages/shared-types/src/types.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "TemplateVersion",
        "type": "Entity",
        "criticality": "Core",
        "boundedContext": "Test Template Management",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Represents a specific version of a TestTemplate, supporting versioning, activation, and management of template iterations.",
        "ubiquitousLanguage": "TemplateVersion refers specifically to one iteration/version of a TestTemplate. It is distinct from the TestTemplate entity itself, which may have multiple TemplateVersions. Synonyms like 'Template Iteration' or 'Template Revision' may be used internally but 'TemplateVersion' is the preferred term."
      },
      "structure": {
        "fields": [
          {
            "name": "version",
            "type": "number",
            "description": "The version number identifying this iteration of the template."
          },
          {
            "name": "template",
            "type": "string",
            "description": "The actual template content or prompt string used for generation."
          },
          {
            "name": "variables",
            "type": "string[]",
            "description": "List of variable names used within the template."
          },
          {
            "name": "isActive",
            "type": "boolean",
            "description": "Indicates if this version is currently active for the parent TestTemplate."
          },
          {
            "name": "createdAt",
            "type": "string (ISO date)",
            "description": "Timestamp when this version was created."
          },
          {
            "name": "createdBy",
            "type": "string",
            "description": "Identifier of the user who created this version."
          },
          {
            "name": "changeNotes",
            "type": "string",
            "description": "Optional notes describing changes or rationale for this version."
          },
          {
            "name": "model",
            "type": "string",
            "description": "The generative AI model associated with this template version (e.g., 'gemini-2.5-flash')."
          },
          {
            "name": "parentVersion",
            "type": "number",
            "description": "Optional reference to the previous version number this version is derived from."
          }
        ],
        "relationships": [
          {
            "description": "Belongs to one TestTemplate which aggregates multiple TemplateVersions."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "draft",
          "active",
          "archived"
        ],
        "validTransitions": [
          "draft → active",
          "active → archived",
          "archived → active"
        ]
      },
      "invariants": [
        {
          "rule": "Only one TemplateVersion per TestTemplate can be active at a time.",
          "notes": "Enforced to ensure consistent template usage."
        },
        {
          "rule": "Version numbers must be strictly increasing within a TestTemplate.",
          "notes": "Prevents version conflicts and maintains history."
        },
        {
          "rule": "CreatedAt timestamp must be set and immutable once created."
        }
      ],
      "commands": [
        {
          "name": "CreateTemplateVersion",
          "description": "Create a new version of a TestTemplate with specified content and metadata."
        },
        {
          "name": "ActivateTemplateVersion",
          "description": "Set a specific TemplateVersion as the active version for its TestTemplate."
        },
        {
          "name": "ArchiveTemplateVersion",
          "description": "Mark a TemplateVersion as archived, making it inactive and hidden from default usage."
        },
        {
          "name": "UpdateChangeNotes",
          "description": "Modify the change notes for a TemplateVersion."
        }
      ],
      "events": [
        {
          "name": "TemplateVersionCreated",
          "description": "Emitted when a new TemplateVersion is created."
        },
        {
          "name": "TemplateVersionActivated",
          "description": "Emitted when a TemplateVersion becomes the active version."
        },
        {
          "name": "TemplateVersionArchived",
          "description": "Emitted when a TemplateVersion is archived."
        },
        {
          "name": "TemplateVersionUpdated",
          "description": "Emitted when metadata such as change notes are updated."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "TemplateVersion data structure and Firestore document",
          "path": "Firestore collection 'promptTemplates/{templateId}/versions/{version}'"
        },
        {
          "kind": "file",
          "label": "Template fetching and caching logic",
          "path": "apps/worker/src/templates.ts"
        },
        {
          "kind": "file",
          "label": "TemplateVersion UI components",
          "path": "apps/evals/src/components/template/TemplateVersionSidebar.tsx"
        },
        {
          "kind": "symbol",
          "label": "PromptTemplate Type including version fields",
          "path": "packages/shared-runtime/src/types.ts (PromptTemplate)"
        }
      ]
    },
    {
      "metadata": {
        "name": "User",
        "type": "Entity",
        "criticality": "Core",
        "boundedContext": "User and Operational Infrastructure",
        "aggregateRoot": true
      },
      "definition": {
        "shortDescription": "Represents a system user including roles such as End User and Admin, with identity and authentication managed via Firebase Auth and Slack user info.",
        "ubiquitousLanguage": "User refers specifically to authenticated individuals interacting with the system, identified by Firebase Auth UID and optionally linked to Slack user identity. Roles include End User and Admin (Template Manager). Excludes service accounts or anonymous sessions."
      },
      "structure": {
        "fields": [
          {
            "name": "id",
            "type": "string",
            "description": "Unique identifier for the user, typically Firebase Auth UID."
          },
          {
            "name": "email",
            "type": "string",
            "description": "User's email address, from Firebase Auth."
          },
          {
            "name": "displayName",
            "type": "string",
            "description": "User's display name, from Firebase Auth or Slack profile."
          },
          {
            "name": "roles",
            "type": "string[]",
            "description": "List of roles assigned to the user, e.g., 'End User', 'Admin'."
          },
          {
            "name": "slackUserId",
            "type": "string",
            "description": "Optional Slack user ID linked to this user."
          },
          {
            "name": "createdAt",
            "type": "string",
            "description": "Timestamp when the user was first registered or created in the system."
          },
          {
            "name": "lastLoginAt",
            "type": "string",
            "description": "Timestamp of the user's last authentication event."
          }
        ],
        "relationships": [
          {
            "description": "A User can create and manage Data Requests and Test Templates."
          },
          {
            "description": "A User may be linked to Slack user identity for communication and notifications."
          },
          {
            "description": "A User may trigger or be associated with Test Executions and LLM job requests."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "registered",
          "active",
          "suspended",
          "deleted"
        ],
        "validTransitions": [
          "registered → active",
          "active → suspended",
          "suspended → active",
          "active → deleted",
          "suspended → deleted"
        ]
      },
      "invariants": [
        {
          "rule": "User must have a unique, non-null identifier (Firebase UID)."
        },
        {
          "rule": "User roles must be from the predefined set (e.g., End User, Admin)."
        },
        {
          "rule": "Email must be unique and valid if present."
        },
        {
          "rule": "Slack user linkage, if present, must correspond to a valid Slack user ID."
        }
      ],
      "commands": [
        {
          "name": "RegisterUser",
          "description": "Create a new user record upon first authentication."
        },
        {
          "name": "AssignRole",
          "description": "Assign or update roles for a user."
        },
        {
          "name": "LinkSlackUser",
          "description": "Associate a Slack user ID with the system user."
        },
        {
          "name": "SuspendUser",
          "description": "Temporarily disable user access."
        },
        {
          "name": "DeleteUser",
          "description": "Remove or deactivate user from the system."
        }
      ],
      "events": [
        {
          "name": "UserRegistered",
          "description": "Emitted when a new user is created."
        },
        {
          "name": "UserRoleUpdated",
          "description": "Emitted when user roles are changed."
        },
        {
          "name": "UserSlackLinked",
          "description": "Emitted when a Slack user ID is linked to the user."
        },
        {
          "name": "UserSuspended",
          "description": "Emitted when a user is suspended."
        },
        {
          "name": "UserDeleted",
          "description": "Emitted when a user is deleted or deactivated."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "Firebase Authentication Initialization",
          "path": "apps/evals/src/firebase.ts"
        },
        {
          "kind": "file",
          "label": "Slack API Integration for User Identity",
          "path": "apps/worker/src/slack/api.ts"
        },
        {
          "kind": "file",
          "label": "Shared TypeScript Types for User and Roles",
          "path": "packages/shared-types/src/types.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "TestExecutionBatchStatus",
        "type": "value_object",
        "criticality": "supporting",
        "boundedContext": "Test Execution and Evaluation",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Represents the status and progress state of a TestBatch execution, including tracking of cancellation and completion.",
        "ubiquitousLanguage": "Also referred to as the execution state of a test batch; excludes individual test case statuses but summarizes overall batch progress."
      },
      "structure": {
        "fields": [
          {
            "name": "isCancelled",
            "type": "boolean",
            "description": "Indicates whether the test batch execution has been cancelled."
          },
          {
            "name": "isCompleted",
            "type": "boolean",
            "description": "Indicates whether the test batch execution has finished all test cases."
          },
          {
            "name": "progress",
            "type": "number",
            "description": "Represents the percentage or fraction of test cases completed within the batch."
          },
          {
            "name": "startedAt",
            "type": "string (ISO timestamp)",
            "description": "Timestamp when the batch execution started."
          },
          {
            "name": "completedAt",
            "type": "string (ISO timestamp) | null",
            "description": "Timestamp when the batch execution completed, null if not completed."
          }
        ],
        "relationships": [
          {
            "description": "Belongs to a TestBatch aggregate which groups multiple test executions."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "pending",
          "in_progress",
          "cancelled",
          "completed"
        ],
        "validTransitions": [
          "pending → in_progress",
          "in_progress → completed",
          "in_progress → cancelled",
          "pending → cancelled"
        ]
      },
      "invariants": [
        {
          "rule": "If isCompleted is true, then progress must be 100%.",
          "notes": "Ensures completion status aligns with progress."
        },
        {
          "rule": "If isCancelled is true, the batch cannot transition to completed.",
          "notes": "Cancelled batches are terminal and do not complete."
        },
        {
          "rule": "startedAt must be set before transitioning to in_progress or beyond.",
          "notes": "Execution start time is mandatory for progress tracking."
        }
      ],
      "commands": [
        {
          "name": "MarkBatchStarted",
          "description": "Sets the batch status to in_progress and records the start time."
        },
        {
          "name": "UpdateBatchProgress",
          "description": "Updates the progress percentage as test executions complete."
        },
        {
          "name": "MarkBatchCompleted",
          "description": "Marks the batch as completed and records the completion time."
        },
        {
          "name": "CancelBatchExecution",
          "description": "Marks the batch as cancelled, stopping further execution."
        }
      ],
      "events": [
        {
          "name": "TestExecutionBatchStarted",
          "description": "Emitted when a test batch execution begins."
        },
        {
          "name": "TestExecutionBatchProgressUpdated",
          "description": "Emitted when progress on the batch execution is updated."
        },
        {
          "name": "TestExecutionBatchCompleted",
          "description": "Emitted when the batch execution completes successfully."
        },
        {
          "name": "TestExecutionBatchCancelled",
          "description": "Emitted when the batch execution is cancelled."
        }
      ],
      "implementation": [
        {
          "kind": "symbol",
          "label": "TestExecutionBatchStatus Type",
          "path": "packages/shared-types/src/testExecution.ts"
        },
        {
          "kind": "file",
          "label": "Test execution logic and status updates",
          "path": "apps/evals-functions/src/index.ts"
        },
        {
          "kind": "file",
          "label": "Worker service handling batch execution and status",
          "path": "apps/worker/src/testExecutionWorker.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "EnvironmentConfig",
        "type": "Value Object",
        "criticality": "Supporting",
        "boundedContext": "User and Operational Infrastructure",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Encapsulates environment-specific configuration such as service accounts, queue names, and locations used across cloud functions and workers.",
        "ubiquitousLanguage": "EnvironmentConfig refers specifically to immutable configuration values that define deployment environment parameters like service account emails, task queue names, and service URLs."
      },
      "structure": {
        "fields": [
          {
            "name": "workerUrl",
            "type": "string",
            "description": "URL of the worker Cloud Run service"
          },
          {
            "name": "tasksServiceAccount",
            "type": "string",
            "description": "Service account email used for Cloud Tasks OIDC tokens"
          },
          {
            "name": "tasksQueue",
            "type": "string",
            "description": "Name of the Cloud Tasks queue"
          },
          {
            "name": "tasksLocation",
            "type": "string",
            "description": "Location/region of the Cloud Tasks queue"
          }
        ],
        "relationships": []
      },
      "lifecycle": {
        "states": [],
        "validTransitions": []
      },
      "invariants": [
        {
          "rule": "All configuration values must be valid and correspond to existing cloud resources.",
          "notes": "Invalid or missing values can cause runtime failures in task dispatching or worker communication."
        },
        {
          "rule": "EnvironmentConfig is immutable at runtime.",
          "notes": "Configuration changes require redeployment or environment variable updates."
        }
      ],
      "commands": [],
      "events": [],
      "implementation": [
        {
          "kind": "file",
          "label": "EnvironmentConfig definitions",
          "path": "apps/evals-functions/src/config.ts"
        },
        {
          "kind": "symbol",
          "label": "workerUrl",
          "path": "apps/evals-functions/src/config.ts"
        },
        {
          "kind": "symbol",
          "label": "tasksServiceAccount",
          "path": "apps/evals-functions/src/config.ts"
        },
        {
          "kind": "symbol",
          "label": "tasksQueue",
          "path": "apps/evals-functions/src/config.ts"
        },
        {
          "kind": "symbol",
          "label": "tasksLocation",
          "path": "apps/evals-functions/src/config.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "DebugContext",
        "type": "Value Object",
        "criticality": "Supporting",
        "boundedContext": "Test Execution and Evaluation",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Contextual information captured during debugging and logging of test executions and AI prompt processing to aid diagnostics.",
        "ubiquitousLanguage": "DebugContext refers specifically to the structured data used to trace and log the state and parameters of AI model requests and test executions. It excludes runtime results or mutable state outside of diagnostic scope."
      },
      "structure": {
        "fields": [
          {
            "name": "db",
            "type": "FirestoreLike",
            "description": "Reference to the Firestore database interface used for recording debug events."
          },
          {
            "name": "rootTs",
            "type": "string",
            "description": "A root timestamp string representing the origin time of the debug session or test execution."
          },
          {
            "name": "templateId",
            "type": "string",
            "description": "Identifier of the test or prompt template being executed."
          },
          {
            "name": "templateVersion",
            "type": "number",
            "description": "Version number of the template to track changes over time."
          },
          {
            "name": "templateVariables",
            "type": "Record<string, any>",
            "description": "Key-value pairs of variables used to render or parameterize the template."
          },
          {
            "name": "requestId",
            "type": "string",
            "description": "Optional unique identifier for the specific LLM request or debug event."
          }
        ],
        "relationships": [
          {
            "description": "Used by LLM request execution and test execution services to log and trace AI prompt processing."
          },
          {
            "description": "Interacts with Firestore for persisting debug events."
          }
        ]
      },
      "lifecycle": {
        "states": [],
        "validTransitions": []
      },
      "invariants": [
        {
          "rule": "templateId must be a non-empty string",
          "notes": "Ensures debug context always references a valid template."
        },
        {
          "rule": "templateVersion must be a positive integer",
          "notes": "Tracks the correct version of the template for reproducibility."
        },
        {
          "rule": "db must be a valid Firestore-like interface",
          "notes": "Required to record debug events reliably."
        }
      ],
      "commands": [],
      "events": [],
      "implementation": [
        {
          "kind": "file",
          "label": "DebugContext interface definition",
          "path": "packages/shared-runtime/src/llm.ts"
        },
        {
          "kind": "file",
          "label": "DebugContext interface definition",
          "path": "apps/evals-functions/src/shared.ts"
        },
        {
          "kind": "symbol",
          "label": "executePrompt function using DebugContext",
          "path": "packages/shared-runtime/src/llm.ts"
        },
        {
          "kind": "symbol",
          "label": "executePrompt function using DebugContext",
          "path": "apps/evals-functions/src/shared.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "TestRun",
        "type": "Entity",
        "criticality": "Core",
        "boundedContext": "Test Execution and Evaluation",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Represents an individual execution instance of a test case or check, capturing detailed results and status within a test execution or batch.",
        "ubiquitousLanguage": "TestRun refers specifically to a single execution attempt of a TestCase against a template, recording outcome status such as pass, fail, or error, along with execution metadata and check results if applicable."
      },
      "structure": {
        "fields": [
          {
            "name": "id",
            "type": "string",
            "description": "Unique identifier for the TestRun instance."
          },
          {
            "name": "testCaseId",
            "type": "string",
            "description": "Identifier of the TestCase being executed."
          },
          {
            "name": "templateId",
            "type": "string",
            "description": "Identifier of the template used during this test run."
          },
          {
            "name": "templateVersion",
            "type": "number",
            "description": "Version number of the template used; may be undefined if template fetch failed."
          },
          {
            "name": "executedBy",
            "type": "string",
            "description": "Identifier of the user or system actor who executed the test run."
          },
          {
            "name": "executedAt",
            "type": "string",
            "description": "Timestamp when the test run was executed."
          },
          {
            "name": "requestId",
            "type": "string",
            "description": "Identifier of the data request associated with this test run; always present on pass and fail."
          },
          {
            "name": "threadId",
            "type": "string",
            "description": "Identifier of the Slack thread or communication context related to this test run; always present on pass and fail."
          },
          {
            "name": "status",
            "type": "'pass' | 'fail' | 'error'",
            "description": "Outcome status of the test run indicating success, failure, or error."
          },
          {
            "name": "elapsedMs",
            "type": "number",
            "description": "Elapsed time in milliseconds for the test run execution; always present on pass and fail."
          },
          {
            "name": "checkResults",
            "type": "CheckResult[] | undefined",
            "description": "Array of detailed results for individual checks run as part of this test run; always present if status is fail, optional if pass."
          },
          {
            "name": "errorMessage",
            "type": "string | undefined",
            "description": "Error message describing failure reason if status is error."
          }
        ],
        "relationships": [
          {
            "description": "Belongs to a TestCase which defines the input and checks to run."
          },
          {
            "description": "Associated with a Template that defines the test execution logic."
          },
          {
            "description": "May have multiple CheckResults representing individual check outcomes."
          },
          {
            "description": "Linked to a data Request and Slack thread for communication and tracking."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "pass",
          "fail",
          "error"
        ],
        "validTransitions": [
          "N/A - TestRun status is set upon completion of execution and is immutable thereafter"
        ]
      },
      "invariants": [
        {
          "rule": "TestRun must have a unique id."
        },
        {
          "rule": "status must be one of 'pass', 'fail', or 'error'."
        },
        {
          "rule": "If status is 'pass', requestId, threadId, and elapsedMs must be present; checkResults may be present."
        },
        {
          "rule": "If status is 'fail', requestId, threadId, elapsedMs, and checkResults must be present."
        },
        {
          "rule": "If status is 'error', errorMessage must be present; templateVersion may be undefined."
        }
      ],
      "commands": [
        {
          "name": "RecordTestRun",
          "description": "Create and persist a new TestRun instance after executing a test case."
        },
        {
          "name": "UpdateTestRunStatus",
          "description": "Update the status and results of a TestRun during or after execution (if applicable)."
        }
      ],
      "events": [
        {
          "name": "TestRunCreated",
          "description": "Emitted when a new TestRun is recorded."
        },
        {
          "name": "TestRunCompleted",
          "description": "Emitted when a TestRun finishes execution with a final status."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "TestRun types and interfaces",
          "path": "apps/evals/src/lib/types.ts"
        },
        {
          "kind": "symbol",
          "label": "TestRunPass, TestRunFail, TestRunError types",
          "path": "apps/evals/src/lib/types.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "TemplateRendering",
        "type": "domain_service",
        "criticality": "core",
        "boundedContext": "Test Template Management",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Handles rendering of test templates using EJS, including extraction of variables and evaluation of templates for test execution.",
        "ubiquitousLanguage": "TemplateRendering refers specifically to the domain service responsible for processing test templates by extracting required variables and rendering the final prompt strings using EJS templating syntax. Synonyms like 'Template Processor' or 'Template Evaluator' may be used internally but 'TemplateRendering' is the preferred term. It excludes unrelated template management or storage concerns."
      },
      "structure": {
        "fields": [
          {
            "name": "template",
            "type": "PromptTemplate",
            "description": "The test template object containing the EJS template string, variables, metadata, and versioning."
          },
          {
            "name": "variables",
            "type": "Record<string, any>",
            "description": "Key-value pairs of variables to be injected into the template during rendering."
          }
        ],
        "relationships": [
          {
            "description": "Operates on PromptTemplate entities representing test templates stored in Firestore."
          },
          {
            "description": "Interacts with Firestore to fetch active template versions and metadata."
          },
          {
            "description": "Integrates with LLMRequest and LLMResponse domain concepts by producing rendered prompts for AI model execution."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "templateLoaded",
          "variablesExtracted",
          "renderingInProgress",
          "renderingSucceeded",
          "renderingFailed"
        ],
        "validTransitions": [
          "templateLoaded → variablesExtracted",
          "variablesExtracted → renderingInProgress",
          "renderingInProgress → renderingSucceeded",
          "renderingInProgress → renderingFailed"
        ]
      },
      "invariants": [
        {
          "rule": "All variables declared in the template must be provided in the variables input before rendering.",
          "notes": "Missing variables cause rendering failure."
        },
        {
          "rule": "Only the active version of a template is used for rendering.",
          "notes": "Ensures consistency and correctness of test executions."
        },
        {
          "rule": "EJS comments and JavaScript keywords are excluded from variable extraction.",
          "notes": "Prevents false positives in variable detection."
        }
      ],
      "commands": [
        {
          "name": "extractVariables(template: string): string[]",
          "description": "Extracts all variable names used in the EJS template string."
        },
        {
          "name": "renderTemplate(template: PromptTemplate, variables: Record<string, any>): Promise<string>",
          "description": "Renders the EJS template with the provided variables, returning the final prompt string."
        },
        {
          "name": "fetchActiveTemplate(templateId: string): Promise<PromptTemplate>",
          "description": "Retrieves the active version of a template from Firestore."
        }
      ],
      "events": [
        {
          "name": "TemplateRenderSucceeded",
          "description": "Emitted when a template is successfully rendered."
        },
        {
          "name": "TemplateRenderFailed",
          "description": "Emitted when template rendering fails due to missing variables or syntax errors."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "Template rendering and fetching logic",
          "path": "apps/evals-functions/src/templates.ts"
        },
        {
          "kind": "file",
          "label": "EJS variable extraction utility",
          "path": "packages/shared-runtime/src/templates.ts"
        },
        {
          "kind": "file",
          "label": "LLM request and debug context integration",
          "path": "apps/evals-functions/src/shared.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "SlackEventProcessing",
        "type": "Domain Service",
        "criticality": "Supporting",
        "boundedContext": "Communication and Collaboration",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Processes and verifies incoming Slack events, including signature verification, event deduplication, and event-driven work enqueueing.",
        "ubiquitousLanguage": "SlackEventProcessing refers specifically to the domain service responsible for handling Slack event payloads securely and reliably. It excludes generic event processing or other messaging platform integrations."
      },
      "structure": {
        "fields": [
          {
            "name": "signature",
            "type": "string",
            "description": "The Slack request signature header used for verifying authenticity."
          },
          {
            "name": "timestamp",
            "type": "string",
            "description": "The Slack request timestamp header used to prevent replay attacks."
          },
          {
            "name": "rawBody",
            "type": "string",
            "description": "The raw HTTP request body payload from Slack."
          },
          {
            "name": "signingSecret",
            "type": "string",
            "description": "The secret key used to verify Slack request signatures."
          },
          {
            "name": "eventId",
            "type": "string",
            "description": "Unique identifier of the Slack event used for deduplication."
          },
          {
            "name": "payload",
            "type": "TaskPayload",
            "description": "The structured payload to enqueue for asynchronous processing."
          }
        ],
        "relationships": [
          {
            "description": "Interacts with Firestore to record and check event deduplication state."
          },
          {
            "description": "Uses Slack API metadata (signature, timestamp) for event authenticity verification."
          },
          {
            "description": "Enqueues verified and deduplicated events as tasks to the Worker service via Google Cloud Tasks."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "received",
          "verified",
          "deduplicated",
          "enqueued",
          "processed"
        ],
        "validTransitions": [
          "received → verified",
          "verified → deduplicated",
          "deduplicated → enqueued",
          "enqueued → processed"
        ]
      },
      "invariants": [
        {
          "rule": "Slack event signature must be valid according to Slack's HMAC v0 specification.",
          "notes": "Prevents unauthorized or tampered requests."
        },
        {
          "rule": "Event timestamp must be within 5 minutes of current time to prevent replay attacks.",
          "notes": "Ensures freshness of events."
        },
        {
          "rule": "Each Slack event ID must be processed only once within a TTL window (1 hour).",
          "notes": "Prevents duplicate processing of the same event."
        },
        {
          "rule": "Work must only be enqueued after successful verification and deduplication.",
          "notes": "Maintains system integrity and avoids redundant processing."
        }
      ],
      "commands": [
        {
          "name": "verifySlackSignature",
          "description": "Validates the Slack request signature and timestamp to authenticate the event."
        },
        {
          "name": "markEventSeenOnce",
          "description": "Records the event ID in Firestore to ensure idempotent processing."
        },
        {
          "name": "enqueueWork",
          "description": "Submits a verified and deduplicated event payload to Google Cloud Tasks for asynchronous processing."
        }
      ],
      "events": [
        {
          "name": "SlackEventVerified",
          "description": "Emitted when a Slack event's signature and timestamp are successfully verified."
        },
        {
          "name": "SlackEventDeduplicated",
          "description": "Emitted when a Slack event is confirmed as not previously processed."
        },
        {
          "name": "SlackEventEnqueued",
          "description": "Emitted when a Slack event is successfully enqueued for background processing."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "Deduplication logic",
          "path": "apps/ingest/src/adapters/dedupe.ts"
        },
        {
          "kind": "file",
          "label": "Slack signature verification",
          "path": "apps/ingest/src/slack/verify.ts"
        },
        {
          "kind": "file",
          "label": "Work enqueueing to Cloud Tasks",
          "path": "apps/ingest/src/core/enqueue.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "TestExecutionWorker",
        "type": "Domain Service",
        "criticality": "Core",
        "boundedContext": "Test Execution and Evaluation",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Background worker service responsible for asynchronously executing LLM jobs and test executions, managing their lifecycle and results.",
        "ubiquitousLanguage": "TestExecutionWorker refers specifically to the background service that processes test execution tasks and LLM jobs in parallel batches, handling job orchestration, status checks, and result persistence. Synonyms like 'Worker Service' or 'Job Processor' may be used internally but 'TestExecutionWorker' is the preferred domain term."
      },
      "structure": {
        "fields": [
          {
            "name": "jobQueue",
            "type": "Queue",
            "description": "Manages the queue of test execution and LLM jobs to be processed asynchronously."
          },
          {
            "name": "db",
            "type": "Firestore Database",
            "description": "Interface to Firestore for reading and updating job, batch, test case, and thread data."
          },
          {
            "name": "llmModel",
            "type": "Generative AI Model Interface",
            "description": "Handles interactions with generative AI models such as Vertex AI for executing LLM jobs."
          }
        ],
        "relationships": [
          {
            "description": "Processes TestExecutionTasks related to test batches, test cases, and templates."
          },
          {
            "description": "Interacts with Firestore collections such as 'testBatches', 'promptTemplates', 'testCases', and 'threads' to retrieve and update job state."
          },
          {
            "description": "Communicates with Slack API to post messages, reactions, and updates related to LLM job progress and results."
          },
          {
            "description": "Uses shared runtime utilities for executing tests and managing LLM interactions."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "queued",
          "running",
          "completed",
          "failed",
          "cancelled"
        ],
        "validTransitions": [
          "queued → running",
          "running → completed",
          "running → failed",
          "queued → cancelled",
          "running → cancelled"
        ]
      },
      "invariants": [
        {
          "rule": "A test execution job must only run if its associated batch is active and not cancelled.",
          "notes": "Prevents wasted computation on cancelled or invalid batches."
        },
        {
          "rule": "Test cases must have defined input variables before execution.",
          "notes": "Ensures that test executions have the necessary data to run."
        },
        {
          "rule": "LLM jobs must update Firestore and Slack consistently to reflect current job status.",
          "notes": "Maintains synchronization between backend state and user-facing communication."
        }
      ],
      "commands": [
        {
          "name": "runTestExecutionJob",
          "description": "Executes a test case within a batch asynchronously, handling input extraction, test execution, and result persistence."
        },
        {
          "name": "runLlmJob",
          "description": "Processes a long-running LLM job, managing Slack thread interactions, reactions, and iterative data request evaluations."
        }
      ],
      "events": [
        {
          "name": "TestExecutionStarted",
          "description": "Emitted when a test execution job begins processing."
        },
        {
          "name": "TestExecutionCompleted",
          "description": "Emitted when a test execution job finishes successfully."
        },
        {
          "name": "TestExecutionFailed",
          "description": "Emitted when a test execution job encounters an error."
        },
        {
          "name": "LlmJobStarted",
          "description": "Emitted when an LLM job begins processing."
        },
        {
          "name": "LlmJobCompleted",
          "description": "Emitted when an LLM job finishes successfully."
        },
        {
          "name": "LlmJobFailed",
          "description": "Emitted when an LLM job encounters an error."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "Test Execution Job Handler",
          "path": "apps/worker/src/jobs/test-execution.ts"
        },
        {
          "kind": "file",
          "label": "LLM Job Handler",
          "path": "apps/worker/src/jobs/llm.ts"
        },
        {
          "kind": "file",
          "label": "Firestore Adapter",
          "path": "apps/worker/src/adapters/firestore.js"
        },
        {
          "kind": "file",
          "label": "Slack API Integration",
          "path": "apps/worker/src/slack/api.js"
        },
        {
          "kind": "file",
          "label": "Shared Runtime Utilities",
          "path": "packages/shared-runtime"
        }
      ]
    },
    {
      "metadata": {
        "name": "ErrorHandling",
        "type": "Domain Service",
        "criticality": "Supporting",
        "boundedContext": "User and Operational Infrastructure",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Centralized error handling and logging utilities to capture, log, and manage errors and operational results across the system.",
        "ubiquitousLanguage": "ErrorHandling refers specifically to the domain service responsible for consistent error processing, structured logging, and user-friendly error messaging. Synonyms like 'ErrorHandler' or 'LoggingService' are acceptable within context. It excludes low-level transport or infrastructure error mechanisms."
      },
      "structure": {
        "fields": [
          {
            "name": "AppError",
            "type": "Value Object",
            "description": "Structured error representation including code, message, severity, recoverability, context, and timestamp."
          },
          {
            "name": "ErrorSeverity",
            "type": "Enum",
            "description": "Defines severity levels such as CRITICAL, HIGH, MEDIUM, LOW to categorize errors."
          },
          {
            "name": "OperationResult",
            "type": "Value Object",
            "description": "Represents the outcome of operations, potentially including success or failure states."
          }
        ],
        "relationships": [
          {
            "description": "Interacts with logging infrastructure (console, structured logs) to record error details."
          },
          {
            "description": "Transforms external errors (e.g., Firebase errors) into domain AppError instances."
          },
          {
            "description": "Supports other domain services and UI layers by providing consistent error information and logging."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "Captured",
          "Logged",
          "Classified",
          "Reported"
        ],
        "validTransitions": [
          "Captured → Classified",
          "Classified → Logged",
          "Logged → Reported"
        ]
      },
      "invariants": [
        {
          "rule": "All errors must be logged with a severity level.",
          "notes": "Ensures consistent visibility and prioritization."
        },
        {
          "rule": "Errors must be transformed into AppError before logging or handling.",
          "notes": "Guarantees uniform error structure across the system."
        },
        {
          "rule": "Recoverable errors should be flagged to allow retry or alternative flows.",
          "notes": "Supports operational resilience."
        }
      ],
      "commands": [
        {
          "name": "log",
          "description": "Logs an AppError with appropriate severity and structured data."
        },
        {
          "name": "fromFirebaseError",
          "description": "Converts a Firebase error into a structured AppError for consistent handling."
        }
      ],
      "events": [
        {
          "name": "ErrorLogged",
          "description": "Emitted when an error is successfully logged."
        },
        {
          "name": "ErrorClassified",
          "description": "Emitted when an error's severity and recoverability are determined."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "Structured logging helpers",
          "path": "packages/shared-types/src/logging.ts"
        },
        {
          "kind": "file",
          "label": "ErrorHandler domain service",
          "path": "packages/shared-types/src/error-handler.ts"
        },
        {
          "kind": "symbol",
          "label": "ErrorHandler class",
          "path": "packages/shared-types/src/error-handler.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "TestCaseManagement",
        "type": "Domain Service",
        "criticality": "Supporting",
        "boundedContext": "Test Template Management",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Manages creation, updating, listing, and organization of test cases within test templates, supporting test lifecycle and versioning.",
        "ubiquitousLanguage": "TestCaseManagement refers specifically to the domain service responsible for handling test cases as part of test templates. Synonyms like 'Test Case Service' or 'Test Case Handler' may be used internally, but 'TestCaseManagement' is the preferred term. It excludes test execution logic or template management outside test cases."
      },
      "structure": {
        "fields": [
          {
            "name": "testCases",
            "type": "TestCase[]",
            "description": "Collection of test cases managed by this service."
          },
          {
            "name": "templateId",
            "type": "string",
            "description": "Identifier of the test template to which test cases belong."
          }
        ],
        "relationships": [
          {
            "description": "Belongs to a Test Template aggregate, managing multiple TestCase entities."
          },
          {
            "description": "Interacts with User entities for creation and updates (e.g., createdBy)."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "draft",
          "active",
          "archived"
        ],
        "validTransitions": [
          "draft → active",
          "active → archived",
          "archived → active"
        ]
      },
      "invariants": [
        {
          "rule": "Each TestCase must have a unique identifier within its Test Template.",
          "notes": "Ensures unambiguous reference and update operations."
        },
        {
          "rule": "Test cases must be associated with exactly one Test Template.",
          "notes": "Prevents orphan or cross-template test cases."
        },
        {
          "rule": "TestCase creation and updates must record metadata such as createdBy, createdAt, and updatedAt.",
          "notes": "Supports auditability and versioning."
        }
      ],
      "commands": [
        {
          "name": "createTestCase",
          "description": "Creates a new test case under a specified test template."
        },
        {
          "name": "updateTestCase",
          "description": "Updates fields of an existing test case."
        },
        {
          "name": "deleteTestCase",
          "description": "Removes a test case from a test template."
        },
        {
          "name": "listTestCases",
          "description": "Retrieves all test cases for a given test template, typically sorted by creation date."
        }
      ],
      "events": [
        {
          "name": "TestCaseCreated",
          "description": "Emitted when a new test case is successfully created."
        },
        {
          "name": "TestCaseUpdated",
          "description": "Emitted when an existing test case is updated."
        },
        {
          "name": "TestCaseDeleted",
          "description": "Emitted when a test case is deleted."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "React hook managing test cases",
          "path": "apps/evals/src/components/template/hooks/useTestCases.ts"
        },
        {
          "kind": "file",
          "label": "UI component for test case management tab",
          "path": "apps/evals/src/components/template/TestCasesTab.tsx"
        },
        {
          "kind": "symbol",
          "label": "createTestCase function",
          "path": "apps/evals/src/components/template/hooks/useTestCases.ts"
        },
        {
          "kind": "symbol",
          "label": "updateTestCase function",
          "path": "apps/evals/src/components/template/hooks/useTestCases.ts"
        },
        {
          "kind": "symbol",
          "label": "deleteTestCase function",
          "path": "apps/evals/src/components/template/hooks/useTestCases.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "TemplateVersioning",
        "type": "Domain Service",
        "criticality": "Core",
        "boundedContext": "Test Template Management",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Manages version control, activation, and lifecycle of test templates to ensure reproducibility and controlled updates.",
        "ubiquitousLanguage": "TemplateVersioning refers specifically to the domain service responsible for handling multiple versions of test templates, including activating a specific version, maintaining version history, and ensuring consistent template usage across test executions. Synonyms like 'Template Version Control' or 'Template Version Management' are acceptable; excludes unrelated versioning concepts outside test templates."
      },
      "structure": {
        "fields": [
          {
            "name": "templateId",
            "type": "string",
            "description": "Unique identifier of the test template."
          },
          {
            "name": "version",
            "type": "number",
            "description": "Version number of a specific template iteration."
          },
          {
            "name": "isActive",
            "type": "boolean",
            "description": "Flag indicating if this version is currently active."
          },
          {
            "name": "templateContent",
            "type": "string",
            "description": "The actual prompt or test template content."
          },
          {
            "name": "variables",
            "type": "string[]",
            "description": "List of variables used in the template."
          },
          {
            "name": "createdAt",
            "type": "string (ISO date)",
            "description": "Timestamp when this version was created."
          },
          {
            "name": "createdBy",
            "type": "string",
            "description": "Identifier of the user who created this version."
          },
          {
            "name": "parentVersion",
            "type": "number | null",
            "description": "The version number from which this version was branched or derived."
          },
          {
            "name": "changeNotes",
            "type": "string | null",
            "description": "Optional notes describing changes in this version."
          },
          {
            "name": "model",
            "type": "string",
            "description": "The generative AI model associated with this template version."
          }
        ],
        "relationships": [
          {
            "description": "Each TemplateVersion belongs to one Template identified by templateId."
          },
          {
            "description": "TemplateVersioning manages multiple TemplateVersions per Template."
          },
          {
            "description": "Active TemplateVersion is referenced by the Template as the current version."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "draft",
          "active",
          "archived"
        ],
        "validTransitions": [
          "draft → active",
          "active → archived",
          "archived → draft (if reactivated)"
        ]
      },
      "invariants": [
        {
          "rule": "Only one TemplateVersion per Template can be active at any given time.",
          "notes": "Ensures reproducibility and consistency in test executions."
        },
        {
          "rule": "Version numbers must increment sequentially and uniquely per Template.",
          "notes": "Prevents version conflicts and maintains clear version history."
        },
        {
          "rule": "A TemplateVersion must have a valid parentVersion or be the initial version (parentVersion null).",
          "notes": "Maintains version lineage."
        }
      ],
      "commands": [
        {
          "name": "CreateTemplateVersion",
          "description": "Creates a new version of a test template with optional change notes."
        },
        {
          "name": "ActivateTemplateVersion",
          "description": "Sets a specific template version as active, deactivating others."
        },
        {
          "name": "ArchiveTemplateVersion",
          "description": "Archives a template version to prevent further use."
        },
        {
          "name": "FetchActiveTemplate",
          "description": "Retrieves the currently active version of a template."
        }
      ],
      "events": [
        {
          "name": "TemplateVersionCreated",
          "description": "Emitted when a new template version is created."
        },
        {
          "name": "TemplateVersionActivated",
          "description": "Emitted when a template version is set as active."
        },
        {
          "name": "TemplateVersionArchived",
          "description": "Emitted when a template version is archived."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "Template fetching and caching logic",
          "path": "apps/worker/src/templates.ts"
        },
        {
          "kind": "file",
          "label": "Template version sidebar UI component",
          "path": "apps/evals/src/components/template/TemplateVersionSidebar.tsx"
        },
        {
          "kind": "symbol",
          "label": "fetchActiveTemplate(templateId: string): Promise<PromptTemplate>",
          "path": "apps/worker/src/templates.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "BatchProcessing",
        "type": "Domain Service",
        "criticality": "Core",
        "boundedContext": "Test Execution and Evaluation",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Orchestrates the processing, progress tracking, and cancellation of batches of test executions, coordinating worker tasks and reporting.",
        "ubiquitousLanguage": "BatchProcessing refers specifically to the domain service responsible for managing the lifecycle and orchestration of test execution batches. Synonyms like 'Batch Orchestration' or 'Batch Manager' may be used internally but 'BatchProcessing' is the preferred term. It excludes individual test executions or single test case handling."
      },
      "structure": {
        "fields": [
          {
            "name": "batchId",
            "type": "string",
            "description": "Unique identifier for the test batch being processed."
          },
          {
            "name": "templateId",
            "type": "string",
            "description": "Identifier of the test template associated with the batch."
          },
          {
            "name": "status",
            "type": "string",
            "description": "Current processing status of the batch (e.g., running, completed, cancelled, failed)."
          },
          {
            "name": "totalTestCases",
            "type": "number",
            "description": "Total number of test cases included in the batch."
          },
          {
            "name": "completedCount",
            "type": "number",
            "description": "Number of test cases completed so far in the batch."
          },
          {
            "name": "initiatedAt",
            "type": "string",
            "description": "Timestamp when the batch processing was started."
          },
          {
            "name": "cancelRequested",
            "type": "boolean",
            "description": "Flag indicating if cancellation of the batch has been requested."
          }
        ],
        "relationships": [
          {
            "description": "Coordinates with Worker service to enqueue and execute individual test execution tasks."
          },
          {
            "description": "Interacts with Firestore to persist batch state and progress."
          },
          {
            "description": "Communicates with Slack API to report batch progress and status updates."
          },
          {
            "description": "Uses Generative AI model APIs indirectly via worker tasks for test execution."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "pending",
          "running",
          "completed",
          "cancelled",
          "failed"
        ],
        "validTransitions": [
          "pending → running",
          "running → completed",
          "running → cancelled",
          "running → failed",
          "pending → cancelled"
        ]
      },
      "invariants": [
        {
          "rule": "A batch must have a valid templateId before execution.",
          "notes": "Ensures test executions are always linked to a valid test template."
        },
        {
          "rule": "Batch status must be one of the defined lifecycle states.",
          "notes": "Prevents invalid or unknown states."
        },
        {
          "rule": "CompletedCount cannot exceed TotalTestCases.",
          "notes": "Ensures progress tracking integrity."
        },
        {
          "rule": "Cancelled batches cannot transition back to running.",
          "notes": "Cancellation is terminal for a batch."
        }
      ],
      "commands": [
        {
          "name": "executeTestBatch",
          "description": "Starts processing a new batch of test executions for a given template."
        },
        {
          "name": "cancelTestBatch",
          "description": "Requests cancellation of an ongoing batch."
        },
        {
          "name": "trackBatchProgress",
          "description": "Updates progress metrics and status of the batch."
        }
      ],
      "events": [
        {
          "name": "TestBatchStarted",
          "description": "Emitted when a batch begins execution."
        },
        {
          "name": "TestBatchProgressUpdated",
          "description": "Emitted when progress on a batch is updated."
        },
        {
          "name": "TestBatchCancelled",
          "description": "Emitted when a batch is cancelled."
        },
        {
          "name": "TestBatchCompleted",
          "description": "Emitted when a batch finishes successfully."
        },
        {
          "name": "TestBatchFailed",
          "description": "Emitted when a batch fails due to errors."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "React Hook for batch operations and state tracking",
          "path": "apps/evals/src/components/template/hooks/useTestBatch.ts"
        },
        {
          "kind": "file",
          "label": "Batch progress UI component",
          "path": "apps/evals/src/components/template/components/BatchProgressIndicator.tsx"
        },
        {
          "kind": "file",
          "label": "Batch detail modal UI component",
          "path": "apps/evals/src/components/template/components/BatchDetailModal.tsx"
        },
        {
          "kind": "file",
          "label": "Cloud Function to enqueue and initiate test batch execution",
          "path": "apps/evals-functions/src/index.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "SlackThreadManagement",
        "type": "Domain Service",
        "criticality": "Supporting",
        "boundedContext": "Communication and Collaboration",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Manages the lifecycle and interactions of Slack threads related to data requests and test executions, including posting messages, adding reactions, fetching messages, and updating thread status.",
        "ubiquitousLanguage": "Slack thread refers specifically to a conversation thread within Slack channels used for coordinating data requests and test evaluations. Synonyms like 'Slack conversation' or 'Slack channel message thread' are acceptable. Excludes unrelated Slack messaging concepts such as direct messages or ephemeral messages."
      },
      "structure": {
        "fields": [
          {
            "name": "channel",
            "type": "string",
            "description": "Slack channel identifier where the thread exists"
          },
          {
            "name": "rootTs",
            "type": "string",
            "description": "Timestamp of the root message that identifies the Slack thread"
          },
          {
            "name": "status",
            "type": "string",
            "description": "Current status of the thread lifecycle or coordination state"
          },
          {
            "name": "messages",
            "type": "List<Message>",
            "description": "Collection of messages posted within the thread"
          }
        ],
        "relationships": [
          {
            "description": "Coordinates with DataRequest and TestExecution domain concepts to reflect their progress and results within Slack threads"
          },
          {
            "description": "Interacts with Slack API for messaging and reactions"
          },
          {
            "description": "Persists thread status and metadata in Firestore for state tracking"
          }
        ]
      },
      "lifecycle": {
        "states": [
          "initialized",
          "active",
          "awaiting_response",
          "completed",
          "archived"
        ],
        "validTransitions": [
          "initialized → active",
          "active → awaiting_response",
          "awaiting_response → active",
          "active → completed",
          "completed → archived"
        ]
      },
      "invariants": [
        {
          "rule": "Thread must always be associated with a valid Slack channel and root timestamp",
          "notes": "Ensures messages and reactions are posted to the correct thread"
        },
        {
          "rule": "Only valid Slack API responses are accepted; errors must be handled gracefully",
          "notes": "Prevents inconsistent thread state due to API failures"
        },
        {
          "rule": "Thread status updates must be persisted atomically to Firestore",
          "notes": "Maintains consistency between Slack state and backend tracking"
        }
      ],
      "commands": [
        {
          "name": "postThreadMessage",
          "description": "Post a text message to a Slack thread"
        },
        {
          "name": "postThreadBlocks",
          "description": "Post a message with block elements to a Slack thread"
        },
        {
          "name": "addRobotReaction",
          "description": "Add a robot_face emoji reaction to the root message of a Slack thread"
        },
        {
          "name": "updateThreadStatus",
          "description": "Update the lifecycle status of a Slack thread in Firestore"
        },
        {
          "name": "fetchThreadMessages",
          "description": "Retrieve messages from a Slack thread (implied, not shown in snippet)"
        }
      ],
      "events": [
        {
          "name": "ThreadMessagePosted",
          "description": "Emitted when a new message is posted to a Slack thread"
        },
        {
          "name": "ThreadReactionAdded",
          "description": "Emitted when a reaction is added to a Slack thread message"
        },
        {
          "name": "ThreadStatusUpdated",
          "description": "Emitted when the thread lifecycle status changes"
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "Slack API client and thread message functions",
          "path": "apps/worker/src/slack/api.ts"
        },
        {
          "kind": "file",
          "label": "Thread status update placeholder",
          "path": "apps/worker/src/adapters/threads.ts"
        }
      ]
    },
    {
      "metadata": {
        "name": "TemplateVariableManagement",
        "type": "Value Object",
        "criticality": "Supporting",
        "boundedContext": "Test Template Management",
        "aggregateRoot": false
      },
      "definition": {
        "shortDescription": "Represents and manages variables used within EJS test templates, supporting variable extraction, tabbed UI display, and template rendering.",
        "ubiquitousLanguage": "Template variables refer specifically to named placeholders or expressions embedded in EJS templates that are dynamically replaced or evaluated during template rendering. Synonyms like 'template parameters' or 'placeholders' are discouraged to avoid ambiguity with other parameter types."
      },
      "structure": {
        "fields": [
          {
            "name": "variables",
            "type": "Record<string, any>",
            "description": "A map of variable names to their current values used in the template."
          },
          {
            "name": "templateString",
            "type": "string",
            "description": "The raw EJS template string containing embedded variables."
          },
          {
            "name": "extractedVariableNames",
            "type": "string[]",
            "description": "List of variable names extracted from the EJS template string."
          }
        ],
        "relationships": [
          {
            "description": "Used by Test Templates to dynamically render content with variable substitution."
          },
          {
            "description": "Displayed in the UI as tabbed views to allow users to inspect and interact with variable values."
          }
        ]
      },
      "lifecycle": {
        "states": [
          "initialized",
          "variablesExtracted",
          "rendered"
        ],
        "validTransitions": [
          "initialized → variablesExtracted",
          "variablesExtracted → rendered"
        ]
      },
      "invariants": [
        {
          "rule": "All variable names extracted must be valid JavaScript identifiers and not JavaScript reserved keywords.",
          "notes": "Ensures safe and predictable template rendering without syntax errors."
        },
        {
          "rule": "Variables must be immutable once extracted to maintain consistency during rendering.",
          "notes": "Supports value object semantics and prevents side effects."
        }
      ],
      "commands": [
        {
          "name": "extractVariables(templateString: string): string[]",
          "description": "Parses the EJS template string and returns a sorted list of unique variable names used."
        },
        {
          "name": "renderTemplate(variables: Record<string, any>): string",
          "description": "Renders the EJS template by substituting variables with provided values."
        }
      ],
      "events": [
        {
          "name": "VariablesExtracted",
          "description": "Emitted after successful extraction of variables from a template."
        },
        {
          "name": "TemplateRendered",
          "description": "Emitted after the template has been rendered with variable values."
        }
      ],
      "implementation": [
        {
          "kind": "file",
          "label": "Variable Extraction Utility",
          "path": "packages/shared-runtime/src/templates.ts"
        },
        {
          "kind": "file",
          "label": "Template Rendering and LLM Interaction",
          "path": "apps/evals-functions/src/shared.ts"
        },
        {
          "kind": "file",
          "label": "UI Component for Variable Tabs Display",
          "path": "apps/evals/src/components/LlmResponseTabs.tsx"
        }
      ]
    }
  ]
}