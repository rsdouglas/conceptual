{
  "id": "gcp-data-request",
  "name": "Slack-based Data Request and LLM Evaluation System",
  "summary": "A system where Slack conversations become structured data requests that are reviewed, processed by LLMs, and evaluated using configurable templates and checks.",
  "description": "The system turns informal Slack threads into formal data requests, guides requesters through an automated review and iteration process, and executes LLM-based workflows to answer or process those requests. Admins configure prompt templates, test cases, and evaluation checks via a web UI, while background workers orchestrate LLM calls, Slack interactions, and Firestore persistence. The system records debug events and test results to support continuous improvement of templates and workflows.",
  "models": [
    {
      "id": "slack-data-request-flow",
      "title": "Slack Data Request Flow",
      "description": "How Slack conversations are turned into structured data requests, iterated on, and communicated back to users.",
      "concepts": [
        {
          "id": "slack-user",
          "label": "Slack user",
          "category": "role",
          "description": "A person interacting with the system through Slack, asking questions or making data-related requests.",
          "aliases": [
            "slack-user",
            "user",
            "userId"
          ],
          "notes": "A Slack user is a human (or possibly another Slack actor) identified by a Slack user ID string, interacting with the system via Slack messages. In the shared types, the Slack user is represented indirectly by the optional `user` field on `EventEnvelope` and `TaskPayload`, and by `userId` on `TestExecutionTaskPayload`. The Slack user is the originator of Slack events that the system processes and is the intended recipient of user-facing error messages and responses posted back into Slack threads."
        },
        {
          "id": "slack-channel",
          "label": "Slack channel",
          "category": "place",
          "description": "A Slack conversation space where data requests are initiated and discussed.",
          "aliases": [
            "slack-channel",
            "channel",
            "Slack conversation space"
          ],
          "notes": "A Slack channel is the identifier of the Slack conversation space where the bot operates. It is used to post messages, reactions, and threaded replies related to data requests and LLM evaluation. In the code, it appears as a string field named `channel` passed to Slack Web API methods and embedded in event and task payloads."
        },
        {
          "id": "slack-thread",
          "label": "Slack thread",
          "category": "thing",
          "description": "A threaded Slack conversation that the system treats as a single data request context.",
          "aliases": [
            "slack-thread",
            "thread",
            "root thread",
            "thread context",
            "thread doc",
            "threads/<root_ts>"
          ],
          "notes": "A Slack thread is the unit of context that the system treats as a single data request. It is identified by a root Slack timestamp (rootTs / root_ts) corresponding to the parent message of the thread. Per-thread state (such as whether the bot has reacted or greeted) is stored in a Firestore document in the 'threads' collection keyed by this root timestamp. All Slack events and tasks that belong to the same data request reference this rootTs so they can be associated with the same Slack thread."
        },
        {
          "id": "slack-message",
          "label": "Slack message",
          "category": "thing",
          "description": "An individual message in a Slack thread that may contain a data request or follow-up information.",
          "aliases": [
            "slack-message",
            "Slack message",
            "thread message",
            "outgoing_slack_message",
            "thread greeting",
            "thread reply"
          ],
          "notes": "A Slack message is an individual post within a Slack channel or thread. In this system, the primary focus is on messages posted by the bot into an existing thread (identified by rootTs/thread_ts). These messages can be plain text or block-based, and they are used to greet users, respond to data requests, and provide follow-up information. Each outgoing Slack message from the bot is also recorded as a debug event for observability."
        },
        {
          "id": "data-request",
          "label": "Data request",
          "category": "thing",
          "description": "A structured representation of what a Slack user is asking for, derived from one or more Slack messages.",
          "aliases": [
            "data-request",
            "data request",
            "request",
            "Slack data request",
            "in-thread data request",
            "meta question about data",
            "directAnswer (for meta questions about data structures/terminology)"
          ],
          "notes": "A Data Request is a structured interpretation of what a Slack user is asking for in a Slack thread. It is derived from one or more Slack messages and may evolve as the conversation continues. The system first classifies whether a given Slack message/thread is a data request at all, then iteratively refines a set of artifacts that represent the request (formal request text, clarifying questions, step-by-step self-service instructions, or a direct answer for meta questions about data structures/terminology)."
        },
        {
          "id": "data-request-classification",
          "label": "Data request classification",
          "category": "activity",
          "description": "The activity of determining whether a Slack thread contains a data request and what type of request it is.",
          "aliases": [
            "data-request-classification",
            "is_data_request",
            "data request detection",
            "data request verdict",
            "classification_verdict"
          ],
          "notes": "Data request classification is the activity of using an LLM (via a prompt template) to decide whether a Slack thread contains a data request and to produce a structured verdict. In the provided code, this is embodied by the isDataRequest function, which takes the full Slack thread and a specific message, renders an 'is_data_request' template, calls a generative model, and interprets the result as a verdict with isDataRequest (boolean), reason (string), and confidence (number). When a root thread timestamp (rootTs) is provided, the classification is associated with a debug context and persisted/monitored via Firestore and error-recording mechanisms."
        },
        {
          "id": "data-request-iteration",
          "label": "Data request iteration",
          "category": "activity",
          "description": "The process of refining a data request through back-and-forth with the user to clarify requirements.",
          "aliases": [
            "data-request-iteration",
            "iteration on a data request",
            "in-thread iteration on a data request",
            "continue data request iteration",
            "iterate_data_request"
          ],
          "notes": "Data request iteration is the ongoing, in-thread process of updating and refining a Slack-based data request as new user messages arrive. The LLM receives the full Slack thread, the latest user reply, and previously generated artifacts (request, clarifyingQuestions, stepByStepInstructions, directAnswer) and produces updated artifacts that better reflect the newest information. Iteration may remove clarifying questions once they are answered, refine the request as it becomes clearer, add or update self-service Looker instructions when appropriate, or switch to providing a direct answer for meta questions about fields, terminology, or data structures."
        },
        {
          "id": "data-request-review",
          "label": "Data request review",
          "category": "activity",
          "description": "The activity of assessing whether a data request is appropriate, feasible, and compliant before execution.",
          "aliases": [
            "data request review",
            "review data request",
            "review_result",
            "ReviewResult",
            "LLM data request review"
          ],
          "notes": "Data request review is the LLM-mediated activity where the Slackbot analyzes a user's raw data request and produces structured artifacts to make the request clear, unambiguous, and actionable for the data team or for self-service. The review focuses on documenting the request, identifying missing information, suggesting self-service steps in Looker, and optionally providing a direct answer for meta (non-numeric) questions."
        },
        {
          "id": "slack-bot-feedback",
          "label": "Slack bot feedback",
          "category": "activity",
          "description": "The system’s visible responses in Slack, such as greetings, status updates, and results posted back to the user.",
          "aliases": [
            "slack-bot-feedback",
            "Slack bot feedback",
            "Slack responses",
            "outgoing Slack message",
            "thread greeting",
            "thread message",
            "thread blocks",
            "robot reaction",
            "bot reaction"
          ],
          "notes": "Slack bot feedback is the set of visible responses the system sends into Slack in response to a user’s data request thread. It includes reactions (e.g., a robot_face reaction on the root message) and messages posted into the same thread (greetings, status updates, results, and other text or block-based messages). These responses are posted using the bot token and are associated with a specific channel and root thread timestamp. Each outgoing Slack message is also recorded as a debug event of type 'outgoing_slack_message' for observability."
        },
        {
          "id": "slack-robot-reaction",
          "label": "Slack robot reaction",
          "category": "event",
          "description": "Emoji reactions added or removed by the bot to signal that a thread is being processed or has completed.",
          "aliases": [
            "slack-robot-reaction",
            "robot reaction",
            "robot_face reaction",
            "bot reaction",
            "addRobotReaction"
          ],
          "notes": "A Slack emoji reaction (specifically the :robot_face: emoji) that the bot adds to the root message of a Slack thread. It visually signals that the bot has noticed the thread and is processing or engaging with it. In the current code, it is always added via the Slack Web API `reactions.add` method with `name: \"robot_face\"` and the root message timestamp as the target."
        },
        {
          "id": "ingest-event",
          "label": "Ingest event",
          "category": "event",
          "description": "An incoming Slack or external event that triggers ingestion, deduplication, and queuing of work.",
          "aliases": [
            "ingest event",
            "event",
            "incoming event",
            "EventEnvelope",
            "Slack event",
            "external event"
          ],
          "notes": "An ingest event is an incoming Slack or external event that enters the ingest pipeline. It is represented structurally as an EventEnvelope (with eventId, channel, ts, etc.). When received, it is checked for idempotency/deduplication using its eventId, and if accepted as new, it leads to creation of queued work (TaskPayload) for downstream processing."
        }
      ],
      "relationships": [
        {
          "id": "rel-slack-user-sends-event-envelope",
          "from": "slack-user",
          "to": "event-envelope",
          "phrase": "sends",
          "category": "causes",
          "description": "A Slack user sends a message or interaction in Slack, which the system represents as an EventEnvelope with a `user` field containing the Slack user ID."
        },
        {
          "id": "rel-slack-user-initiates-task-payload",
          "from": "slack-user",
          "to": "task-payload",
          "phrase": "initiates",
          "category": "causes",
          "description": "A Slack user's message or request leads to creation of a TaskPayload, where the originating Slack user may be recorded in the `user` field."
        },
        {
          "id": "rel-slack-user-initiates-test-execution",
          "from": "slack-user",
          "to": "test-execution-task-payload",
          "phrase": "initiates",
          "category": "causes",
          "description": "A Slack user can be the actor who triggers a test execution; this is captured as `userId` on a TestExecutionTaskPayload."
        },
        {
          "id": "rel-slack-user-receives-thread-messages",
          "from": "slack-user",
          "to": "outgoing-slack-message",
          "phrase": "receives",
          "category": "uses",
          "description": "A Slack user receives responses from the system as outgoing Slack messages posted into the relevant channel and thread."
        },
        {
          "id": "rel-slack-user-is-subject-of-app-error-messages",
          "from": "slack-user",
          "to": "app-error",
          "phrase": "is informed by",
          "category": "uses",
          "description": "When operations related to a Slack user's request fail, AppError instances with user-friendly messages are intended to be communicated back to the Slack user."
        },
        {
          "id": "rel-slack-channel-has-events",
          "from": "slack-channel",
          "to": "event-envelope",
          "phrase": "has",
          "category": "part_of",
          "description": "Each EventEnvelope is associated with exactly one Slack channel, indicating the conversation space where the event occurred."
        },
        {
          "id": "rel-slack-channel-receives-events",
          "from": "slack-channel",
          "to": "event-envelope",
          "phrase": "receives",
          "category": "uses",
          "description": "A Slack channel receives events (messages, reactions, etc.) that are wrapped as EventEnvelopes for processing in the data request flow."
        },
        {
          "id": "rel-slack-channel-has-tasks",
          "from": "slack-channel",
          "to": "task-payload",
          "phrase": "is referenced by",
          "category": "uses",
          "description": "TaskPayloads include a channel field to indicate which Slack channel the task’s Slack interactions (messages, reactions) should occur in."
        },
        {
          "id": "rel-slack-channel-contains-threads",
          "from": "slack-channel",
          "to": "slack-thread",
          "phrase": "contains",
          "category": "part_of",
          "description": "A Slack channel contains one or more threads, each identified by a root timestamp (rootTs or threadTs) within that channel."
        },
        {
          "id": "rel-slack-channel-hosts-data-requests",
          "from": "slack-channel",
          "to": "data-request-thread",
          "phrase": "hosts",
          "category": "part_of",
          "description": "Data request discussions are conducted in threads within a Slack channel; the channel is the overall space in which these request threads live."
        },
        {
          "id": "rel-slack-channel-receives-bot-reactions",
          "from": "slack-channel",
          "to": "bot-reaction",
          "phrase": "receives",
          "category": "uses",
          "description": "The system adds robot_face reactions to messages in a Slack channel to signal automated processing or acknowledgment."
        },
        {
          "id": "rel-slack-channel-receives-bot-messages",
          "from": "slack-channel",
          "to": "bot-thread-message",
          "phrase": "receives",
          "category": "uses",
          "description": "The system posts thread messages and block-based messages into a Slack channel as part of the data request and evaluation workflow."
        },
        {
          "id": "rel-slack-channel-is-logged-in-debug-events",
          "from": "slack-channel",
          "to": "debug-event",
          "phrase": "is recorded in",
          "category": "uses",
          "description": "When the system sends outgoing Slack messages, the associated channel is recorded in DebugEvents for observability and troubleshooting."
        },
        {
          "id": "rel-thread-has-root-ts",
          "from": "slack-thread",
          "to": "slack-message-root-timestamp",
          "phrase": "is identified by",
          "category": "represents",
          "description": "Each Slack thread is uniquely identified in the system by the root Slack message timestamp (rootTs/root_ts) of the thread's parent message."
        },
        {
          "id": "rel-thread-stored-in-threads-collection",
          "from": "slack-thread",
          "to": "threads-collection",
          "phrase": "is stored as document in",
          "category": "part_of",
          "description": "Each Slack thread has a corresponding document in the Firestore 'threads' collection, keyed by its rootTs, where per-thread flags and status are persisted."
        },
        {
          "id": "rel-thread-has-flags",
          "from": "slack-thread",
          "to": "thread-flags",
          "phrase": "has",
          "category": "part_of",
          "description": "A Slack thread has per-thread flags (such as 'reacted' and 'greeted') that record whether the system has already performed certain actions in that thread."
        },
        {
          "id": "rel-thread-uses-user",
          "from": "slack-thread",
          "to": "slack-user",
          "phrase": "is associated with",
          "category": "uses",
          "description": "When setting per-thread flags, the system may associate the Slack thread with a Slack user (the requester or message author) via the 'user' field."
        },
        {
          "id": "rel-thread-uses-channel",
          "from": "slack-thread",
          "to": "slack-channel",
          "phrase": "occurs in",
          "category": "uses",
          "description": "A Slack thread occurs within a specific Slack channel; the channel ID is stored alongside thread-related operations and used to fetch channel info."
        },
        {
          "id": "rel-thread-uses-text",
          "from": "slack-thread",
          "to": "slack-message-text",
          "phrase": "is described by",
          "category": "uses",
          "description": "The initial or current text associated with a Slack thread (e.g., the root message text) can be stored or passed when setting thread flags to capture the data request content."
        },
        {
          "id": "rel-thread-aggregates-events",
          "from": "slack-thread",
          "to": "slack-event",
          "phrase": "aggregates",
          "category": "part_of",
          "description": "Multiple Slack events (messages, replies) that share the same rootTs are treated as part of the same Slack thread and thus the same data request context."
        },
        {
          "id": "rel-thread-linked-from-task-payload",
          "from": "slack-thread",
          "to": "task-payload",
          "phrase": "is referenced by",
          "category": "uses",
          "description": "Background tasks reference a Slack thread via the rootTs field in TaskPayload so that processing can be tied back to the correct thread context."
        },
        {
          "id": "rel-thread-linked-from-event-envelope",
          "from": "slack-thread",
          "to": "event-envelope",
          "phrase": "is referenced by",
          "category": "uses",
          "description": "Incoming Slack events reference a Slack thread via the ts and threadTs fields in EventEnvelope, allowing the system to determine the rootTs for the thread."
        },
        {
          "id": "rel-thread-has-status",
          "from": "slack-thread",
          "to": "thread-status",
          "phrase": "has",
          "category": "part_of",
          "description": "A Slack thread has a status value that can be updated (e.g., via updateThreadStatus) to reflect the processing state of the data request associated with the thread."
        },
        {
          "id": "rel-slack-message-part-of-thread",
          "from": "slack-message",
          "to": "slack-thread",
          "phrase": "is posted in",
          "category": "part_of",
          "description": "Each Slack message handled by this flow is posted into a specific Slack thread, identified by the root thread timestamp (rootTs/thread_ts)."
        },
        {
          "id": "rel-slack-message-part-of-channel",
          "from": "slack-message",
          "to": "slack-channel",
          "phrase": "appears in",
          "category": "part_of",
          "description": "Each Slack message appears in a specific Slack channel, identified by its channel ID."
        },
        {
          "id": "rel-slack-message-represents-bot-response",
          "from": "slack-message",
          "to": "bot-response",
          "phrase": "represents",
          "category": "represents",
          "description": "An outgoing Slack message represents the bot's response to a data request or follow-up in the associated thread."
        },
        {
          "id": "rel-slack-message-uses-debug-event",
          "from": "slack-message",
          "to": "debug-event",
          "phrase": "is recorded as",
          "category": "uses",
          "description": "Each outgoing Slack message from the bot is recorded as a debug event of type 'outgoing_slack_message' for monitoring and troubleshooting."
        },
        {
          "id": "rel-slack-message-has-content",
          "from": "slack-message",
          "to": "message-content",
          "phrase": "has",
          "category": "part_of",
          "description": "A Slack message has content, which may be plain text or structured blocks."
        },
        {
          "id": "rel-slack-message-uses-reaction",
          "from": "slack-message",
          "to": "robot-reaction",
          "phrase": "may trigger",
          "category": "enables",
          "description": "A Slack message in a thread may cause the system to add a 'robot_face' reaction to the root message, signaling bot involvement."
        },
        {
          "id": "rel-data-request-derived-from-thread",
          "from": "data-request",
          "to": "slack-thread",
          "phrase": "is derived from",
          "category": "represents",
          "description": "A Data Request is derived from the content of a Slack thread, which is passed to the LLM as the fullThread input when determining or iterating on the request."
        },
        {
          "id": "rel-data-request-derived-from-message",
          "from": "data-request",
          "to": "slack-message",
          "phrase": "is refined from",
          "category": "represents",
          "description": "A Data Request is refined based on a specific Slack message within the thread (specificMessage / latest user reply) that the system is currently responding to."
        },
        {
          "id": "rel-slack-user-creates-data-request",
          "from": "slack-user",
          "to": "data-request",
          "phrase": "creates by posting messages",
          "category": "causes",
          "description": "A Slack user implicitly creates a Data Request by posting one or more messages in a Slack thread that the system interprets as a request for data or data-related information."
        },
        {
          "id": "rel-data-request-has-artifacts",
          "from": "data-request",
          "to": "data-request-artifact",
          "phrase": "is represented by",
          "category": "part_of",
          "description": "A Data Request is represented by a set of artifacts (request text, clarifying questions, step-by-step instructions, or a direct answer) that capture the current understanding of what is being asked."
        },
        {
          "id": "rel-data-request-artifact-types",
          "from": "data-request-artifact",
          "to": "data-request-artifact-type",
          "phrase": "includes types",
          "category": "is_a",
          "description": "Data Request artifacts can take several forms: a structured request description, clarifying questions, step-by-step self-service instructions, or a direct answer for meta questions about data structures and terminology."
        },
        {
          "id": "rel-data-request-uses-classification",
          "from": "data-request",
          "to": "llm-classification-verdict",
          "phrase": "is gated by",
          "category": "uses",
          "description": "Creation of a Data Request is gated by an LLM classification verdict that determines whether the Slack content is a data request at all, including a boolean isDataRequest flag, reasoning, and confidence."
        },
        {
          "id": "rel-data-request-uses-iteration",
          "from": "data-request",
          "to": "llm-iteration-process",
          "phrase": "is refined by",
          "category": "uses",
          "description": "A Data Request is refined over time by an LLM iteration process that updates the artifacts as new Slack messages arrive in the thread."
        },
        {
          "id": "rel-data-request-logged-as-debug-event",
          "from": "data-request",
          "to": "debug-event",
          "phrase": "is associated with",
          "category": "uses",
          "description": "The lifecycle of a Data Request is associated with debug events such as llm_classification and time_to_react, which record timing, verdicts, and reasoning about the request."
        },
        {
          "id": "rel-data-request-classification-uses-slack-thread",
          "from": "data-request-classification",
          "to": "slack-thread",
          "phrase": "analyzes",
          "category": "uses",
          "description": "Data request classification analyzes the full Slack thread (as an ordered list of messages) to determine whether it contains a data request."
        },
        {
          "id": "rel-data-request-classification-uses-specific-message",
          "from": "data-request-classification",
          "to": "slack-message",
          "phrase": "focuses-on",
          "category": "uses",
          "description": "Data request classification focuses on a specific Slack message within the thread as an anchor for deciding whether there is a data request."
        },
        {
          "id": "rel-data-request-classification-produces-verdict",
          "from": "data-request-classification",
          "to": "data-request-verdict",
          "phrase": "produces",
          "category": "causes",
          "description": "Data request classification produces a verdict object containing isDataRequest, reason, and confidence."
        },
        {
          "id": "rel-data-request-classification-uses-template",
          "from": "data-request-classification",
          "to": "prompt-template",
          "phrase": "uses",
          "category": "uses",
          "description": "Data request classification uses an active 'is_data_request' prompt template, which is fetched and rendered with the Slack thread and specific message."
        },
        {
          "id": "rel-data-request-classification-uses-generative-model",
          "from": "data-request-classification",
          "to": "generative-model",
          "phrase": "invokes",
          "category": "uses",
          "description": "Data request classification invokes a generative model (e.g., a Vertex AI model) to evaluate the rendered prompt and obtain the classification result."
        },
        {
          "id": "rel-data-request-classification-uses-debug-context",
          "from": "data-request-classification",
          "to": "debug-context",
          "phrase": "associates-with",
          "category": "uses",
          "description": "Data request classification may associate its execution with a debug context, tying the classification to a root Slack thread timestamp, template metadata, and a request identifier."
        },
        {
          "id": "rel-data-request-classification-uses-firestore",
          "from": "data-request-classification",
          "to": "debug-log-store",
          "phrase": "records-errors-in",
          "category": "uses",
          "description": "Data request classification records errors related to generative model execution into a Firestore-backed debug log store when a debug context is present."
        },
        {
          "id": "rel-data-request-classification-precedes-downstream-processing",
          "from": "data-request-classification",
          "to": "downstream-data-request-processing",
          "phrase": "gates",
          "category": "precedes",
          "description": "Data request classification gates downstream data request processing by indicating whether a Slack thread should be treated as a data request at all."
        },
        {
          "id": "rel-data-request-iteration-refines-artifacts",
          "from": "data-request-iteration",
          "to": "data-request-artifacts",
          "phrase": "updates and refines",
          "category": "uses",
          "description": "Data request iteration updates the current set of artifacts (request text, clarifying questions, step-by-step instructions, and any direct answer) to reflect the latest information in the Slack thread."
        },
        {
          "id": "rel-data-request-iteration-uses-slack-thread",
          "from": "data-request-iteration",
          "to": "slack-thread",
          "phrase": "uses",
          "category": "uses",
          "description": "Data request iteration uses the full Slack thread and the latest user reply as inputs to understand context and refine the data request."
        },
        {
          "id": "rel-data-request-iteration-uses-prior-artifacts",
          "from": "data-request-iteration",
          "to": "prior-artifacts",
          "phrase": "uses",
          "category": "uses",
          "description": "Data request iteration consumes prior artifacts (request, clarifyingQuestions, stepByStepInstructions, directAnswer) as inputs and produces updated versions of those artifacts."
        },
        {
          "id": "rel-data-request-iteration-uses-llm",
          "from": "data-request-iteration",
          "to": "generative-model",
          "phrase": "is performed by",
          "category": "uses",
          "description": "Data request iteration is carried out by a generative model that executes a prompt describing how to update the artifacts based on the latest Slack messages."
        },
        {
          "id": "rel-data-request-iteration-part-of-slack-data-request-flow",
          "from": "data-request-iteration",
          "to": "slack-data-request-flow",
          "phrase": "is part of",
          "category": "part_of",
          "description": "Data request iteration is a recurring step within the overall Slack Data Request Flow, occurring whenever a user adds new information or replies in the thread."
        },
        {
          "id": "rel-data-request-iteration-produces-direct-answer",
          "from": "data-request-iteration",
          "to": "direct-answer",
          "phrase": "may produce or update",
          "category": "uses",
          "description": "During iteration, the system may produce or update a directAnswer artifact when the user’s message is a meta question about field meanings, business terminology, or data structures rather than about specific data values."
        },
        {
          "id": "rel-data-request-iteration-produces-clarifying-questions",
          "from": "data-request-iteration",
          "to": "clarifying-questions",
          "phrase": "may produce, update, or remove",
          "category": "uses",
          "description": "During iteration, the system may add, refine, or remove clarifying questions depending on whether the user has answered them and whether the request is now clear."
        },
        {
          "id": "rel-data-request-iteration-produces-step-by-step-instructions",
          "from": "data-request-iteration",
          "to": "step-by-step-instructions",
          "phrase": "may produce or update",
          "category": "uses",
          "description": "During iteration, the system may produce or update step-by-step Looker instructions when self-service access to the requested data is possible."
        },
        {
          "id": "rel-data-request-iteration-refines-data-request",
          "from": "data-request-iteration",
          "to": "data-request",
          "phrase": "refines",
          "category": "uses",
          "description": "Each data request iteration refines the underlying data request description as the user provides more information or clarification."
        },
        {
          "id": "rel-data-request-review-uses-llm",
          "from": "data-request-review",
          "to": "llm-model",
          "phrase": "uses",
          "category": "uses",
          "description": "Data request review uses a generative LLM model (via getGenerativeModel and executePrompt) to analyze and transform the user's data request into structured review outputs."
        },
        {
          "id": "rel-data-request-review-uses-context",
          "from": "data-request-review",
          "to": "review-context",
          "phrase": "uses",
          "category": "uses",
          "description": "Data request review uses all available context (via useAllContext and fetchActiveTemplate, including current date and time) to interpret and refine the user's data request."
        },
        {
          "id": "rel-data-request-review-produces-review-result",
          "from": "data-request-review",
          "to": "review-result",
          "phrase": "produces",
          "category": "causes",
          "description": "Data request review produces a ReviewResult object containing a clarified request, clarifying questions, step-by-step instructions, and an optional direct answer."
        },
        {
          "id": "rel-data-request-review-intermediary-between-user-and-data-team",
          "from": "data-request-review",
          "to": "data-request",
          "phrase": "mediates",
          "category": "enables",
          "description": "Data request review acts as an intermediary between a user submitting a data request in Slack and the data team that will fulfill or respond to that request."
        },
        {
          "id": "rel-review-result-has-clarifying-questions",
          "from": "review-result",
          "to": "clarifying-questions",
          "phrase": "has",
          "category": "part_of",
          "description": "A review result includes a clarifyingQuestions field that captures questions the user must answer before the request can proceed."
        },
        {
          "id": "rel-review-result-has-step-by-step-instructions",
          "from": "review-result",
          "to": "self-service-instructions",
          "phrase": "has",
          "category": "part_of",
          "description": "A review result includes stepByStepInstructions describing how the requester can self-serve the answer in Looker when appropriate."
        },
        {
          "id": "rel-review-result-has-direct-answer",
          "from": "review-result",
          "to": "direct-answer",
          "phrase": "has",
          "category": "part_of",
          "description": "A review result includes a directAnswer field used when the user asks meta questions about field meanings, business terminology, or data structures."
        },
        {
          "id": "rel-review-result-has-documented-request",
          "from": "review-result",
          "to": "documented-data-request",
          "phrase": "has",
          "category": "part_of",
          "description": "A review result includes a request field that represents the LLM's best attempt at a clear, well-documented, unambiguous data request suitable for analysts."
        },
        {
          "id": "rel-data-request-review-precedes-user-presentation",
          "from": "data-request-review",
          "to": "user-facing-response",
          "phrase": "precedes",
          "category": "precedes",
          "description": "Data request review precedes the construction of the user-facing Slack response, which selectively shows clarifying questions, self-service instructions, or the documented request based on the review output."
        },
        {
          "id": "rel-slack-bot-feedback-uses-slack-thread",
          "from": "slack-bot-feedback",
          "to": "slack-thread",
          "phrase": "is posted into",
          "category": "uses",
          "description": "Slack bot feedback is posted into a specific Slack thread, identified by a channel and a root thread timestamp (rootTs)."
        },
        {
          "id": "rel-slack-bot-feedback-represents-system-response",
          "from": "slack-bot-feedback",
          "to": "system-response",
          "phrase": "represents",
          "category": "represents",
          "description": "Slack bot feedback represents the system’s visible response to a user’s data request in Slack, including greetings, status updates, and results."
        },
        {
          "id": "rel-slack-bot-feedback-has-message-text",
          "from": "slack-bot-feedback",
          "to": "slack-message-text",
          "phrase": "has",
          "category": "part_of",
          "description": "Each Slack bot feedback message includes human-readable text content when posted as a text message."
        },
        {
          "id": "rel-slack-bot-feedback-has-message-blocks",
          "from": "slack-bot-feedback",
          "to": "slack-message-blocks",
          "phrase": "may include",
          "category": "part_of",
          "description": "Some Slack bot feedback messages are composed of structured Slack blocks instead of or in addition to plain text."
        },
        {
          "id": "rel-slack-bot-feedback-adds-robot-reaction",
          "from": "slack-bot-feedback",
          "to": "slack-reaction",
          "phrase": "adds",
          "category": "causes",
          "description": "Slack bot feedback can take the form of adding a 'robot_face' reaction to the root message of a Slack thread."
        },
        {
          "id": "rel-slack-bot-feedback-generates-debug-event",
          "from": "slack-bot-feedback",
          "to": "debug-event",
          "phrase": "generates",
          "category": "causes",
          "description": "When the system posts a Slack bot feedback message, it generates a corresponding debug event of type 'outgoing_slack_message' for that thread."
        },
        {
          "id": "rel-slack-bot-feedback-uses-bot-token",
          "from": "slack-bot-feedback",
          "to": "slack-bot-token",
          "phrase": "uses",
          "category": "uses",
          "description": "Slack bot feedback is sent via the Slack Web API using the configured bot token."
        },
        {
          "id": "rel-slack-bot-feedback-associated-with-root-message",
          "from": "slack-bot-feedback",
          "to": "root-slack-message",
          "phrase": "is associated with",
          "category": "part_of",
          "description": "Slack bot feedback is associated with a root Slack message in a channel, identified by its timestamp (rootTs), and appears as a reaction or a threaded reply to that root message."
        },
        {
          "id": "rel-slack-robot-reaction-thread-root-message",
          "from": "slack-robot-reaction",
          "to": "slack-thread-root-message",
          "phrase": "is attached to",
          "category": "part_of",
          "description": "The robot reaction is attached to the root message of a Slack thread, identified by its timestamp (`rootTs`)."
        },
        {
          "id": "rel-slack-robot-reaction-slack-channel",
          "from": "slack-robot-reaction",
          "to": "slack-channel",
          "phrase": "occurs in",
          "category": "part_of",
          "description": "Each robot reaction occurs within a specific Slack channel, identified by the `channel` parameter when calling the Slack API."
        },
        {
          "id": "rel-slack-robot-reaction-slack-bot",
          "from": "slack-robot-reaction",
          "to": "slack-bot",
          "phrase": "is created by",
          "category": "causes",
          "description": "The Slack bot (using the bot token) creates the robot reaction by calling the Slack Web API `reactions.add` endpoint."
        },
        {
          "id": "rel-slack-robot-reaction-slack-api-call",
          "from": "slack-robot-reaction",
          "to": "slack-api-call",
          "phrase": "is implemented as",
          "category": "represents",
          "description": "In practice, adding a robot reaction is realized as a Slack API call to `reactions.add` with the `robot_face` emoji name."
        },
        {
          "id": "rel-slack-robot-reaction-slack-data-request-thread",
          "from": "slack-robot-reaction",
          "to": "slack-data-request-thread",
          "phrase": "marks",
          "category": "represents",
          "description": "The robot reaction marks a Slack data request thread as being noticed and processed by the system."
        },
        {
          "id": "rel-ingest-event-represents-envelope",
          "from": "ingest-event",
          "to": "event-envelope",
          "phrase": "is represented by",
          "category": "represents",
          "description": "An ingest event is represented in the system as an EventEnvelope structure containing identifiers and basic message metadata (eventId, channel, ts, threadTs, user, text)."
        },
        {
          "id": "rel-ingest-event-uses-event-id",
          "from": "ingest-event",
          "to": "event-id",
          "phrase": "uses",
          "category": "uses",
          "description": "An ingest event uses its eventId as a unique key for idempotency and deduplication in the events collection."
        },
        {
          "id": "rel-ingest-event-causes-dedupe-record",
          "from": "ingest-event",
          "to": "deduplication-record",
          "phrase": "creates",
          "category": "causes",
          "description": "When an ingest event is seen for the first time, it causes creation of a deduplication record in the events collection with seenAt and expireAt timestamps."
        },
        {
          "id": "rel-ingest-event-precedes-work-queueing",
          "from": "ingest-event",
          "to": "queued-work",
          "phrase": "precedes",
          "category": "precedes",
          "description": "A valid, non-duplicate ingest event precedes the creation of queued work items that will be processed by downstream workers."
        },
        {
          "id": "rel-ingest-event-causes-task-payload",
          "from": "ingest-event",
          "to": "task-payload",
          "phrase": "is transformed into",
          "category": "causes",
          "description": "An ingest event is transformed into a TaskPayload that captures the channel, rootTs, messageTs, text, user, and metadata for downstream LLM or data request processing."
        },
        {
          "id": "rel-ingest-event-enables-worker-task",
          "from": "ingest-event",
          "to": "worker-task",
          "phrase": "enables creation of",
          "category": "enables",
          "description": "A non-duplicate ingest event enables creation of a worker task in the task queue, which will POST the TaskPayload to the worker endpoint."
        }
      ],
      "rules": [
        {
          "id": "rule-slack-user-optional-on-event-envelope",
          "title": "Slack user may be absent on some events",
          "text": "For an EventEnvelope, the `user` field representing the Slack user is optional, meaning some Slack events processed by the system may not be associated with a specific Slack user.",
          "kind": "assumption",
          "conceptIds": [
            "slack-user"
          ]
        },
        {
          "id": "rule-slack-user-optional-on-task-payload",
          "title": "Slack user may be absent on some task payloads",
          "text": "For a TaskPayload derived from Slack activity, the `user` field representing the Slack user is optional, so not all tasks are required to track the originating Slack user.",
          "kind": "assumption",
          "conceptIds": [
            "slack-user"
          ]
        },
        {
          "id": "rule-test-execution-must-have-user-id",
          "title": "Test execution must be associated with a user",
          "text": "Every TestExecutionTaskPayload must include a `userId`, ensuring that each test execution is associated with a specific user.",
          "kind": "constraint",
          "conceptIds": [
            "slack-user"
          ]
        },
        {
          "id": "rule-slack-channel-required-for-slack-ops",
          "title": "Slack channel is required for Slack operations",
          "text": "Any operation that posts messages or reactions to Slack must specify a valid Slack channel identifier.",
          "kind": "constraint",
          "conceptIds": [
            "slack-channel"
          ]
        },
        {
          "id": "rule-slack-channel-immutable-per-event",
          "title": "EventEnvelope channel is immutable per event",
          "text": "For a given EventEnvelope, the channel value identifies the Slack channel where the event occurred and does not change during processing.",
          "kind": "assumption",
          "conceptIds": [
            "slack-channel"
          ]
        },
        {
          "id": "rule-slack-channel-immutable-per-task",
          "title": "TaskPayload channel is immutable per task",
          "text": "For a given TaskPayload, the channel value identifies the Slack channel where the task’s Slack interactions will occur and remains constant for that task.",
          "kind": "assumption",
          "conceptIds": [
            "slack-channel"
          ]
        },
        {
          "id": "rule-thread-identified-by-rootts",
          "title": "Slack thread must be identified by rootTs",
          "text": "Every Slack thread that the system tracks as a data request context must have a rootTs value corresponding to the timestamp of the root Slack message of that thread.",
          "kind": "constraint",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-thread-flags-once",
          "title": "Per-thread flags are set at most once",
          "text": "Per-thread flags such as 'reacted' and 'greeted' are managed transactionally so that each flag is only set once per Slack thread, preventing duplicate reactions or greetings in the same thread.",
          "kind": "invariant",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-thread-collection-key",
          "title": "Slack thread document key is rootTs",
          "text": "In the 'threads' collection, each Slack thread document is keyed by the rootTs of the thread, ensuring a one-to-one mapping between a Slack thread and its stored per-thread state.",
          "kind": "assumption",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-thread-shares-context",
          "title": "All messages under a rootTs share a single request context",
          "text": "All Slack messages and events that belong to the same rootTs are treated as part of a single data request context represented by one Slack thread.",
          "kind": "assumption",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-slack-message-requires-channel-and-thread",
          "title": "Slack message must specify channel and thread",
          "text": "When the system posts a Slack message into a thread, it must specify both the channel ID and the root thread timestamp (thread_ts/rootTs).",
          "kind": "constraint",
          "conceptIds": [
            "slack-message"
          ]
        },
        {
          "id": "rule-slack-message-debug-event",
          "title": "Outgoing Slack messages are logged as debug events",
          "text": "Every outgoing Slack message posted by the bot into a thread is recorded as a debug event with type 'outgoing_slack_message', including channel, threadTs, text, messageType, and a timestamp.",
          "kind": "policy",
          "conceptIds": [
            "slack-message"
          ]
        },
        {
          "id": "rule-slack-message-content-type",
          "title": "Slack message content type",
          "text": "A Slack message sent by the system must contain either plain text or block content; text messages are recorded with messageType 'text'.",
          "kind": "assumption",
          "conceptIds": [
            "slack-message"
          ]
        },
        {
          "id": "rule-data-request-must-be-classified",
          "title": "Data Request must be positively classified",
          "text": "A Slack conversation is treated as a Data Request only if the LLM classification verdict has isDataRequest = true; otherwise, no Data Request is instantiated or processed.",
          "kind": "constraint",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-data-request-derived-from-slack-content",
          "title": "Data Request must be derived from Slack thread and message",
          "text": "A Data Request must be derived from at least one Slack thread and a specific Slack message within that thread, which are provided as fullThread and specificMessage inputs to the LLM.",
          "kind": "invariant",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-data-request-artifacts-updated-on-new-messages",
          "title": "Data Request artifacts must be updated when new information arrives",
          "text": "Whenever a new user reply is posted in the Slack thread, the system must re-run the iteration process to update the Data Request artifacts so they reflect the newest information.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-direct-answer-only-for-meta-questions",
          "title": "Direct answers only for meta questions about data structures and terminology",
          "text": "The directAnswer artifact may only be used for questions about field meanings, table structures, business terminology, or how data is organized. If the question involves actual data values, metrics, numbers, counts, or specific data content, it must be treated as a Data Request and represented via the request and/or stepByStepInstructions artifacts instead.",
          "kind": "constraint",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-clarifying-questions-removed-when-answered",
          "title": "Clarifying questions must be removed once fully answered",
          "text": "If the clarifying questions associated with a Data Request are fully answered by subsequent Slack messages, they must be removed from the artifacts during iteration.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-self-service-steps-when-possible",
          "title": "Provide self-service instructions when feasible",
          "text": "If a Data Request can be fulfilled by the user via self-service tools (e.g., Looker), the artifacts should include step-by-step instructions instead of or in addition to a direct answer.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-data-request-classification-requires-thread",
          "title": "Classification requires a Slack thread context",
          "text": "Data request classification must be provided with the full Slack thread as an ordered list of messages; if no messages are provided, the classification operates on an empty thread representation.",
          "kind": "assumption",
          "conceptIds": [
            "data-request-classification"
          ]
        },
        {
          "id": "rule-data-request-classification-verdict-shape",
          "title": "Classification produces a structured verdict",
          "text": "Data request classification must produce a verdict containing three fields: isDataRequest (boolean), reason (string), and confidence (number).",
          "kind": "invariant",
          "conceptIds": [
            "data-request-classification"
          ]
        },
        {
          "id": "rule-data-request-classification-template-binding",
          "title": "Classification uses the active 'is_data_request' template",
          "text": "Data request classification must fetch the currently active 'is_data_request' prompt template and render it with the full thread and specific message before invoking the generative model.",
          "kind": "policy",
          "conceptIds": [
            "data-request-classification"
          ]
        },
        {
          "id": "rule-data-request-classification-model-selection",
          "title": "Classification uses the template's configured model with fallback",
          "text": "Data request classification should use the generative model specified by the active template; if the template does not specify a model, it falls back to a default model name.",
          "kind": "policy",
          "conceptIds": [
            "data-request-classification"
          ]
        },
        {
          "id": "rule-data-request-classification-error-recording",
          "title": "Classification records model execution errors when debug context is present",
          "text": "If a debug context is available, any error during generative model execution must be recorded as a high-severity error associated with the root Slack thread in the debug log store.",
          "kind": "policy",
          "conceptIds": [
            "data-request-classification"
          ]
        },
        {
          "id": "rule-data-request-iteration-removes-answered-questions",
          "title": "Remove clarifying questions once fully answered",
          "text": "If clarifying questions are fully answered in the latest Slack messages, the data request iteration must remove those questions from the clarifyingQuestions artifact.",
          "kind": "policy",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "rule-data-request-iteration-refines-clear-request",
          "title": "Refine request when it becomes clear",
          "text": "When the user’s intent is clear based on the Slack thread and latest reply, the data request iteration should refine and improve the request artifact to accurately capture the clarified requirements.",
          "kind": "policy",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "rule-data-request-iteration-provides-self-service-steps-when-possible",
          "title": "Provide self-service Looker instructions when feasible",
          "text": "If self-service access to the requested data is possible, the data request iteration should provide step-by-step Looker instructions in the stepByStepInstructions artifact.",
          "kind": "policy",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "rule-data-request-iteration-direct-answer-only-for-meta-questions",
          "title": "Use directAnswer only for meta questions",
          "text": "The data request iteration may populate the directAnswer artifact only for questions about field meanings, business terminology, or data structures, and must not use directAnswer for questions about actual data values, metrics, numbers, counts, or specific data content.",
          "kind": "constraint",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "rule-data-request-iteration-treat-data-questions-as-requests",
          "title": "Treat data-value questions as data requests",
          "text": "If the user’s question involves actual data values, metrics, numbers, counts, or specific data content, the data request iteration must treat it as a data request and use the request and stepByStepInstructions artifacts instead of directAnswer.",
          "kind": "constraint",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "rule-data-request-iteration-updates-all-artifacts-together",
          "title": "Update all relevant artifacts on each iteration",
          "text": "On each invocation, the data request iteration should consider and update all relevant artifacts (request, clarifyingQuestions, stepByStepInstructions, directAnswer) so they remain consistent with the latest Slack thread and user reply.",
          "kind": "assumption",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "rule-review-produces-structured-output",
          "title": "Review must produce structured review result",
          "text": "Each data request review must return a structured ReviewResult object containing fields for the clarified request, clarifying questions, step-by-step instructions, and a direct answer.",
          "kind": "invariant",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-clarifying-questions-gate-user-view",
          "title": "Clarifying questions gate what is shown to the user",
          "text": "If a data request review produces any clarifying questions, only those clarifying questions are shown to the user at that stage; other artifacts from the review are retained for later iteration.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-no-clarifying-questions-show-instructions-or-request",
          "title": "Absence of clarifying questions determines what is shown",
          "text": "When a data request review produces no clarifying questions, the system shows the user the step-by-step self-service instructions if they are present; otherwise, it shows the well-documented request produced by the review.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-direct-answer-scope",
          "title": "Direct answer limited to meta questions",
          "text": "Direct answers produced during data request review must only address meta questions about field meanings, business terminology, or data structures, and must not provide actual data values, metrics, or numbers.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-review-must-call-out-assumptions",
          "title": "Review must explicitly call out assumptions",
          "text": "During data request review, the assistant should make reasonable assumptions to clarify the request but must explicitly call out those assumptions so they can be corrected if wrong.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-review-aims-for-unambiguous-request",
          "title": "Review aims for a well-documented, unambiguous request",
          "text": "The primary goal of data request review is to transform the user's initial request into a clear, well-documented, and unambiguous description that refers to existing data in a way that is simple for an analyst to execute.",
          "kind": "assumption",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-slack-bot-feedback-requires-bot-token",
          "title": "Slack bot feedback requires a configured bot token",
          "text": "Slack bot feedback can only be sent if a Slack bot token (SLACK_BOT_TOKEN) is configured; otherwise, attempts to send feedback must fail.",
          "kind": "constraint",
          "conceptIds": [
            "slack-bot-feedback"
          ]
        },
        {
          "id": "rule-slack-bot-feedback-must-target-thread",
          "title": "Slack bot feedback must target a specific thread",
          "text": "Each Slack bot feedback item must specify both a Slack channel and a root thread timestamp (rootTs) so that the reaction or message is attached to the correct conversation thread.",
          "kind": "invariant",
          "conceptIds": [
            "slack-bot-feedback"
          ]
        },
        {
          "id": "rule-slack-bot-feedback-text-messages-have-text",
          "title": "Text-based Slack bot feedback must include text content",
          "text": "When Slack bot feedback is sent as a text message, it must include a non-empty text field describing the greeting, status, or result.",
          "kind": "assumption",
          "conceptIds": [
            "slack-bot-feedback"
          ]
        },
        {
          "id": "rule-slack-bot-feedback-debug-event-recording",
          "title": "Slack bot feedback attempts to record debug events",
          "text": "For each Slack bot feedback message posted, the system attempts to record a debug event of type 'outgoing_slack_message' containing the channel, thread timestamp, text, and message type.",
          "kind": "policy",
          "conceptIds": [
            "slack-bot-feedback"
          ]
        },
        {
          "id": "rule-slack-robot-reaction-emoji-name",
          "title": "Robot reaction must use the robot_face emoji",
          "text": "A Slack robot reaction is always represented by the :robot_face: emoji when added to a message.",
          "kind": "invariant",
          "conceptIds": [
            "slack-robot-reaction"
          ]
        },
        {
          "id": "rule-slack-robot-reaction-targets-root-message",
          "title": "Robot reaction targets the thread root message",
          "text": "A Slack robot reaction is added to the root message of a thread, using the root message timestamp as the reaction target.",
          "kind": "invariant",
          "conceptIds": [
            "slack-robot-reaction"
          ]
        },
        {
          "id": "rule-slack-robot-reaction-bot-token-required",
          "title": "Robot reaction requires a valid bot token",
          "text": "Adding a Slack robot reaction requires a valid Slack bot token; if the bot token is not set, the operation fails.",
          "kind": "constraint",
          "conceptIds": [
            "slack-robot-reaction"
          ]
        },
        {
          "id": "rule-slack-robot-reaction-already-reacted-tolerated",
          "title": "Robot reaction tolerates already_reacted Slack errors",
          "text": "If Slack reports that the bot has already added the robot reaction to a message (error code \"already_reacted\"), this is treated as a non-fatal condition and does not cause the operation to fail.",
          "kind": "policy",
          "conceptIds": [
            "slack-robot-reaction"
          ]
        },
        {
          "id": "rule-ingest-event-must-have-id",
          "title": "Ingest event must have a unique eventId",
          "text": "Every ingest event must provide an eventId that is used as the unique key in the events collection for idempotency and deduplication.",
          "kind": "invariant",
          "conceptIds": [
            "ingest-event"
          ]
        },
        {
          "id": "rule-ingest-event-deduplication-window",
          "title": "Ingest event deduplication is time-bounded",
          "text": "An ingest event is considered a potential duplicate only within a defined TTL window (currently 1 hour) from its first observation, after which its deduplication record expires.",
          "kind": "policy",
          "conceptIds": [
            "ingest-event"
          ]
        },
        {
          "id": "rule-ingest-event-first-write-only",
          "title": "Only first occurrence of an ingest event is processed",
          "text": "Only the first occurrence of an ingest event with a given eventId is treated as new and allowed to proceed to work queuing; subsequent occurrences with the same eventId are treated as duplicates and must not enqueue additional work.",
          "kind": "constraint",
          "conceptIds": [
            "ingest-event"
          ]
        },
        {
          "id": "rule-ingest-event-requires-queue-config",
          "title": "Ingest event processing requires task queue configuration",
          "text": "For an ingest event to result in queued work, the system must have valid worker URL, project ID, region, and queue name configured; otherwise, work cannot be enqueued for that event.",
          "kind": "assumption",
          "conceptIds": [
            "ingest-event"
          ]
        }
      ],
      "lifecycles": [
        {
          "id": "lifecycle-thread-greeting-reaction",
          "subjectConceptId": "slack-thread",
          "stateConceptIds": [
            "thread-not-reacted-or-greeted",
            "thread-reacted-and-or-greeted"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "thread-not-reacted-or-greeted",
          "terminalStateIds": [
            "thread-reacted-and-or-greeted"
          ]
        },
        {
          "id": "lifecycle-thread-processing-status",
          "subjectConceptId": "slack-thread",
          "stateConceptIds": [
            "thread-status-unknown",
            "thread-status-updated"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "thread-status-unknown",
          "terminalStateIds": [
            "thread-status-updated"
          ]
        },
        {
          "id": "lifecycle-data-request-implicit",
          "subjectConceptId": "data-request",
          "stateConceptIds": [
            "slack-thread-without-data-request",
            "classified-as-data-request",
            "artifacts-initialized",
            "artifacts-refined"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "slack-thread-without-data-request",
          "terminalStateIds": [
            "artifacts-refined"
          ]
        },
        {
          "id": "lifecycle-ingest-event-basic",
          "subjectConceptId": "ingest-event",
          "stateConceptIds": [
            "ingest-event-received",
            "ingest-event-deduplicated-new",
            "ingest-event-deduplicated-duplicate",
            "ingest-event-queued"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "ingest-event-received",
          "terminalStateIds": [
            "ingest-event-deduplicated-duplicate",
            "ingest-event-queued"
          ]
        }
      ],
      "views": [
        {
          "id": "slack-conversation-context",
          "name": "Slack conversation context",
          "kind": "overview",
          "description": "Shows how Slack users, channels, threads, and messages relate, forming the conversational context from which data requests are derived.",
          "conceptIds": [
            "slack-user",
            "slack-channel",
            "slack-thread",
            "slack-message",
            "slack-robot-reaction",
            "ingest-event"
          ],
          "relationshipIds": [
            "rel-slack-user-sends-event-envelope",
            "rel-slack-user-receives-thread-messages",
            "rel-slack-channel-contains-threads",
            "rel-slack-channel-receives-bot-reactions",
            "rel-slack-message-part-of-thread",
            "rel-slack-message-part-of-channel",
            "rel-slack-message-uses-reaction",
            "rel-slack-robot-reaction-thread-root-message",
            "rel-slack-robot-reaction-slack-channel",
            "rel-ingest-event-represents-envelope"
          ]
        },
        {
          "id": "from-thread-to-data-request",
          "name": "From Slack thread to structured data request",
          "kind": "lifecycle",
          "description": "Explains how Slack threads and messages become structured data requests and associated artifacts.",
          "conceptIds": [
            "slack-thread",
            "slack-message",
            "slack-user",
            "data-request",
            "data-request-artifact",
            "data-request-artifact-type"
          ],
          "relationshipIds": [
            "rel-slack-message-part-of-thread",
            "rel-slack-user-creates-data-request",
            "rel-data-request-derived-from-thread",
            "rel-data-request-derived-from-message",
            "rel-data-request-has-artifacts",
            "rel-data-request-artifact-types",
            "rel-data-request-logged-as-debug-event"
          ]
        },
        {
          "id": "classification-gates-processing",
          "name": "Data request classification and gating",
          "kind": "implementation",
          "description": "Shows how a Slack thread is classified as a data request using LLMs and how that verdict gates downstream processing.",
          "conceptIds": [
            "slack-thread",
            "slack-message",
            "data-request-classification",
            "data-request-verdict",
            "prompt-template",
            "generative-model",
            "downstream-data-request-processing"
          ],
          "relationshipIds": [
            "rel-data-request-classification-uses-slack-thread",
            "rel-data-request-classification-uses-specific-message",
            "rel-data-request-classification-uses-template",
            "rel-data-request-classification-uses-generative-model",
            "rel-data-request-classification-produces-verdict",
            "rel-data-request-classification-precedes-downstream-processing",
            "rel-data-request-classification-uses-debug-context",
            "rel-data-request-classification-uses-firestore"
          ]
        },
        {
          "id": "llm-iteration-on-request",
          "name": "LLM-driven data request iteration",
          "kind": "lifecycle",
          "description": "Focuses on how LLMs iteratively refine a data request and produce clarifications, answers, and instructions.",
          "conceptIds": [
            "data-request",
            "data-request-iteration",
            "generative-model",
            "direct-answer",
            "clarifying-questions",
            "step-by-step-instructions",
            "prior-artifacts"
          ],
          "relationshipIds": [
            "rel-data-request-iteration-refines-data-request",
            "rel-data-request-iteration-refines-artifacts",
            "rel-data-request-iteration-uses-slack-thread",
            "rel-data-request-iteration-uses-prior-artifacts",
            "rel-data-request-iteration-uses-llm",
            "rel-data-request-iteration-produces-direct-answer",
            "rel-data-request-iteration-produces-clarifying-questions",
            "rel-data-request-iteration-produces-step-by-step-instructions",
            "rel-data-request-iteration-part-of-slack-data-request-flow"
          ]
        },
        {
          "id": "review-and-user-facing-outcome",
          "name": "Review and user-facing outcome",
          "kind": "lifecycle",
          "description": "Shows how a data request is reviewed via LLMs and how the review result shapes what is ultimately presented to the user.",
          "conceptIds": [
            "data-request",
            "data-request-review",
            "llm-model",
            "review-context",
            "review-result",
            "clarifying-questions",
            "direct-answer",
            "documented-data-request"
          ],
          "relationshipIds": [
            "rel-data-request-review-uses-llm",
            "rel-data-request-review-uses-context",
            "rel-data-request-review-produces-review-result",
            "rel-data-request-review-intermediary-between-user-and-data-team",
            "rel-review-result-has-clarifying-questions",
            "rel-review-result-has-direct-answer",
            "rel-review-result-has-documented-request",
            "rel-data-request-review-precedes-user-presentation"
          ]
        },
        {
          "id": "bot-feedback-loop-in-slack",
          "name": "Slack bot feedback loop",
          "kind": "overview",
          "description": "Illustrates how system responses and status are communicated back into Slack via bot messages and reactions.",
          "conceptIds": [
            "slack-thread",
            "slack-bot-feedback",
            "slack-message-text",
            "slack-message-blocks",
            "slack-reaction",
            "debug-event",
            "slack-bot-token",
            "root-slack-message"
          ],
          "relationshipIds": [
            "rel-slack-bot-feedback-uses-slack-thread",
            "rel-slack-bot-feedback-represents-system-response",
            "rel-slack-bot-feedback-has-message-text",
            "rel-slack-bot-feedback-has-message-blocks",
            "rel-slack-bot-feedback-adds-robot-reaction",
            "rel-slack-bot-feedback-generates-debug-event",
            "rel-slack-bot-feedback-uses-bot-token",
            "rel-slack-bot-feedback-associated-with-root-message"
          ]
        },
        {
          "id": "ingest-and-queueing",
          "name": "Ingest and queueing pipeline",
          "kind": "implementation",
          "description": "Shows how incoming Slack events are ingested, deduplicated, and transformed into queued work and task payloads.",
          "conceptIds": [
            "ingest-event",
            "event-envelope",
            "event-id",
            "deduplication-record",
            "queued-work",
            "task-payload",
            "worker-task"
          ],
          "relationshipIds": [
            "rel-ingest-event-represents-envelope",
            "rel-ingest-event-uses-event-id",
            "rel-ingest-event-causes-dedupe-record",
            "rel-ingest-event-precedes-work-queueing",
            "rel-ingest-event-causes-task-payload",
            "rel-ingest-event-enables-worker-task",
            "rel-slack-user-initiates-task-payload",
            "rel-slack-user-initiates-test-execution"
          ]
        }
      ],
      "storyViews": [
        {
          "id": "simple-data-question-classified-and-answered",
          "name": "Simple data question is classified and answered in Slack",
          "kind": "user_flow",
          "description": "A Slack user asks a straightforward data question, which is ingested, classified as a valid data request, iterated on by an LLM, and answered directly in the same Slack thread.",
          "tags": [
            "happy-path",
            "classification",
            "iteration",
            "bot-feedback"
          ],
          "focusConceptId": "data-request",
          "steps": [
            {
              "id": "user-posts-question-in-channel",
              "index": 0,
              "title": "User posts a data question in a Slack channel",
              "narrative": "A Slack user types a simple question like “What were signups last week?” in a Slack channel, creating a root Slack message and thread context.",
              "conceptIds": [
                "slack-user",
                "slack-channel",
                "slack-thread",
                "slack-message"
              ],
              "relationshipIds": [
                "rel-slack-message-part-of-channel",
                "rel-slack-message-part-of-thread",
                "rel-thread-uses-user",
                "rel-thread-uses-channel"
              ],
              "primaryConceptIds": [
                "slack-user",
                "slack-thread"
              ],
              "primaryRelationshipIds": [
                "rel-slack-message-part-of-thread"
              ]
            },
            {
              "id": "event-is-ingested-and-thread-identified",
              "index": 1,
              "title": "Slack event is ingested and tied to the thread",
              "narrative": "The new message generates an ingest event, which is deduplicated and transformed into queued work that references the Slack thread.",
              "conceptIds": [
                "ingest-event",
                "slack-thread",
                "slack-message"
              ],
              "relationshipIds": [
                "rel-ingest-event-represents-envelope",
                "rel-ingest-event-causes-dedupe-record",
                "rel-ingest-event-precedes-work-queueing",
                "rel-thread-linked-from-event-envelope"
              ],
              "primaryConceptIds": [
                "ingest-event",
                "slack-thread"
              ],
              "primaryRelationshipIds": [
                "rel-ingest-event-precedes-work-queueing"
              ]
            },
            {
              "id": "thread-is-classified-as-data-request",
              "index": 2,
              "title": "Thread is classified as a data request",
              "narrative": "The system runs data request classification on the Slack thread and root message, using a prompt template and generative model to produce a verdict that this is a valid data request.",
              "conceptIds": [
                "data-request-classification",
                "slack-thread",
                "slack-message",
                "generative-model"
              ],
              "relationshipIds": [
                "rel-data-request-classification-uses-slack-thread",
                "rel-data-request-classification-uses-specific-message",
                "rel-data-request-classification-uses-template",
                "rel-data-request-classification-uses-generative-model",
                "rel-data-request-classification-produces-verdict"
              ],
              "primaryConceptIds": [
                "data-request-classification"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-classification-produces-verdict"
              ]
            },
            {
              "id": "data-request-is-created-from-thread",
              "index": 3,
              "title": "Structured data request is created from the thread",
              "narrative": "Based on the classification verdict, the system derives a structured data request from the Slack thread and the user’s message, logging it for debugging and downstream processing.",
              "conceptIds": [
                "data-request",
                "slack-thread",
                "slack-message"
              ],
              "relationshipIds": [
                "rel-data-request-derived-from-thread",
                "rel-data-request-derived-from-message",
                "rel-slack-user-creates-data-request",
                "rel-data-request-logged-as-debug-event"
              ],
              "primaryConceptIds": [
                "data-request"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-derived-from-thread"
              ]
            },
            {
              "id": "llm-iteration-produces-direct-answer",
              "index": 4,
              "title": "LLM iteration produces a direct answer",
              "narrative": "The data request enters an iteration process that uses the generative model and prior artifacts to refine the request and generate a direct answer for the user.",
              "conceptIds": [
                "data-request-iteration",
                "data-request",
                "generative-model"
              ],
              "relationshipIds": [
                "rel-data-request-iteration-uses-slack-thread",
                "rel-data-request-iteration-uses-prior-artifacts",
                "rel-data-request-iteration-uses-llm",
                "rel-data-request-iteration-refines-data-request",
                "rel-data-request-iteration-produces-direct-answer"
              ],
              "primaryConceptIds": [
                "data-request-iteration"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-iteration-produces-direct-answer"
              ]
            },
            {
              "id": "bot-posts-answer-in-thread",
              "index": 5,
              "title": "Slack bot posts the answer back in the thread",
              "narrative": "The system sends Slack bot feedback into the same thread, posting a message with the direct answer and marking the thread as processed with a robot reaction.",
              "conceptIds": [
                "slack-bot-feedback",
                "slack-thread",
                "slack-message",
                "slack-robot-reaction"
              ],
              "relationshipIds": [
                "rel-slack-bot-feedback-uses-slack-thread",
                "rel-slack-bot-feedback-has-message-text",
                "rel-slack-bot-feedback-adds-robot-reaction",
                "rel-slack-message-represents-bot-response",
                "rel-slack-message-uses-reaction"
              ],
              "primaryConceptIds": [
                "slack-bot-feedback"
              ],
              "primaryRelationshipIds": [
                "rel-slack-bot-feedback-uses-slack-thread"
              ]
            }
          ]
        },
        {
          "id": "iterative-clarification-of-ambiguous-request",
          "name": "Iterative clarification of an ambiguous data request",
          "kind": "user_flow",
          "description": "A user posts an ambiguous request, which is recognized as a data request but requires multiple LLM-driven iterations and clarifying questions before a final answer is returned.",
          "tags": [
            "iteration",
            "clarifying-questions",
            "conversation"
          ],
          "focusConceptId": "data-request-iteration",
          "steps": [
            {
              "id": "user-posts-ambiguous-request",
              "index": 0,
              "title": "User posts an ambiguous data request in a thread",
              "narrative": "A Slack user writes “Can you pull last quarter’s performance?” in a channel, creating a Slack thread whose meaning is not yet fully clear.",
              "conceptIds": [
                "slack-user",
                "slack-channel",
                "slack-thread",
                "slack-message"
              ],
              "relationshipIds": [
                "rel-slack-message-part-of-channel",
                "rel-slack-message-part-of-thread",
                "rel-thread-uses-user",
                "rel-thread-uses-text"
              ],
              "primaryConceptIds": [
                "slack-thread"
              ],
              "primaryRelationshipIds": [
                "rel-thread-uses-text"
              ]
            },
            {
              "id": "classification-identifies-request-but-needs-detail",
              "index": 1,
              "title": "Classification identifies a data request that lacks detail",
              "narrative": "The classification process analyzes the thread and root message with a generative model, producing a verdict that it is a data request but missing key parameters.",
              "conceptIds": [
                "data-request-classification",
                "slack-thread",
                "slack-message",
                "generative-model"
              ],
              "relationshipIds": [
                "rel-data-request-classification-uses-slack-thread",
                "rel-data-request-classification-uses-specific-message",
                "rel-data-request-classification-uses-template",
                "rel-data-request-classification-uses-generative-model",
                "rel-data-request-classification-produces-verdict"
              ],
              "primaryConceptIds": [
                "data-request-classification"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-classification-produces-verdict"
              ]
            },
            {
              "id": "initial-data-request-and-artifacts-created",
              "index": 2,
              "title": "Initial data request and artifacts are created",
              "narrative": "The system derives a preliminary data request from the thread and message, creating artifacts that capture the current understanding and logging them for debugging.",
              "conceptIds": [
                "data-request",
                "slack-thread",
                "slack-message"
              ],
              "relationshipIds": [
                "rel-data-request-derived-from-thread",
                "rel-data-request-derived-from-message",
                "rel-data-request-has-artifacts",
                "rel-data-request-logged-as-debug-event"
              ],
              "primaryConceptIds": [
                "data-request"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-has-artifacts"
              ]
            },
            {
              "id": "iteration-generates-clarifying-questions",
              "index": 3,
              "title": "Iteration generates clarifying questions for the user",
              "narrative": "A data request iteration uses the generative model and prior artifacts to propose clarifying questions instead of a direct answer, updating the data request definition.",
              "conceptIds": [
                "data-request-iteration",
                "data-request",
                "generative-model"
              ],
              "relationshipIds": [
                "rel-data-request-iteration-uses-prior-artifacts",
                "rel-data-request-iteration-uses-llm",
                "rel-data-request-iteration-refines-data-request",
                "rel-data-request-iteration-produces-clarifying-questions"
              ],
              "primaryConceptIds": [
                "data-request-iteration"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-iteration-produces-clarifying-questions"
              ]
            },
            {
              "id": "bot-posts-clarifying-questions-in-thread",
              "index": 4,
              "title": "Bot posts clarifying questions in the Slack thread",
              "narrative": "The system posts Slack bot feedback into the thread, asking the user to specify which metrics and regions they mean, and marks the thread as awaiting input.",
              "conceptIds": [
                "slack-bot-feedback",
                "slack-thread",
                "slack-message"
              ],
              "relationshipIds": [
                "rel-slack-bot-feedback-uses-slack-thread",
                "rel-slack-bot-feedback-has-message-text",
                "rel-slack-message-represents-bot-response"
              ],
              "primaryConceptIds": [
                "slack-bot-feedback"
              ],
              "primaryRelationshipIds": [
                "rel-slack-bot-feedback-has-message-text"
              ]
            },
            {
              "id": "user-responds-and-iteration-updates-request",
              "index": 5,
              "title": "User responds and iteration updates the data request",
              "narrative": "The user replies in the same thread with more detail; a new iteration run uses the updated thread and prior artifacts to refine the data request and now produce a direct answer.",
              "conceptIds": [
                "slack-thread",
                "slack-message",
                "data-request-iteration",
                "data-request"
              ],
              "relationshipIds": [
                "rel-slack-message-part-of-thread",
                "rel-data-request-iteration-uses-slack-thread",
                "rel-data-request-iteration-refines-artifacts",
                "rel-data-request-iteration-refines-data-request",
                "rel-data-request-iteration-produces-direct-answer"
              ],
              "primaryConceptIds": [
                "data-request-iteration"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-iteration-refines-data-request"
              ]
            },
            {
              "id": "final-answer-posted-to-thread",
              "index": 6,
              "title": "Final answer is posted back to the user",
              "narrative": "The bot posts a final Slack message with the clarified results, signaling completion with a robot reaction on the root message.",
              "conceptIds": [
                "slack-bot-feedback",
                "slack-thread",
                "slack-robot-reaction"
              ],
              "relationshipIds": [
                "rel-slack-bot-feedback-uses-slack-thread",
                "rel-slack-bot-feedback-adds-robot-reaction",
                "rel-slack-robot-reaction-thread-root-message"
              ],
              "primaryConceptIds": [
                "slack-bot-feedback"
              ],
              "primaryRelationshipIds": [
                "rel-slack-bot-feedback-adds-robot-reaction"
              ]
            }
          ]
        },
        {
          "id": "request-routed-through-review-before-user-response",
          "name": "Data request routed through review before user response",
          "kind": "system_flow",
          "description": "A more complex or sensitive data request is classified, then routed through a review activity that mediates between the user and downstream execution before a user-facing response is produced.",
          "tags": [
            "review",
            "governance",
            "mediation"
          ],
          "focusConceptId": "data-request-review",
          "steps": [
            {
              "id": "user-creates-complex-request",
              "index": 0,
              "title": "User creates a complex or sensitive data request",
              "narrative": "A Slack user posts a message asking for detailed user-level data, which becomes part of a Slack thread in a shared channel.",
              "conceptIds": [
                "slack-user",
                "slack-channel",
                "slack-thread",
                "slack-message"
              ],
              "relationshipIds": [
                "rel-slack-message-part-of-channel",
                "rel-slack-message-part-of-thread",
                "rel-thread-uses-user",
                "rel-slack-user-creates-data-request"
              ],
              "primaryConceptIds": [
                "slack-user",
                "slack-thread"
              ],
              "primaryRelationshipIds": [
                "rel-slack-user-creates-data-request"
              ]
            },
            {
              "id": "classification-gates-downstream-processing",
              "index": 1,
              "title": "Classification gates downstream processing",
              "narrative": "The classification activity analyzes the thread and message with a generative model, producing a verdict that this is a data request requiring additional review before execution.",
              "conceptIds": [
                "data-request-classification",
                "slack-thread",
                "slack-message",
                "generative-model"
              ],
              "relationshipIds": [
                "rel-data-request-classification-uses-slack-thread",
                "rel-data-request-classification-uses-specific-message",
                "rel-data-request-classification-uses-generative-model",
                "rel-data-request-classification-produces-verdict",
                "rel-data-request-classification-precedes-downstream-processing"
              ],
              "primaryConceptIds": [
                "data-request-classification"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-classification-precedes-downstream-processing"
              ]
            },
            {
              "id": "data-request-constructed-for-review",
              "index": 2,
              "title": "Data request is constructed and prepared for review",
              "narrative": "The system derives a structured data request from the Slack thread and message, capturing artifacts that will be used in the review process.",
              "conceptIds": [
                "data-request",
                "slack-thread",
                "slack-message"
              ],
              "relationshipIds": [
                "rel-data-request-derived-from-thread",
                "rel-data-request-derived-from-message",
                "rel-data-request-has-artifacts"
              ],
              "primaryConceptIds": [
                "data-request"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-derived-from-thread"
              ]
            },
            {
              "id": "review-assesses-feasibility-and-compliance",
              "index": 3,
              "title": "Data request review assesses feasibility and compliance",
              "narrative": "A data request review activity uses its review context and an LLM model to evaluate whether the request is appropriate, feasible, and compliant, producing a structured review result.",
              "conceptIds": [
                "data-request-review",
                "data-request"
              ],
              "relationshipIds": [
                "rel-data-request-review-uses-llm",
                "rel-data-request-review-uses-context",
                "rel-data-request-review-produces-review-result",
                "rel-data-request-review-intermediary-between-user-and-data-team"
              ],
              "primaryConceptIds": [
                "data-request-review"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-review-produces-review-result"
              ]
            },
            {
              "id": "review-result-contains-guidance-and-answers",
              "index": 4,
              "title": "Review result contains clarifications, instructions, or answers",
              "narrative": "The review result may include clarifying questions, self-service step-by-step instructions, a direct answer, and a documented version of the request for tracking.",
              "conceptIds": [
                "data-request-review"
              ],
              "relationshipIds": [
                "rel-review-result-has-clarifying-questions",
                "rel-review-result-has-step-by-step-instructions",
                "rel-review-result-has-direct-answer",
                "rel-review-result-has-documented-request"
              ],
              "primaryConceptIds": [
                "data-request-review"
              ],
              "primaryRelationshipIds": [
                "rel-review-result-has-direct-answer"
              ]
            },
            {
              "id": "user-facing-response-posted-in-slack",
              "index": 5,
              "title": "User-facing response is posted back in Slack",
              "narrative": "Following review, the system prepares a user-facing response and posts Slack bot feedback into the original thread, summarizing the outcome and any next steps.",
              "conceptIds": [
                "slack-bot-feedback",
                "slack-thread"
              ],
              "relationshipIds": [
                "rel-data-request-review-precedes-user-presentation",
                "rel-slack-bot-feedback-uses-slack-thread",
                "rel-slack-bot-feedback-has-message-text"
              ],
              "primaryConceptIds": [
                "slack-bot-feedback"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-review-precedes-user-presentation"
              ]
            }
          ]
        },
        {
          "id": "ingestion-and-deduplication-of-slack-events",
          "name": "Ingestion and deduplication of Slack events into the data request flow",
          "kind": "system_flow",
          "description": "Slack messages generate ingest events that are deduplicated, transformed into tasks, and associated with Slack threads to drive the data request flow.",
          "tags": [
            "ingestion",
            "deduplication",
            "queueing"
          ],
          "focusConceptId": "ingest-event",
          "steps": [
            {
              "id": "slack-message-generates-ingest-event",
              "index": 0,
              "title": "Slack message generates an ingest event",
              "narrative": "When a Slack user posts a message in a channel, Slack delivers an event envelope that is recorded as an ingest event in the system.",
              "conceptIds": [
                "slack-user",
                "slack-channel",
                "slack-message",
                "ingest-event"
              ],
              "relationshipIds": [
                "rel-slack-channel-has-events",
                "rel-slack-channel-receives-events",
                "rel-ingest-event-represents-envelope",
                "rel-ingest-event-uses-event-id"
              ],
              "primaryConceptIds": [
                "ingest-event"
              ],
              "primaryRelationshipIds": [
                "rel-ingest-event-represents-envelope"
              ]
            },
            {
              "id": "ingest-event-deduplicated",
              "index": 1,
              "title": "Ingest event is deduplicated",
              "narrative": "The system checks whether an ingest event with the same event ID has already been processed, creating or updating a deduplication record to avoid duplicate work.",
              "conceptIds": [
                "ingest-event"
              ],
              "relationshipIds": [
                "rel-ingest-event-uses-event-id",
                "rel-ingest-event-causes-dedupe-record"
              ],
              "primaryConceptIds": [
                "ingest-event"
              ],
              "primaryRelationshipIds": [
                "rel-ingest-event-causes-dedupe-record"
              ]
            },
            {
              "id": "ingest-event-transformed-into-task-payload",
              "index": 2,
              "title": "Ingest event is transformed into a task payload",
              "narrative": "A non-duplicate ingest event is transformed into a task payload that references the relevant Slack thread and channel for downstream processing.",
              "conceptIds": [
                "ingest-event",
                "slack-thread",
                "slack-channel"
              ],
              "relationshipIds": [
                "rel-ingest-event-causes-task-payload",
                "rel-thread-linked-from-task-payload",
                "rel-slack-channel-has-tasks"
              ],
              "primaryConceptIds": [
                "ingest-event"
              ],
              "primaryRelationshipIds": [
                "rel-ingest-event-causes-task-payload"
              ]
            },
            {
              "id": "work-is-queued-and-worker-task-created",
              "index": 3,
              "title": "Work is queued and a worker task is created",
              "narrative": "The task payload is added to a work queue, and a worker task is created to run classification, iteration, and other parts of the Slack data request flow.",
              "conceptIds": [
                "ingest-event"
              ],
              "relationshipIds": [
                "rel-ingest-event-precedes-work-queueing",
                "rel-ingest-event-enables-worker-task"
              ],
              "primaryConceptIds": [
                "ingest-event"
              ],
              "primaryRelationshipIds": [
                "rel-ingest-event-enables-worker-task"
              ]
            },
            {
              "id": "thread-context-assembled-for-processing",
              "index": 4,
              "title": "Slack thread context is assembled for processing",
              "narrative": "Using references from the task payload, the system aggregates Slack events into a Slack thread with status and flags, ready for classification and iteration.",
              "conceptIds": [
                "slack-thread",
                "slack-channel"
              ],
              "relationshipIds": [
                "rel-thread-aggregates-events",
                "rel-thread-has-status",
                "rel-thread-has-flags",
                "rel-thread-uses-channel"
              ],
              "primaryConceptIds": [
                "slack-thread"
              ],
              "primaryRelationshipIds": [
                "rel-thread-aggregates-events"
              ]
            }
          ]
        },
        {
          "id": "robot-reactions-as-thread-status-signals",
          "name": "Robot reactions signal thread processing status",
          "kind": "system_flow",
          "description": "The system uses robot reactions on Slack thread root messages to signal when a data request is being processed and when it has completed.",
          "tags": [
            "status",
            "robot-reaction",
            "ux"
          ],
          "focusConceptId": "slack-robot-reaction",
          "steps": [
            {
              "id": "thread-detected-as-data-request-thread",
              "index": 0,
              "title": "Thread is detected as a Slack data request thread",
              "narrative": "After classification determines that a Slack thread contains a data request, the system treats the thread as part of the Slack data request flow.",
              "conceptIds": [
                "slack-thread",
                "data-request-classification"
              ],
              "relationshipIds": [
                "rel-data-request-classification-uses-slack-thread",
                "rel-data-request-classification-precedes-downstream-processing"
              ],
              "primaryConceptIds": [
                "slack-thread"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-classification-uses-slack-thread"
              ]
            },
            {
              "id": "bot-adds-reaction-to-root-message",
              "index": 1,
              "title": "Bot adds a robot reaction to the root message",
              "narrative": "The Slack bot adds a robot reaction emoji to the thread’s root message in the channel, marking it as a Slack data request thread that is being processed.",
              "conceptIds": [
                "slack-robot-reaction",
                "slack-thread",
                "slack-channel"
              ],
              "relationshipIds": [
                "rel-slack-robot-reaction-thread-root-message",
                "rel-slack-robot-reaction-slack-channel",
                "rel-slack-robot-reaction-slack-bot",
                "rel-slack-robot-reaction-slack-data-request-thread"
              ],
              "primaryConceptIds": [
                "slack-robot-reaction"
              ],
              "primaryRelationshipIds": [
                "rel-slack-robot-reaction-thread-root-message"
              ]
            },
            {
              "id": "reaction-implemented-via-slack-api-call",
              "index": 2,
              "title": "Reaction is implemented via a Slack API call",
              "narrative": "Under the hood, the robot reaction is created by a Slack API call invoked as part of the Slack bot feedback process.",
              "conceptIds": [
                "slack-robot-reaction"
              ],
              "relationshipIds": [
                "rel-slack-robot-reaction-slack-api-call"
              ],
              "primaryConceptIds": [
                "slack-robot-reaction"
              ],
              "primaryRelationshipIds": [
                "rel-slack-robot-reaction-slack-api-call"
              ]
            },
            {
              "id": "processing-progress-communicated-with-feedback",
              "index": 3,
              "title": "Processing progress is communicated with bot feedback",
              "narrative": "As classification, iteration, and review progress, the system posts Slack bot feedback messages into the thread, keeping the user informed while the robot reaction remains as a status badge.",
              "conceptIds": [
                "slack-bot-feedback",
                "slack-thread",
                "slack-robot-reaction"
              ],
              "relationshipIds": [
                "rel-slack-bot-feedback-uses-slack-thread",
                "rel-slack-bot-feedback-has-message-text",
                "rel-slack-bot-feedback-adds-robot-reaction"
              ],
              "primaryConceptIds": [
                "slack-bot-feedback"
              ],
              "primaryRelationshipIds": [
                "rel-slack-bot-feedback-uses-slack-thread"
              ]
            },
            {
              "id": "reaction-signals-completion-of-request",
              "index": 4,
              "title": "Robot reaction signals completion of the data request",
              "narrative": "When the final answer or outcome is posted, the robot reaction on the root message reflects that the Slack data request thread has completed processing, giving users a quick visual cue.",
              "conceptIds": [
                "slack-robot-reaction",
                "slack-thread"
              ],
              "relationshipIds": [
                "rel-slack-robot-reaction-slack-data-request-thread",
                "rel-slack-robot-reaction-thread-root-message"
              ],
              "primaryConceptIds": [
                "slack-robot-reaction"
              ],
              "primaryRelationshipIds": [
                "rel-slack-robot-reaction-slack-data-request-thread"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "llm-orchestration",
      "title": "LLM Orchestration and Prompt Execution",
      "description": "How the system constructs prompts, calls LLMs, and records responses and debug information.",
      "concepts": [
        {
          "id": "llm-request",
          "label": "LLM request",
          "category": "thing",
          "description": "A structured prompt and parameters sent to a large language model to perform a task.",
          "aliases": [
            "LLMRequest",
            "LLM request",
            "LLM prompt request",
            "prompt request"
          ],
          "notes": "An LLM request is a structured description of how the system wants a large language model to respond. It bundles the user-facing prompt text with model selection and generation parameters (modelName, temperature, maxTokens). It is passed into the prompt execution/orchestration layer (executePrompt) and may be logged as part of a debug event. The request itself does not contain timing or result data; those belong to the corresponding LLMResponse and debug records."
        },
        {
          "id": "llm-response",
          "label": "LLM response",
          "category": "thing",
          "description": "The content and metadata returned by a large language model after executing a request.",
          "aliases": [
            "LLMResponse",
            "LLM response",
            "model response",
            "LLM output",
            "generated content"
          ],
          "notes": "An LLM response is the structured result returned after executing an LLMRequest via executePrompt. It bundles the primary generated text, the raw provider-specific response object, the elapsed time for the call, and the resolved model name actually used. It is JSON-serializable at the text/metadata level (though rawResponse may contain provider-specific structures) and is used both for downstream processing (e.g., parsing, evaluation) and for debugging/inspection in the UI."
        },
        {
          "id": "prompt-template",
          "label": "Prompt template",
          "category": "thing",
          "description": "A reusable, parameterized text pattern used to generate concrete prompts for LLMs.",
          "aliases": [
            "PromptTemplate",
            "prompt template",
            "template"
          ],
          "notes": "A Prompt Template is a reusable, versioned text pattern (typically containing EJS-style placeholders) that is parameterized by named variables and used to generate concrete prompts for LLMs. It is identified by an id and version, has metadata (name, description, tags, change notes, createdAt, createdBy), and may be associated with a specific LLM model. A Prompt Template declares the variables it expects; at render time, those variables must be supplied or rendering fails. Templates are stored in Firestore under a promptTemplates collection with per-template version subcollections, and one version is designated as the active version for use in production flows such as test execution."
        },
        {
          "id": "template-variable",
          "label": "Template variable",
          "category": "thing",
          "description": "A named placeholder within a prompt template that is filled with context-specific values.",
          "aliases": [
            "template variable",
            "EJS variable",
            "variable",
            "variables",
            "templateVariables"
          ],
          "notes": "A template variable is a named placeholder referenced inside a prompt template (implemented with EJS syntax) that is later bound to a concrete, JSON-serializable value when constructing the final prompt for an LLM. In the EJS-based templates, these appear as identifiers inside <% %>, <%= %>, or <%- %> tags. The system can statically extract the set of variable names from a template string (via extractEJSVariables) and, at evaluation time, display the resolved variable names and their bound values in a UI (TemplateVariablesTabs) alongside the final rendered prompt. Template variables are treated as simple identifiers (matching JavaScript identifier rules) and are distinct from JavaScript keywords and common built-ins, which are explicitly filtered out during extraction."
        },
        {
          "id": "template-rendering",
          "label": "Template rendering",
          "category": "activity",
          "description": "The activity of combining a prompt template with variable values to produce a concrete LLM prompt.",
          "aliases": [
            "template rendering",
            "render template",
            "renderEJSTemplate",
            "EJS rendering",
            "prompt template rendering"
          ],
          "notes": "Template rendering is the activity of taking a stored prompt template (including its EJS-based template string and declared variables) and a set of variable values, validating that all required variables are present, and producing a concrete LLM prompt string. In this system it is implemented via EJS rendering and is treated as a distinct step that happens after fetching the active version of a PromptTemplate and before executing an LLMRequest. Failures in this step are surfaced as explicit errors (e.g., missing variables, EJS rendering errors) and prevent the LLM request from being sent."
        },
        {
          "id": "llm-execution",
          "label": "LLM execution",
          "category": "activity",
          "description": "The process of selecting a model, sending a prompt, and obtaining a response from an LLM provider.",
          "aliases": [
            "llm-execution",
            "executePrompt",
            "LLM request",
            "LLMResponse",
            "LLMRequest",
            "LLM call",
            "LLM invocation",
            "model.generateContent"
          ],
          "notes": "LLM execution is the end-to-end act of taking a textual prompt and optional generation parameters, selecting or defaulting a model name, obtaining a provider-specific model handle via a model getter, invoking the provider's content-generation API, and returning a normalized response object that includes the generated text, raw provider response, elapsed time, and the resolved model name. During execution, optional debug context may be used to record a structured 'llm_request' debug event in Firestore before the provider call. The implementation currently targets Google Vertex AI (Gemini models) and uses a model cache keyed by model name to avoid recreating clients. Location/region selection for the model is derived from the model name and environment configuration."
        },
        {
          "id": "llm-job",
          "label": "LLM job",
          "category": "thing",
          "description": "A unit of background work that encapsulates an LLM execution and its associated context.",
          "aliases": [
            "llm-job",
            "LLM job",
            "runLlmJob",
            "LLM task",
            "background LLM job"
          ],
          "notes": "An LLM job is a unit of background work that runs an LLM-based analysis or interaction for a specific Slack thread. It is triggered with a TaskPayload that identifies the Slack channel, root thread timestamp, optional message timestamp, user, and text. The job coordinates LLM classification (e.g., isDataRequest), iteration (iterateDataRequest), and review (reviewDataRequest), and posts results back into the Slack thread while managing robot reactions and greeting behavior. It also records per-thread metadata (e.g., reacted, greeted, updatedAt) in the threads collection in Firestore and measures job start time for potential timing/debug purposes."
        },
        {
          "id": "llm-context",
          "label": "LLM context",
          "category": "thing",
          "description": "The set of contextual facts, prior messages, and metadata provided to an LLM to guide its behavior.",
          "aliases": [
            "llm-context",
            "context",
            "named context",
            "context file",
            "context snippet",
            "all context"
          ],
          "notes": "LLM context is the named body of reference material and guidance text that is loaded from markdown files and supplied (directly or via templates) into an LLM prompt to guide its behavior. Each context is stored as a separate .md file under a context directory and can be retrieved individually by name or aggregated into a single combined representation. The system treats these context files as stable, reusable knowledge snippets that can be injected into prompts alongside template variables and other metadata."
        },
        {
          "id": "debug-event",
          "label": "Debug event",
          "category": "event",
          "description": "A recorded observation about an LLM interaction or workflow step, used for troubleshooting and analysis.",
          "aliases": [
            "debug-event",
            "DebugEvent",
            "debug event",
            "debugEvents",
            "error debug event"
          ],
          "notes": "A Debug Event is a structured, timestamped record capturing a specific observation about an LLM interaction, Slack workflow step, or system behavior, primarily for troubleshooting, performance analysis, and evaluation. It is stored under a Slack thread (identified by rootTs) in a 'debugEvents' collection and can represent different event types such as LLM requests, LLM responses, Slack messages, timing metrics, and errors."
        },
        {
          "id": "error-recording",
          "label": "Error recording",
          "category": "activity",
          "description": "The activity of capturing and persisting errors that occur during LLM or workflow execution.",
          "aliases": [
            "error recording",
            "recordError",
            "error logging",
            "log error",
            "debug event recording",
            "recordDebugEvent",
            "structured error handling",
            "error handling"
          ],
          "notes": "Error recording is the activity of capturing, structuring, and persisting information about errors that occur during LLM or workflow execution. In this system, error recording always includes at least console logging (via logError or ErrorHandler.log) and may additionally persist a structured DebugEvent into a Firestore-backed debugEvents subcollection under a thread. Error recording is treated as best-effort persistence: failures to persist debug events must not break the main workflow."
        }
      ],
      "relationships": [
        {
          "id": "rel-llm-request-uses-prompt",
          "from": "llm-request",
          "to": "prompt",
          "phrase": "includes",
          "category": "part_of",
          "description": "An LLM request includes a prompt string that describes the task the large language model should perform."
        },
        {
          "id": "rel-llm-request-uses-model-name",
          "from": "llm-request",
          "to": "llm-model",
          "phrase": "selects",
          "category": "uses",
          "description": "An LLM request may select which large language model to use via modelName; if omitted, a default model is chosen during execution."
        },
        {
          "id": "rel-llm-request-uses-generation-params",
          "from": "llm-request",
          "to": "generation-parameters",
          "phrase": "specifies",
          "category": "uses",
          "description": "An LLM request may specify generation parameters such as temperature and maxTokens that influence how the model generates content."
        },
        {
          "id": "rel-llm-request-precedes-llm-response",
          "from": "llm-request",
          "to": "llm-response",
          "phrase": "results in",
          "category": "precedes",
          "description": "Each LLM request, when executed, results in an LLM response containing the generated text and metadata."
        },
        {
          "id": "rel-llm-request-used-by-execute-prompt",
          "from": "llm-request",
          "to": "prompt-execution",
          "phrase": "is executed by",
          "category": "uses",
          "description": "An LLM request is consumed by the prompt execution process (executePrompt) to call the underlying large language model."
        },
        {
          "id": "rel-llm-request-recorded-in-debug-context",
          "from": "llm-request",
          "to": "debug-context",
          "phrase": "is recorded in",
          "category": "uses",
          "description": "When a debug context is provided, an LLM request is recorded as a debug event, capturing its parameters and associated template information."
        },
        {
          "id": "rel-llm-request-associated-with-template",
          "from": "llm-request",
          "to": "prompt-template",
          "phrase": "is associated with",
          "category": "other",
          "description": "Through the debug context, an LLM request is associated with a specific prompt template (templateId, templateVersion) and templateVariables that were used to construct the prompt."
        },
        {
          "id": "rel-llm-request-identified-by-request-id",
          "from": "llm-request",
          "to": "llm-request-identifier",
          "phrase": "may be identified by",
          "category": "represents",
          "description": "An LLM request may be associated with a requestId in the debug context, allowing it to be uniquely identified in debug logs."
        },
        {
          "id": "rel-llm-response-from-request",
          "from": "llm-response",
          "to": "llm-request",
          "phrase": "is produced from",
          "category": "precedes",
          "description": "Each LLM response is produced as the result of executing a specific LLM request via executePrompt."
        },
        {
          "id": "rel-llm-response-uses-model",
          "from": "llm-response",
          "to": "llm-model",
          "phrase": "is generated by",
          "category": "uses",
          "description": "An LLM response is generated by a particular LLM model, identified by modelName, obtained through a ModelGetter."
        },
        {
          "id": "rel-llm-response-part-of-orchestration",
          "from": "llm-response",
          "to": "llm-orchestration-and-prompt-execution",
          "phrase": "is output of",
          "category": "part_of",
          "description": "An LLM response is the primary output artifact of the LLM orchestration and prompt execution process."
        },
        {
          "id": "rel-llm-response-enables-evaluation",
          "from": "llm-response",
          "to": "llm-evaluation",
          "phrase": "provides content for",
          "category": "enables",
          "description": "The text and rawResponse in an LLM response provide the content that downstream evaluation components analyze."
        },
        {
          "id": "rel-llm-response-enables-ui-inspection",
          "from": "llm-response",
          "to": "llm-response-ui-view",
          "phrase": "is displayed in",
          "category": "enables",
          "description": "The LLM response is surfaced in UI components (such as response tabs or parsers) for inspection, copying, and debugging."
        },
        {
          "id": "rel-llm-response-includes-raw-provider-response",
          "from": "llm-response",
          "to": "llm-provider-raw-response",
          "phrase": "wraps",
          "category": "part_of",
          "description": "An LLM response wraps the provider-specific raw response object, preserving full details beyond the extracted text."
        },
        {
          "id": "rel-llm-response-includes-text",
          "from": "llm-response",
          "to": "llm-generated-text",
          "phrase": "contains",
          "category": "part_of",
          "description": "An LLM response contains the primary generated text extracted from the provider's raw response."
        },
        {
          "id": "rel-llm-response-includes-timing",
          "from": "llm-response",
          "to": "llm-call-timing",
          "phrase": "records",
          "category": "part_of",
          "description": "An LLM response records the elapsed time in milliseconds for the LLM call, enabling performance and debugging analysis."
        },
        {
          "id": "rel-prompt-template-has-variables",
          "from": "prompt-template",
          "to": "template-variable",
          "phrase": "declares",
          "category": "part_of",
          "description": "A Prompt Template declares a set of variable names that must be provided when rendering the template into a concrete LLM prompt."
        },
        {
          "id": "rel-prompt-template-uses-model",
          "from": "prompt-template",
          "to": "llm-model",
          "phrase": "targets",
          "category": "uses",
          "description": "A Prompt Template may target a specific LLM model (e.g., gemini-2.5-flash or gemini-2.5-pro), indicating which model it is intended to be executed against."
        },
        {
          "id": "rel-prompt-template-has-version",
          "from": "prompt-template",
          "to": "prompt-template-version",
          "phrase": "is represented by",
          "category": "part_of",
          "description": "A Prompt Template is represented in storage by one or more version records, each capturing the template text, variables, and metadata for a specific version number."
        },
        {
          "id": "rel-prompt-template-version-derived-from-parent",
          "from": "prompt-template-version",
          "to": "prompt-template-version",
          "phrase": "is derived from",
          "category": "precedes",
          "description": "A Prompt Template version may reference a parentVersion, indicating it was derived from an earlier version of the same template."
        },
        {
          "id": "rel-prompt-template-has-active-version",
          "from": "prompt-template",
          "to": "prompt-template-version",
          "phrase": "designates as active version",
          "category": "uses",
          "description": "A Prompt Template has one version marked as the active version, which is the version fetched and used for rendering in production flows."
        },
        {
          "id": "rel-test-execution-uses-prompt-template",
          "from": "test-execution-task",
          "to": "prompt-template",
          "phrase": "uses",
          "category": "uses",
          "description": "A Test Execution Task references a Prompt Template by templateId to generate the prompts used during LLM evaluation."
        },
        {
          "id": "rel-user-creates-prompt-template",
          "from": "user",
          "to": "prompt-template",
          "phrase": "creates",
          "category": "causes",
          "description": "A User creates a Prompt Template; the template records the identifier of the creating user in createdBy."
        },
        {
          "id": "rel-template-variable-in-prompt-template",
          "from": "template-variable",
          "to": "prompt-template",
          "phrase": "is referenced in",
          "category": "part_of",
          "description": "A template variable is referenced inside a prompt template using EJS tag syntax, serving as a placeholder to be filled with context-specific values."
        },
        {
          "id": "rel-prompt-template-uses-template-variable",
          "from": "prompt-template",
          "to": "template-variable",
          "phrase": "uses",
          "category": "uses",
          "description": "A prompt template uses one or more template variables to parameterize the text that will be sent to the LLM."
        },
        {
          "id": "rel-template-variable-has-value",
          "from": "template-variable",
          "to": "template-variable-value",
          "phrase": "is bound to",
          "category": "represents",
          "description": "Each template variable is bound to a concrete JSON-serializable value when rendering the final prompt."
        },
        {
          "id": "rel-template-variable-collection-displayed-in-ui",
          "from": "template-variable",
          "to": "llm-eval-ui",
          "phrase": "is displayed in",
          "category": "uses",
          "description": "Resolved template variables and their values are displayed in the evaluation UI (TemplateVariablesTabs) to help users inspect how the final prompt was constructed."
        },
        {
          "id": "rel-template-variable-enables-final-prompt",
          "from": "template-variable",
          "to": "final-prompt",
          "phrase": "enables construction of",
          "category": "enables",
          "description": "By substituting template variables with their bound values, the system constructs the final prompt string that is sent to the LLM."
        },
        {
          "id": "rel-template-rendering-uses-prompt-template",
          "from": "template-rendering",
          "to": "prompt-template",
          "phrase": "uses",
          "category": "uses",
          "description": "Template rendering uses a PromptTemplate, including its template string and declared variables, as the blueprint for generating a concrete LLM prompt."
        },
        {
          "id": "rel-template-rendering-requires-template-variables",
          "from": "template-rendering",
          "to": "template-variables",
          "phrase": "requires",
          "category": "constraint",
          "description": "Template rendering requires a set of template variables whose keys match the variable names declared by the PromptTemplate."
        },
        {
          "id": "rel-template-rendering-produces-llm-request-prompt",
          "from": "template-rendering",
          "to": "llm-request",
          "phrase": "produces prompt for",
          "category": "precedes",
          "description": "Template rendering produces the concrete prompt string that is placed into an LLMRequest before execution."
        },
        {
          "id": "rel-template-rendering-precedes-llm-execution",
          "from": "template-rendering",
          "to": "llm-execution",
          "phrase": "precedes",
          "category": "precedes",
          "description": "Template rendering precedes LLM execution; the LLM is only called after a prompt has been successfully rendered."
        },
        {
          "id": "rel-template-rendering-uses-active-prompt-template-version",
          "from": "template-rendering",
          "to": "active-prompt-template-version",
          "phrase": "uses",
          "category": "uses",
          "description": "Template rendering uses the active version of a PromptTemplate, as determined by the template metadata and version documents, when generating the prompt."
        },
        {
          "id": "rel-template-rendering-records-debug-context",
          "from": "template-rendering",
          "to": "debug-event",
          "phrase": "enables recording of",
          "category": "enables",
          "description": "By associating rendered prompts with templateId, templateVersion, and templateVariables in DebugContext, template rendering enables detailed debug events to be recorded for LLM requests."
        },
        {
          "id": "rel-llm-exec-takes-llmrequest",
          "from": "llm-execution",
          "to": "LLMRequest",
          "phrase": "takes as input",
          "category": "uses",
          "description": "LLM execution takes an LLMRequest, which specifies the prompt and optional modelName, temperature, and maxTokens used for the generation."
        },
        {
          "id": "rel-llm-exec-produces-llmresponse",
          "from": "llm-execution",
          "to": "LLMResponse",
          "phrase": "produces",
          "category": "causes",
          "description": "LLM execution produces an LLMResponse containing the generated text, raw provider response, elapsed time, and the resolved model name."
        },
        {
          "id": "rel-llm-exec-uses-modelgetter",
          "from": "llm-execution",
          "to": "ModelGetter",
          "phrase": "uses",
          "category": "uses",
          "description": "LLM execution uses a ModelGetter function to resolve a provider-specific model handle from a model name."
        },
        {
          "id": "rel-llm-exec-uses-vertex-model",
          "from": "llm-execution",
          "to": "VertexGenerativeModel",
          "phrase": "invokes",
          "category": "uses",
          "description": "LLM execution invokes a Vertex AI generative model via its generateContent method to obtain the LLM output."
        },
        {
          "id": "rel-llm-exec-may-use-debugcontext",
          "from": "llm-execution",
          "to": "DebugContext",
          "phrase": "may use",
          "category": "uses",
          "description": "LLM execution may use a DebugContext to record a structured 'llm_request' debug event before calling the model."
        },
        {
          "id": "rel-llm-exec-records-debug-event",
          "from": "llm-execution",
          "to": "DebugEvent",
          "phrase": "records",
          "category": "causes",
          "description": "When a DebugContext is provided, LLM execution records a 'llm_request' DebugEvent containing model, prompt, parameters, template metadata, and a requestId."
        },
        {
          "id": "rel-llm-exec-uses-template-metadata",
          "from": "llm-execution",
          "to": "PromptTemplate",
          "phrase": "associates with",
          "category": "uses",
          "description": "LLM execution associates the LLM request with a PromptTemplate via templateId, templateVersion, and templateVariables stored in the DebugContext and debug event."
        },
        {
          "id": "rel-llm-exec-uses-environment-config",
          "from": "llm-execution",
          "to": "EnvironmentConfiguration",
          "phrase": "uses",
          "category": "uses",
          "description": "LLM execution indirectly uses environment configuration (PROJECT_ID, REGION) to construct the underlying Vertex AI client and select the model location."
        },
        {
          "id": "rel-llm-exec-selects-model",
          "from": "llm-execution",
          "to": "LLMModel",
          "phrase": "selects",
          "category": "uses",
          "description": "LLM execution selects an LLMModel by resolving the modelName from the request or falling back to a default model name."
        },
        {
          "id": "rel-llm-exec-precedes-response-consumption",
          "from": "llm-execution",
          "to": "llm-response-consumption",
          "phrase": "precedes",
          "category": "precedes",
          "description": "LLM execution precedes any downstream consumption or evaluation of the LLMResponse in the broader system."
        },
        {
          "id": "rel-llm-job-uses-taskpayload",
          "from": "llm-job",
          "to": "task-payload",
          "phrase": "is parameterized by",
          "category": "uses",
          "description": "An LLM job is parameterized by a TaskPayload, which supplies the Slack channel, root thread timestamp, optional message timestamp, text, user, and metadata needed to execute the job."
        },
        {
          "id": "rel-llm-job-targets-thread",
          "from": "llm-job",
          "to": "slack-thread",
          "phrase": "targets",
          "category": "uses",
          "description": "An LLM job targets a specific Slack thread, identified by the rootTs in the TaskPayload, and performs its work in the context of that thread."
        },
        {
          "id": "rel-llm-job-posts-to-slack",
          "from": "llm-job",
          "to": "slack-message",
          "phrase": "posts",
          "category": "causes",
          "description": "An LLM job posts messages and block content back into Slack, typically as replies in the target thread, to present LLM results or status updates."
        },
        {
          "id": "rel-llm-job-adds-reactions",
          "from": "llm-job",
          "to": "slack-reaction",
          "phrase": "adds and removes",
          "category": "causes",
          "description": "An LLM job adds and removes robot reactions on Slack messages to signal that the system is processing or has processed the request."
        },
        {
          "id": "rel-llm-job-uses-isdatarequest",
          "from": "llm-job",
          "to": "llm-data-request-classification",
          "phrase": "uses",
          "category": "uses",
          "description": "An LLM job uses the isDataRequest LLM classification to determine whether a Slack message represents a data request."
        },
        {
          "id": "rel-llm-job-uses-iteratedatarequest",
          "from": "llm-job",
          "to": "llm-data-request-iteration",
          "phrase": "uses",
          "category": "uses",
          "description": "An LLM job uses iterateDataRequest to iteratively refine or progress a detected data request conversation."
        },
        {
          "id": "rel-llm-job-uses-reviewdatarequest",
          "from": "llm-job",
          "to": "llm-data-request-review",
          "phrase": "uses",
          "category": "uses",
          "description": "An LLM job uses reviewDataRequest to review or summarize a data request, likely for quality or completeness before responding."
        },
        {
          "id": "rel-llm-job-uses-firestore-thread-doc",
          "from": "llm-job",
          "to": "thread-record",
          "phrase": "reads and updates",
          "category": "uses",
          "description": "An LLM job reads and updates a thread record in persistent storage (threads collection) keyed by the root thread timestamp, tracking flags such as whether the system has reacted or greeted in that thread."
        },
        {
          "id": "rel-llm-job-uses-debug-message",
          "from": "llm-job",
          "to": "debug-message",
          "phrase": "can create",
          "category": "uses",
          "description": "An LLM job can create a Slack message with debug-oriented content (and potentially a debug button) to expose internal information about the job or its LLM processing."
        },
        {
          "id": "rel-llm-job-measures-duration",
          "from": "llm-job",
          "to": "job-timing",
          "phrase": "measures",
          "category": "uses",
          "description": "An LLM job records its start time to enable measurement of elapsed time or performance characteristics for the job."
        },
        {
          "id": "rel-llm-context-stored-as-md-file",
          "from": "llm-context",
          "to": "markdown-context-file",
          "phrase": "is stored as",
          "category": "represents",
          "description": "Each LLM context corresponds to the contents of a markdown (.md) file identified by its context name."
        },
        {
          "id": "rel-llm-context-organized-in-context-directory",
          "from": "llm-context",
          "to": "context-directory",
          "phrase": "is located in",
          "category": "part_of",
          "description": "LLM context files reside in a designated context directory, which may be configured via an environment variable or default to a standard project path."
        },
        {
          "id": "rel-llm-context-identified-by-name",
          "from": "llm-context",
          "to": "context-name",
          "phrase": "is identified by",
          "category": "represents",
          "description": "Each LLM context is referenced and retrieved using a unique string name derived from its markdown filename."
        },
        {
          "id": "rel-llm-context-used-by-llm-prompt",
          "from": "llm-context",
          "to": "llm-prompt",
          "phrase": "is used to enrich",
          "category": "uses",
          "description": "LLM context content is intended to be injected into or combined with the LLM prompt text to guide model behavior."
        },
        {
          "id": "rel-all-llm-context-aggregated-representation",
          "from": "llm-context",
          "to": "aggregated-context-payload",
          "phrase": "is aggregated into",
          "category": "part_of",
          "description": "Multiple named LLM contexts can be combined into a single aggregated payload where each context is wrapped and labeled, enabling the LLM to receive all available contextual snippets at once."
        },
        {
          "id": "rel-llm-context-used-with-llm-request",
          "from": "llm-context",
          "to": "llm-request",
          "phrase": "is incorporated into",
          "category": "uses",
          "description": "The text of one or more LLM contexts is incorporated into the prompt field of an LLM request that is executed against a model."
        },
        {
          "id": "rel-llm-context-associated-with-template",
          "from": "llm-context",
          "to": "prompt-template",
          "phrase": "is referenced by",
          "category": "uses",
          "description": "Prompt templates, identified by templateId and templateVersion, can reference LLM context content and combine it with template variables when constructing the final prompt."
        },
        {
          "id": "rel-llm-context-supports-debug-context",
          "from": "llm-context",
          "to": "debug-context",
          "phrase": "is implied in",
          "category": "uses",
          "description": "When an LLM request is executed with a debug context, the resulting debug event records the prompt text that may already include injected LLM context, linking the context used to the recorded template and variables."
        },
        {
          "id": "rel-debug-event-belongs-to-thread",
          "from": "debug-event",
          "to": "slack-thread",
          "phrase": "belongs to",
          "category": "part_of",
          "description": "Each debug event is recorded under a specific Slack thread, identified by rootTs, and stored in that thread's 'debugEvents' subcollection."
        },
        {
          "id": "rel-debug-event-records-llm-request",
          "from": "debug-event",
          "to": "llm-request",
          "phrase": "records",
          "category": "represents",
          "description": "A debug event of type 'llm_request' represents the details of an LLM request, including model, prompt, parameters, and template context."
        },
        {
          "id": "rel-debug-event-records-llm-response",
          "from": "debug-event",
          "to": "llm-response",
          "phrase": "records",
          "category": "represents",
          "description": "A debug event of type 'llm_response' represents the outcome of an LLM call, including raw response, elapsed time, and optional token usage and finish reason."
        },
        {
          "id": "rel-debug-event-records-slack-message-incoming",
          "from": "debug-event",
          "to": "incoming-slack-message",
          "phrase": "records",
          "category": "represents",
          "description": "A debug event of type 'incoming_slack_message' represents an incoming Slack message, including channel, user, text, and threading information."
        },
        {
          "id": "rel-debug-event-records-thread-creation",
          "from": "debug-event",
          "to": "slack-thread",
          "phrase": "records creation of",
          "category": "represents",
          "description": "A debug event of type 'thread_created' represents the creation of a Slack thread and whether name resolution has been performed."
        },
        {
          "id": "rel-debug-event-records-llm-classification",
          "from": "debug-event",
          "to": "llm-classification",
          "phrase": "records",
          "category": "represents",
          "description": "A debug event of type 'llm_classification' represents the result of an LLM-based classification, including input, verdict, confidence, reasoning, and elapsed time."
        },
        {
          "id": "rel-debug-event-records-time-metric",
          "from": "debug-event",
          "to": "reaction-time-measurement",
          "phrase": "records",
          "category": "represents",
          "description": "A debug event of type 'time_to_react' represents timing metrics between a Slack message and a reaction, including elapsed and wall-clock time."
        },
        {
          "id": "rel-debug-event-records-error",
          "from": "debug-event",
          "to": "app-error",
          "phrase": "records",
          "category": "represents",
          "description": "A debug event of type 'error_occurred' represents an application error, including error code, message, severity, context, and stack trace."
        },
        {
          "id": "rel-debug-event-uses-error-severity",
          "from": "debug-event",
          "to": "error-severity",
          "phrase": "uses",
          "category": "uses",
          "description": "Error-related debug events include an ErrorSeverity value to indicate the impact level of the recorded error."
        },
        {
          "id": "rel-debug-event-linked-by-request-id",
          "from": "debug-event",
          "to": "llm-interaction",
          "phrase": "links parts of",
          "category": "other",
          "description": "Debug events for LLM requests and responses may share a requestId, allowing multiple events to be correlated as a single LLM interaction."
        },
        {
          "id": "rel-debug-event-uses-template-context",
          "from": "debug-event",
          "to": "prompt-template",
          "phrase": "uses context from",
          "category": "uses",
          "description": "LLM-related debug events may include templateId, templateVersion, and templateVariables to tie the event to a specific prompt template and its variables."
        },
        {
          "id": "rel-debug-event-viewed-in-evals-ui",
          "from": "debug-event",
          "to": "evals-ui",
          "phrase": "is displayed in",
          "category": "uses",
          "description": "Debug events are rendered in the evaluation UI to help users inspect LLM behavior, template variables, and responses."
        },
        {
          "id": "rel-error-recording-uses-debug-event",
          "from": "error-recording",
          "to": "debug-event",
          "phrase": "represents each error as",
          "category": "represents",
          "description": "Error recording represents an error as a structured DebugEvent object with type, timestamp, and data fields before persisting it."
        },
        {
          "id": "rel-error-recording-uses-logError",
          "from": "error-recording",
          "to": "logging",
          "phrase": "logs to",
          "category": "uses",
          "description": "Error recording uses the shared logError facility (or ErrorHandler.log) to emit structured error information to console logging as part of the recording process."
        },
        {
          "id": "rel-error-recording-part-of-debugging",
          "from": "error-recording",
          "to": "debugging-and-observability",
          "phrase": "contributes to",
          "category": "part_of",
          "description": "Error recording contributes to the broader debugging and observability capability by capturing structured error events for later inspection."
        },
        {
          "id": "rel-error-recording-uses-firestore",
          "from": "error-recording",
          "to": "thread-debug-event-store",
          "phrase": "persists events in",
          "category": "uses",
          "description": "Error recording persists DebugEvent records into a Firestore-like store, under a threads collection and a debugEvents subcollection keyed by a root thread timestamp."
        },
        {
          "id": "rel-error-recording-associated-with-thread",
          "from": "error-recording",
          "to": "thread",
          "phrase": "associates each recorded error with",
          "category": "part_of",
          "description": "Error recording associates each error DebugEvent with a specific conversation or workflow thread identified by rootTs."
        },
        {
          "id": "rel-error-recording-uses-error-severity",
          "from": "error-recording",
          "to": "error-severity",
          "phrase": "classifies errors by",
          "category": "uses",
          "description": "Error recording classifies each error with an ErrorSeverity level (CRITICAL, HIGH, MEDIUM, LOW) which influences how it is logged and interpreted."
        },
        {
          "id": "rel-error-recording-uses-app-error",
          "from": "error-recording",
          "to": "app-error",
          "phrase": "logs instances of",
          "category": "uses",
          "description": "Error recording via ErrorHandler.log operates on AppError objects, extracting code, messages, severity, recoverability, and context for structured logging."
        },
        {
          "id": "rel-error-recording-follows-error-occurrence",
          "from": "error-recording",
          "to": "error-occurrence",
          "phrase": "follows",
          "category": "precedes",
          "description": "Error recording is triggered after an error occurs during LLM or workflow execution, capturing details about that error occurrence."
        },
        {
          "id": "rel-error-recording-uses-error-context",
          "from": "error-recording",
          "to": "error-context",
          "phrase": "captures",
          "category": "uses",
          "description": "Error recording captures contextual data (operation name, environment, stack trace, and other metadata) as part of the recorded error information."
        },
        {
          "id": "rel-error-recording-uses-error-handler",
          "from": "error-recording",
          "to": "error-handler",
          "phrase": "is implemented by",
          "category": "represents",
          "description": "The ErrorHandler service embodies structured error recording behavior by standardizing how errors are logged and transformed into user-facing messages."
        }
      ],
      "rules": [
        {
          "id": "rule-llm-request-requires-prompt",
          "title": "LLM request must include a prompt",
          "text": "Every LLM request must contain a non-empty prompt string describing the task for the large language model.",
          "kind": "constraint",
          "conceptIds": [
            "llm-request"
          ]
        },
        {
          "id": "rule-llm-request-model-default",
          "title": "LLM request uses a default model when none is specified",
          "text": "If an LLM request does not specify a modelName, the prompt execution process will use a default model (currently 'gemini-2.5-flash').",
          "kind": "assumption",
          "conceptIds": [
            "llm-request"
          ]
        },
        {
          "id": "rule-llm-request-parameters-are-optional",
          "title": "LLM request generation parameters are optional",
          "text": "Temperature and maxTokens in an LLM request are optional; when omitted, the underlying model's defaults are used during generation.",
          "kind": "assumption",
          "conceptIds": [
            "llm-request"
          ]
        },
        {
          "id": "rule-llm-request-can-be-debug-logged",
          "title": "LLM request may be logged as a debug event",
          "text": "When a debug context is provided, each LLM request should be recorded as a debug event with its model, prompt, parameters, and associated template metadata.",
          "kind": "policy",
          "conceptIds": [
            "llm-request"
          ]
        },
        {
          "id": "rule-llm-response-has-text",
          "title": "LLM response must include generated text (possibly empty)",
          "text": "Every LLM response produced by executePrompt includes a text field representing the generated content extracted from the raw provider response. If no candidate text is available, text is set to an empty string rather than being omitted.",
          "kind": "invariant",
          "conceptIds": [
            "llm-response"
          ]
        },
        {
          "id": "rule-llm-response-has-model-name",
          "title": "LLM response must record the model name used",
          "text": "Every LLM response includes a modelName field that records the actual model used to generate the response. If the request omits a modelName, a default model (e.g., 'gemini-2.5-flash') is chosen and recorded in the response.",
          "kind": "invariant",
          "conceptIds": [
            "llm-response"
          ]
        },
        {
          "id": "rule-llm-response-has-elapsed-time",
          "title": "LLM response must record elapsed time",
          "text": "Every LLM response includes an elapsedMs field representing the duration of the LLM call in milliseconds, measured from just before the provider call to just after it completes.",
          "kind": "invariant",
          "conceptIds": [
            "llm-response"
          ]
        },
        {
          "id": "rule-llm-response-preserves-raw-provider-data",
          "title": "LLM response preserves raw provider response",
          "text": "Every LLM response includes a rawResponse field that stores the unmodified provider-specific response object returned by the model, allowing downstream consumers to access full details beyond the extracted text.",
          "kind": "assumption",
          "conceptIds": [
            "llm-response"
          ]
        },
        {
          "id": "rule-prompt-template-must-have-id-name-template",
          "title": "Prompt Template must have core identifiers and content",
          "text": "Each Prompt Template must have an id, a name, and a template body string defined.",
          "kind": "invariant",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "rule-prompt-template-variables-must-be-satisfied-on-render",
          "title": "All declared variables must be provided when rendering",
          "text": "When rendering a Prompt Template, all variables declared in the template's variables list must be present in the provided variable map; otherwise, rendering fails with an error indicating the missing variables.",
          "kind": "constraint",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "rule-prompt-template-version-number-required",
          "title": "Prompt Template version number is required",
          "text": "Each Prompt Template instance must have a version number that identifies its revision within the template's version history.",
          "kind": "invariant",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "rule-prompt-template-active-version-must-exist",
          "title": "Active Prompt Template version must exist in storage",
          "text": "For a Prompt Template to be used as active, there must be a corresponding version document in the versions subcollection matching the activeVersion metadata; if this version document does not exist, the system treats it as an error.",
          "kind": "constraint",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "rule-prompt-template-created-metadata-required",
          "title": "Prompt Template records creation metadata",
          "text": "Each Prompt Template version records when it was created (createdAt) and by whom (createdBy).",
          "kind": "invariant",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "rule-prompt-template-is-active-flag-consistent",
          "title": "Prompt Template version indicates active status",
          "text": "Each Prompt Template version includes an isActive flag indicating whether that version is currently considered active in its context.",
          "kind": "assumption",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "rule-template-variable-identifier-shape",
          "title": "Template variable names must be valid identifiers",
          "text": "Template variable names must match JavaScript identifier rules (starting with a letter, underscore, or dollar sign, followed by letters, digits, underscores, or dollar signs).",
          "kind": "constraint",
          "conceptIds": [
            "template-variable"
          ]
        },
        {
          "id": "rule-template-variable-not-keyword",
          "title": "Template variable names must not be JavaScript keywords or common built-ins",
          "text": "Names that are JavaScript reserved keywords or common built-in objects/functions are not treated as template variables and are excluded when extracting variables from a template.",
          "kind": "constraint",
          "conceptIds": [
            "template-variable"
          ]
        },
        {
          "id": "rule-template-variable-values-json-serializable",
          "title": "Template variable values must be JSON-serializable",
          "text": "Values bound to template variables must be JSON-serializable (string, number, boolean, null, arrays, or plain objects composed of these types) so they can be inspected and rendered in the evaluation UI.",
          "kind": "assumption",
          "conceptIds": [
            "template-variable"
          ]
        },
        {
          "id": "rule-template-rendering-must-have-all-required-variables",
          "title": "Template rendering requires all declared variables to be provided",
          "text": "When rendering a prompt template, all variables declared by the PromptTemplate must be present as keys in the provided variables object; otherwise, template rendering fails with an error indicating the missing variables.",
          "kind": "constraint",
          "conceptIds": [
            "template-rendering"
          ]
        },
        {
          "id": "rule-template-rendering-fails-on-ejs-error",
          "title": "Template rendering fails if EJS rendering fails",
          "text": "If the underlying EJS engine throws an error while rendering the template string with the provided variables, template rendering must fail and surface an error that includes the template identifier.",
          "kind": "invariant",
          "conceptIds": [
            "template-rendering"
          ]
        },
        {
          "id": "rule-template-rendering-uses-active-template-version",
          "title": "Template rendering must use the active template version",
          "text": "Before template rendering, the system must resolve and use the activeVersion of the PromptTemplate from storage; rendering against a non-existent or inactive version is treated as an error.",
          "kind": "constraint",
          "conceptIds": [
            "template-rendering"
          ]
        },
        {
          "id": "rule-template-rendering-precondition-for-llm-request",
          "title": "Template rendering is a precondition for LLM request execution",
          "text": "A concrete LLMRequest.prompt must be produced by successful template rendering before an LLM request is executed; if template rendering fails, the LLM must not be called.",
          "kind": "assumption",
          "conceptIds": [
            "template-rendering"
          ]
        },
        {
          "id": "rule-llm-exec-default-model",
          "title": "LLM execution must resolve a model name",
          "text": "If an LLMRequest does not specify a modelName, LLM execution must default the model name to 'gemini-2.5-flash' before invoking the model getter.",
          "kind": "invariant",
          "conceptIds": [
            "llm-execution"
          ]
        },
        {
          "id": "rule-llm-exec-requires-prompt",
          "title": "LLM execution requires a prompt",
          "text": "LLM execution requires that the LLMRequest contain a prompt string, which is passed as the user content to the underlying model.",
          "kind": "constraint",
          "conceptIds": [
            "llm-execution"
          ]
        },
        {
          "id": "rule-llm-exec-measures-latency",
          "title": "LLM execution measures elapsed time",
          "text": "LLM execution must measure the elapsed time between the start of the request and completion of the provider call, and include this value in the LLMResponse.elapsedMs field.",
          "kind": "invariant",
          "conceptIds": [
            "llm-execution"
          ]
        },
        {
          "id": "rule-llm-exec-records-debug-when-context-present",
          "title": "LLM execution records debug events when debug context is provided",
          "text": "When a DebugContext is provided, LLM execution must attempt to record a 'llm_request' debug event containing model, prompt, temperature, maxTokens, requestId, templateId, templateVersion, and templateVariables before invoking the model.",
          "kind": "policy",
          "conceptIds": [
            "llm-execution"
          ]
        },
        {
          "id": "rule-llm-exec-uses-modelgetter",
          "title": "LLM execution must obtain a model via the model getter",
          "text": "LLM execution must obtain the provider-specific model handle by calling the supplied ModelGetter with the resolved model name, rather than constructing the model directly.",
          "kind": "invariant",
          "conceptIds": [
            "llm-execution"
          ]
        },
        {
          "id": "rule-llm-exec-normalizes-response",
          "title": "LLM execution must normalize provider response",
          "text": "LLM execution must extract the primary generated text from the provider-specific response structure and place it in LLMResponse.text, while also returning the full raw provider response in LLMResponse.rawResponse.",
          "kind": "invariant",
          "conceptIds": [
            "llm-execution"
          ]
        },
        {
          "id": "rule-llm-exec-uses-user-role",
          "title": "LLM execution sends prompt as user role content",
          "text": "LLM execution must send the prompt to the provider as content with role 'user' in the generateContent request.",
          "kind": "invariant",
          "conceptIds": [
            "llm-execution"
          ]
        },
        {
          "id": "rule-llm-job-requires-channel-rootts",
          "title": "LLM job requires channel and root thread timestamp",
          "text": "An LLM job must have both a channel and a rootTs in its TaskPayload; if either is missing, the job does not proceed.",
          "kind": "constraint",
          "conceptIds": [
            "llm-job"
          ]
        },
        {
          "id": "rule-llm-job-uses-reactionts-fallback",
          "title": "LLM job chooses reaction target timestamp",
          "text": "An LLM job uses messageTs as the target for reactions when available; otherwise it uses rootTs as the reaction target.",
          "kind": "invariant",
          "conceptIds": [
            "llm-job"
          ]
        },
        {
          "id": "rule-llm-job-updates-thread-metadata",
          "title": "LLM job updates thread metadata",
          "text": "Each LLM job updates the associated thread record with an updatedAt timestamp and may set flags such as reacted and greeted to reflect system actions taken in that thread.",
          "kind": "invariant",
          "conceptIds": [
            "llm-job"
          ]
        },
        {
          "id": "rule-llm-job-determines-side-effects-in-transaction",
          "title": "LLM job determines greeting and reaction once per thread",
          "text": "An LLM job determines whether it needs to react or greet in a thread by reading the thread record in a transaction and only performing those side effects if the corresponding reacted or greeted flags are not yet set.",
          "kind": "policy",
          "conceptIds": [
            "llm-job"
          ]
        },
        {
          "id": "rule-llm-context-must-map-to-md-file",
          "title": "LLM context name must correspond to a markdown file",
          "text": "Each LLM context is retrieved by name and must correspond to a readable .md file in the configured context directory or in the worker fallback context directory.",
          "kind": "constraint",
          "conceptIds": [
            "llm-context"
          ]
        },
        {
          "id": "rule-llm-context-file-extension",
          "title": "LLM context files use .md extension",
          "text": "Only files with a .md extension are considered valid LLM context sources and are listed or aggregated as context.",
          "kind": "constraint",
          "conceptIds": [
            "llm-context"
          ]
        },
        {
          "id": "rule-llm-context-name-uniqueness",
          "title": "LLM context names are unique within a directory",
          "text": "Within a given context directory, each LLM context name must be unique so that a single markdown file unambiguously defines the context for that name.",
          "kind": "assumption",
          "conceptIds": [
            "llm-context"
          ]
        },
        {
          "id": "rule-llm-context-sanitization-for-aggregation",
          "title": "LLM context content is sanitized when aggregated",
          "text": "When all LLM contexts are aggregated into a single payload, their content is sanitized to escape CDATA terminators so that the aggregated representation remains well-formed.",
          "kind": "invariant",
          "conceptIds": [
            "llm-context"
          ]
        },
        {
          "id": "rule-llm-context-caching",
          "title": "LLM context content is cached after first load",
          "text": "Once an LLM context has been read from disk, its content is cached in memory and subsequent uses of that context name reuse the cached content rather than re-reading the file.",
          "kind": "assumption",
          "conceptIds": [
            "llm-context"
          ]
        },
        {
          "id": "rule-debug-event-has-type-and-timestamp",
          "title": "Debug Event must have a type and timestamp",
          "text": "Every debug event includes a 'type' discriminator and an ISO-8601 'timestamp' string indicating when the observed behavior occurred.",
          "kind": "invariant",
          "conceptIds": [
            "debug-event"
          ]
        },
        {
          "id": "rule-debug-event-type-specific-schema",
          "title": "Debug Event data shape depends on type",
          "text": "The structure of the 'data' payload in a debug event is determined by its 'type' value (e.g., 'llm_request', 'llm_response', 'time_to_react', 'llm_classification', 'thread_created', 'incoming_slack_message', 'error_occurred'), and must conform to the fields defined for that type.",
          "kind": "constraint",
          "conceptIds": [
            "debug-event"
          ]
        },
        {
          "id": "rule-debug-event-identified-within-thread",
          "title": "Debug Event is uniquely identified within a thread",
          "text": "Within a given Slack thread, a debug event is identified by a composite identifier derived from its type and timestamp, ensuring uniqueness in that thread's debugEvents collection.",
          "kind": "assumption",
          "conceptIds": [
            "debug-event"
          ]
        },
        {
          "id": "rule-debug-event-associated-with-root-thread",
          "title": "Debug Event is associated with a root thread timestamp",
          "text": "Each debug event is recorded against a rootTs value that identifies the root Slack message of the thread to which the event belongs.",
          "kind": "invariant",
          "conceptIds": [
            "debug-event"
          ]
        },
        {
          "id": "rule-error-debug-event-logs-to-console",
          "title": "Error Debug Event also logs to console",
          "text": "When an error is recorded as a debug event, the error is always logged to the console via the structured error logger, even if persistence of the debug event fails.",
          "kind": "policy",
          "conceptIds": [
            "debug-event"
          ]
        },
        {
          "id": "rule-debug-event-persistence-failure-non-fatal",
          "title": "Debug Event persistence failures do not affect main workflow",
          "text": "If recording a debug event fails, the system logs the failure but does not throw or interrupt the primary workflow being debugged.",
          "kind": "policy",
          "conceptIds": [
            "debug-event"
          ]
        },
        {
          "id": "rule-error-recording-console-first",
          "title": "Errors must always be logged to console before or regardless of persistence",
          "text": "When recording an error, the system must always emit a structured log to the console (via logError or ErrorHandler.log) even if persistence of the error as a debug event fails or is unavailable.",
          "kind": "invariant",
          "conceptIds": [
            "error-recording"
          ]
        },
        {
          "id": "rule-error-recording-best-effort-persistence",
          "title": "Error persistence must be best-effort and non-fatal",
          "text": "If recording an error as a debug event in the backing store fails, the system must not throw or propagate that failure in a way that disrupts the main workflow; instead, it should log the failure to record the error and continue.",
          "kind": "policy",
          "conceptIds": [
            "error-recording"
          ]
        },
        {
          "id": "rule-error-recording-structured-data",
          "title": "Errors must be recorded with structured data",
          "text": "Each recorded error must include at least an error code, a message (technical or user-facing), a severity level, a timestamp, and may include recoverability and contextual metadata such as stack traces and operation context.",
          "kind": "invariant",
          "conceptIds": [
            "error-recording"
          ]
        },
        {
          "id": "rule-error-recording-debug-event-type",
          "title": "Error debug events must use the error_occurred type",
          "text": "When an error is recorded as a DebugEvent, its type field must be set to 'error_occurred' to distinguish it from other debug event types.",
          "kind": "constraint",
          "conceptIds": [
            "error-recording"
          ]
        },
        {
          "id": "rule-error-recording-event-id-format",
          "title": "Error debug event identifiers must be derived from type and timestamp",
          "text": "Each persisted error DebugEvent must have an identifier composed from its type and timestamp (e.g., `${event.type}_${event.timestamp}`) to provide uniqueness within a thread's debugEvents collection.",
          "kind": "assumption",
          "conceptIds": [
            "error-recording"
          ]
        },
        {
          "id": "rule-error-recording-thread-association",
          "title": "Recorded errors must be associated with a root thread",
          "text": "Each persisted error debug event must be stored under a thread identified by a root timestamp (rootTs), ensuring that errors are associated with the correct conversation or workflow thread.",
          "kind": "constraint",
          "conceptIds": [
            "error-recording"
          ]
        },
        {
          "id": "rule-error-recording-severity-influences-log-channel",
          "title": "Error severity determines logging channel",
          "text": "The severity of an error determines which console channel is used for logging (e.g., console.error for CRITICAL and HIGH, console.warn for MEDIUM, console.info for LOW), reflecting its importance.",
          "kind": "policy",
          "conceptIds": [
            "error-recording"
          ]
        }
      ],
      "lifecycles": [
        {
          "id": "lifecycle-llm-request-execution",
          "subjectConceptId": "llm-request",
          "stateConceptIds": [
            "llm-request-created",
            "llm-request-executing",
            "llm-request-completed",
            "llm-request-failed"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "llm-request-created",
          "terminalStateIds": [
            "llm-request-completed",
            "llm-request-failed"
          ]
        },
        {
          "id": "lifecycle-prompt-template-version-activation",
          "subjectConceptId": "prompt-template",
          "stateConceptIds": [
            "prompt-template-version-inactive",
            "prompt-template-version-active"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "prompt-template-version-inactive",
          "terminalStateIds": [
            "prompt-template-version-active"
          ]
        },
        {
          "id": "lifecycle-llm-exec-basic",
          "subjectConceptId": "llm-execution",
          "stateConceptIds": [
            "llm-execution-requested",
            "llm-execution-in-progress",
            "llm-execution-completed",
            "llm-execution-failed"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "llm-execution-requested",
          "terminalStateIds": [
            "llm-execution-completed",
            "llm-execution-failed"
          ]
        },
        {
          "id": "lifecycle-llm-context-definition-and-use",
          "subjectConceptId": "llm-context",
          "stateConceptIds": [
            "llm-context-defined-on-disk",
            "llm-context-loaded-and-cached"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "llm-context-defined-on-disk",
          "terminalStateIds": [
            "llm-context-loaded-and-cached"
          ]
        }
      ],
      "views": [
        {
          "id": "prompt-template-to-final-request",
          "name": "From prompt template to LLM request",
          "kind": "lifecycle",
          "description": "Shows how a prompt template and its variables are rendered into a concrete LLM request.",
          "conceptIds": [
            "prompt-template",
            "template-variable",
            "template-rendering",
            "template-variable-value",
            "template-variables",
            "active-prompt-template-version",
            "final-prompt",
            "llm-request"
          ],
          "relationshipIds": [
            "rel-prompt-template-has-variables",
            "rel-prompt-template-uses-template-variable",
            "rel-template-variable-in-prompt-template",
            "rel-template-variable-has-value",
            "rel-template-rendering-uses-prompt-template",
            "rel-template-rendering-requires-template-variables",
            "rel-template-rendering-uses-active-prompt-template-version",
            "rel-template-variable-enables-final-prompt",
            "rel-template-rendering-produces-llm-request-prompt",
            "rel-llm-request-associated-with-template"
          ]
        },
        {
          "id": "llm-execution-flow",
          "name": "LLM execution and response flow",
          "kind": "implementation",
          "description": "Shows how an LLM request is executed against a model and produces a structured LLM response.",
          "conceptIds": [
            "llm-request",
            "llm-execution",
            "LLMRequest",
            "LLMResponse",
            "LLMModel",
            "llm-model",
            "llm-response",
            "llm-response-consumption"
          ],
          "relationshipIds": [
            "rel-llm-exec-takes-llmrequest",
            "rel-llm-exec-selects-model",
            "rel-llm-exec-produces-llmresponse",
            "rel-llm-request-uses-model-name",
            "rel-llm-request-precedes-llm-response",
            "rel-llm-response-from-request",
            "rel-llm-response-uses-model",
            "rel-llm-exec-precedes-response-consumption"
          ]
        },
        {
          "id": "llm-context-assembly",
          "name": "LLM context assembly and use",
          "kind": "structure",
          "description": "Shows how LLM context is stored, identified, aggregated, and incorporated into prompts and requests.",
          "conceptIds": [
            "llm-context",
            "markdown-context-file",
            "context-directory",
            "context-name",
            "aggregated-context-payload",
            "llm-prompt",
            "prompt-template",
            "llm-request"
          ],
          "relationshipIds": [
            "rel-llm-context-stored-as-md-file",
            "rel-llm-context-organized-in-context-directory",
            "rel-llm-context-identified-by-name",
            "rel-all-llm-context-aggregated-representation",
            "rel-llm-context-used-by-llm-prompt",
            "rel-llm-context-associated-with-template",
            "rel-llm-context-used-with-llm-request"
          ]
        },
        {
          "id": "llm-job-and-slack-interaction",
          "name": "LLM job interaction with Slack",
          "kind": "overview",
          "description": "Shows how an LLM job uses payloads and thread records to post messages and reactions in Slack.",
          "conceptIds": [
            "llm-job",
            "task-payload",
            "thread-record",
            "slack-thread",
            "slack-message",
            "slack-reaction",
            "job-timing",
            "debug-message"
          ],
          "relationshipIds": [
            "rel-llm-job-uses-taskpayload",
            "rel-llm-job-uses-firestore-thread-doc",
            "rel-llm-job-targets-thread",
            "rel-llm-job-posts-to-slack",
            "rel-llm-job-adds-reactions",
            "rel-llm-job-measures-duration",
            "rel-llm-job-uses-debug-message"
          ]
        },
        {
          "id": "debug-events-around-llm-interactions",
          "name": "Debug events around LLM interactions",
          "kind": "lifecycle",
          "description": "Shows how debug events capture LLM requests, responses, and related Slack and classification context.",
          "conceptIds": [
            "debug-event",
            "slack-thread",
            "llm-request",
            "llm-response",
            "incoming-slack-message",
            "llm-classification",
            "reaction-time-measurement",
            "app-error"
          ],
          "relationshipIds": [
            "rel-debug-event-belongs-to-thread",
            "rel-debug-event-records-llm-request",
            "rel-debug-event-records-llm-response",
            "rel-debug-event-records-slack-message-incoming",
            "rel-debug-event-records-thread-creation",
            "rel-debug-event-records-llm-classification",
            "rel-debug-event-records-time-metric",
            "rel-debug-event-records-error"
          ]
        },
        {
          "id": "error-recording-pipeline",
          "name": "Error recording and persistence pipeline",
          "kind": "datastore",
          "description": "Shows how errors are captured as debug events, classified, and persisted for debugging and observability.",
          "conceptIds": [
            "error-recording",
            "error-occurrence",
            "app-error",
            "error-context",
            "error-handler",
            "debug-event",
            "error-severity",
            "thread-debug-event-store"
          ],
          "relationshipIds": [
            "rel-error-recording-follows-error-occurrence",
            "rel-error-recording-uses-app-error",
            "rel-error-recording-uses-error-context",
            "rel-error-recording-uses-error-handler",
            "rel-error-recording-uses-debug-event",
            "rel-error-recording-uses-error-severity",
            "rel-error-recording-uses-firestore"
          ]
        }
      ],
      "storyViews": [
        {
          "id": "render-template-and-call-llm-for-data-request",
          "name": "Render a Prompt Template and Call the LLM for a Data Request",
          "kind": "system_flow",
          "description": "A background LLM job takes a data request, renders the appropriate prompt template with context, executes the LLM call, and records debug information.",
          "tags": [
            "llm-job",
            "template-rendering",
            "llm-execution",
            "debug-event"
          ],
          "focusConceptId": "llm-job",
          "steps": [
            {
              "id": "job-starts-with-thread-context",
              "index": 0,
              "title": "LLM Job Starts with Thread Context",
              "narrative": "An LLM job is created for a Slack thread, using a task payload that indicates this is a data request and referencing the appropriate prompt template and LLM context.",
              "conceptIds": [
                "llm-job",
                "llm-context",
                "prompt-template"
              ],
              "relationshipIds": [
                "rel-llm-job-uses-taskpayload",
                "rel-llm-job-targets-thread",
                "rel-llm-context-associated-with-template"
              ],
              "primaryConceptIds": [
                "llm-job"
              ],
              "primaryRelationshipIds": [
                "rel-llm-job-uses-taskpayload"
              ]
            },
            {
              "id": "aggregate-context-and-bind-variables",
              "index": 1,
              "title": "Context is Aggregated and Template Variables are Bound",
              "narrative": "The system aggregates all relevant LLM context files and binds them, along with thread-specific values, to the template variables declared by the chosen prompt template.",
              "conceptIds": [
                "llm-context",
                "prompt-template",
                "template-variable"
              ],
              "relationshipIds": [
                "rel-all-llm-context-aggregated-representation",
                "rel-llm-context-used-with-llm-request",
                "rel-prompt-template-has-variables",
                "rel-template-variable-has-value"
              ],
              "primaryConceptIds": [
                "llm-context",
                "template-variable"
              ],
              "primaryRelationshipIds": [
                "rel-all-llm-context-aggregated-representation"
              ]
            },
            {
              "id": "render-template-into-llm-request",
              "index": 2,
              "title": "Template Rendering Produces an LLM Request",
              "narrative": "Template rendering combines the active version of the prompt template with the bound template variables to produce the concrete prompt inside an LLM request, and records a debug event for traceability.",
              "conceptIds": [
                "template-rendering",
                "prompt-template",
                "template-variable",
                "llm-request",
                "debug-event"
              ],
              "relationshipIds": [
                "rel-template-rendering-uses-prompt-template",
                "rel-template-rendering-uses-active-prompt-template-version",
                "rel-template-rendering-requires-template-variables",
                "rel-template-rendering-produces-llm-request-prompt",
                "rel-template-rendering-records-debug-context"
              ],
              "primaryConceptIds": [
                "template-rendering",
                "llm-request"
              ],
              "primaryRelationshipIds": [
                "rel-template-rendering-produces-llm-request-prompt"
              ]
            },
            {
              "id": "execute-llm-call",
              "index": 3,
              "title": "LLM Execution Sends the Request to the Model",
              "narrative": "LLM execution takes the constructed LLM request, selects the appropriate model based on template metadata and environment configuration, and invokes the provider to obtain an LLM response while recording debug events.",
              "conceptIds": [
                "llm-execution",
                "llm-request",
                "llm-response",
                "prompt-template",
                "debug-event"
              ],
              "relationshipIds": [
                "rel-llm-exec-takes-llmrequest",
                "rel-llm-exec-selects-model",
                "rel-llm-exec-uses-template-metadata",
                "rel-llm-exec-uses-environment-config",
                "rel-llm-exec-records-debug-event"
              ],
              "primaryConceptIds": [
                "llm-execution",
                "llm-response"
              ],
              "primaryRelationshipIds": [
                "rel-llm-exec-takes-llmrequest"
              ]
            },
            {
              "id": "record-response-and-thread-debug",
              "index": 4,
              "title": "Response and Debug Events are Recorded for the Thread",
              "narrative": "The resulting LLM response is wrapped with timing and raw provider data, and a debug event is stored for the Slack thread, linking the LLM request and response for later inspection in the evals UI.",
              "conceptIds": [
                "llm-response",
                "debug-event"
              ],
              "relationshipIds": [
                "rel-llm-response-from-request",
                "rel-llm-response-includes-raw-provider-response",
                "rel-llm-response-includes-timing",
                "rel-debug-event-records-llm-request",
                "rel-debug-event-records-llm-response"
              ],
              "primaryConceptIds": [
                "llm-response",
                "debug-event"
              ],
              "primaryRelationshipIds": [
                "rel-debug-event-records-llm-response"
              ]
            }
          ]
        },
        {
          "id": "template-versioning-and-rendering-evolution",
          "name": "Evolving a Prompt Template and Its Effect on Rendering",
          "kind": "admin_flow",
          "description": "An admin updates a prompt template, activates a new version, and subsequent template renderings use the new version while preserving debug traceability.",
          "tags": [
            "prompt-template",
            "versioning",
            "template-rendering"
          ],
          "focusConceptId": "prompt-template",
          "steps": [
            {
              "id": "admin-creates-initial-template",
              "index": 0,
              "title": "Admin Creates an Initial Prompt Template",
              "narrative": "A user acting as an admin creates a new prompt template that targets a specific LLM model and declares the template variables needed for data requests.",
              "conceptIds": [
                "prompt-template",
                "template-variable"
              ],
              "relationshipIds": [
                "rel-user-creates-prompt-template",
                "rel-prompt-template-has-variables",
                "rel-prompt-template-uses-model"
              ],
              "primaryConceptIds": [
                "prompt-template"
              ],
              "primaryRelationshipIds": [
                "rel-user-creates-prompt-template"
              ]
            },
            {
              "id": "template-version-is-established",
              "index": 1,
              "title": "Template Version is Established and Activated",
              "narrative": "The system represents the template as a specific prompt template version, marks it as the active version, and associates it with future template renderings.",
              "conceptIds": [
                "prompt-template"
              ],
              "relationshipIds": [
                "rel-prompt-template-has-version",
                "rel-prompt-template-has-active-version"
              ],
              "primaryConceptIds": [
                "prompt-template"
              ],
              "primaryRelationshipIds": [
                "rel-prompt-template-has-active-version"
              ]
            },
            {
              "id": "render-using-active-version",
              "index": 2,
              "title": "Template Rendering Uses the Active Version",
              "narrative": "When a data request arrives, template rendering uses the active prompt template version and the required template variables to produce an LLM request, recording a debug event that references the template context.",
              "conceptIds": [
                "template-rendering",
                "prompt-template",
                "template-variable",
                "llm-request",
                "debug-event"
              ],
              "relationshipIds": [
                "rel-template-rendering-uses-prompt-template",
                "rel-template-rendering-uses-active-prompt-template-version",
                "rel-template-rendering-requires-template-variables",
                "rel-template-rendering-produces-llm-request-prompt",
                "rel-debug-event-uses-template-context"
              ],
              "primaryConceptIds": [
                "template-rendering"
              ],
              "primaryRelationshipIds": [
                "rel-template-rendering-uses-active-prompt-template-version"
              ]
            },
            {
              "id": "admin-derives-new-template-version",
              "index": 3,
              "title": "Admin Derives and Activates a New Template Version",
              "narrative": "After observing LLM behavior, the admin edits the prompt, creating a new prompt template version derived from the previous one and designates it as the new active version.",
              "conceptIds": [
                "prompt-template"
              ],
              "relationshipIds": [
                "rel-prompt-template-version-derived-from-parent",
                "rel-prompt-template-has-active-version"
              ],
              "primaryConceptIds": [
                "prompt-template"
              ],
              "primaryRelationshipIds": [
                "rel-prompt-template-version-derived-from-parent"
              ]
            },
            {
              "id": "subsequent-renders-use-new-version",
              "index": 4,
              "title": "Subsequent Renderings Use the New Active Version",
              "narrative": "Future template renderings automatically use the updated active prompt template version, and their debug events capture which version was used, enabling comparison of LLM responses across versions.",
              "conceptIds": [
                "template-rendering",
                "prompt-template",
                "llm-response",
                "debug-event"
              ],
              "relationshipIds": [
                "rel-template-rendering-uses-active-prompt-template-version",
                "rel-template-rendering-records-debug-context",
                "rel-llm-response-part-of-orchestration",
                "rel-debug-event-uses-template-context"
              ],
              "primaryConceptIds": [
                "template-rendering",
                "debug-event"
              ],
              "primaryRelationshipIds": [
                "rel-template-rendering-records-debug-context"
              ]
            }
          ]
        },
        {
          "id": "debugging-a-slow-llm-interaction",
          "name": "Debugging a Slow LLM Interaction in a Slack Thread",
          "kind": "error_flow",
          "description": "A slow LLM call in a Slack thread triggers debug events and error recording, allowing engineers to inspect timing and context in the evals UI.",
          "tags": [
            "debug-event",
            "error-recording",
            "timing"
          ],
          "focusConceptId": "debug-event",
          "steps": [
            {
              "id": "slow-llm-execution-occurs",
              "index": 0,
              "title": "An LLM Execution Takes Unusually Long",
              "narrative": "During an LLM job for a Slack thread, the LLM execution experiences an unusually long response time while producing an LLM response.",
              "conceptIds": [
                "llm-execution",
                "llm-response"
              ],
              "relationshipIds": [
                "rel-llm-exec-takes-llmrequest",
                "rel-llm-exec-produces-llmresponse",
                "rel-llm-exec-precedes-response-consumption"
              ],
              "primaryConceptIds": [
                "llm-execution"
              ],
              "primaryRelationshipIds": [
                "rel-llm-exec-produces-llmresponse"
              ]
            },
            {
              "id": "debug-event-records-timing",
              "index": 1,
              "title": "Debug Event Records Timing and Response",
              "narrative": "When the response finally arrives, the system wraps it with timing information and creates a debug event that records the LLM request, LLM response, and a reaction-time measurement for the Slack thread.",
              "conceptIds": [
                "llm-response",
                "debug-event"
              ],
              "relationshipIds": [
                "rel-llm-response-includes-timing",
                "rel-debug-event-belongs-to-thread",
                "rel-debug-event-records-llm-request",
                "rel-debug-event-records-llm-response",
                "rel-debug-event-records-time-metric"
              ],
              "primaryConceptIds": [
                "debug-event"
              ],
              "primaryRelationshipIds": [
                "rel-debug-event-records-time-metric"
              ]
            },
            {
              "id": "error-recording-captures-slow-event",
              "index": 2,
              "title": "Error Recording Captures the Slow Interaction",
              "narrative": "An error-recording activity classifies the slow response as an application error with a severity level, represents it as a debug event, and persists it in the thread’s debug event store.",
              "conceptIds": [
                "error-recording",
                "debug-event"
              ],
              "relationshipIds": [
                "rel-error-recording-uses-debug-event",
                "rel-error-recording-uses-error-severity",
                "rel-error-recording-uses-app-error",
                "rel-error-recording-uses-firestore"
              ],
              "primaryConceptIds": [
                "error-recording"
              ],
              "primaryRelationshipIds": [
                "rel-error-recording-uses-debug-event"
              ]
            },
            {
              "id": "engineer-inspects-in-evals-ui",
              "index": 3,
              "title": "Engineer Inspects the Interaction in the Evals UI",
              "narrative": "Later, an engineer opens the evals UI, where the debug event for this thread is displayed, allowing them to inspect the LLM request, response, and timing to diagnose the slowdown.",
              "conceptIds": [
                "debug-event"
              ],
              "relationshipIds": [
                "rel-debug-event-viewed-in-evals-ui",
                "rel-debug-event-linked-by-request-id"
              ],
              "primaryConceptIds": [
                "debug-event"
              ],
              "primaryRelationshipIds": [
                "rel-debug-event-viewed-in-evals-ui"
              ]
            }
          ]
        },
        {
          "id": "context-enriched-llm-request-for-iteration",
          "name": "Context-Enriched LLM Request for Iterating on a Data Request",
          "kind": "system_flow",
          "description": "The system enriches an LLM request with stored context and template variables to iterate on a user’s data request in a Slack thread.",
          "tags": [
            "llm-context",
            "template-variable",
            "llm-request"
          ],
          "focusConceptId": "llm-context",
          "steps": [
            {
              "id": "context-files-are-prepared",
              "index": 0,
              "title": "Context Files are Prepared for the Thread",
              "narrative": "Relevant LLM context for the Slack thread is stored as markdown files in a context directory and identified by a context name for later aggregation.",
              "conceptIds": [
                "llm-context"
              ],
              "relationshipIds": [
                "rel-llm-context-stored-as-md-file",
                "rel-llm-context-organized-in-context-directory",
                "rel-llm-context-identified-by-name"
              ],
              "primaryConceptIds": [
                "llm-context"
              ],
              "primaryRelationshipIds": [
                "rel-llm-context-stored-as-md-file"
              ]
            },
            {
              "id": "context-aggregated-into-request",
              "index": 1,
              "title": "Context is Aggregated into the LLM Request",
              "narrative": "When the user asks to iterate on a data request, the system aggregates all LLM context into a payload and incorporates it into a new LLM request associated with the relevant prompt template.",
              "conceptIds": [
                "llm-context",
                "llm-request",
                "prompt-template"
              ],
              "relationshipIds": [
                "rel-all-llm-context-aggregated-representation",
                "rel-llm-context-used-with-llm-request",
                "rel-llm-context-associated-with-template",
                "rel-llm-request-associated-with-template"
              ],
              "primaryConceptIds": [
                "llm-context",
                "llm-request"
              ],
              "primaryRelationshipIds": [
                "rel-llm-context-used-with-llm-request"
              ]
            },
            {
              "id": "variables-enable-final-prompt",
              "index": 2,
              "title": "Template Variables Enable Construction of the Final Prompt",
              "narrative": "Template variables, including those derived from the aggregated context and user’s new instructions, are bound and used to construct the final prompt content inside the LLM request.",
              "conceptIds": [
                "template-variable",
                "llm-request",
                "prompt-template"
              ],
              "relationshipIds": [
                "rel-prompt-template-uses-template-variable",
                "rel-template-variable-has-value",
                "rel-template-variable-enables-final-prompt",
                "rel-llm-context-used-by-llm-prompt"
              ],
              "primaryConceptIds": [
                "template-variable"
              ],
              "primaryRelationshipIds": [
                "rel-template-variable-enables-final-prompt"
              ]
            },
            {
              "id": "llm-execution-produces-iterated-response",
              "index": 3,
              "title": "LLM Execution Produces an Iterated Response",
              "narrative": "LLM execution sends the enriched LLM request to the selected model, producing an LLM response that reflects both the prior context and the user’s new iteration instructions.",
              "conceptIds": [
                "llm-execution",
                "llm-request",
                "llm-response"
              ],
              "relationshipIds": [
                "rel-llm-exec-takes-llmrequest",
                "rel-llm-exec-produces-llmresponse",
                "rel-llm-request-precedes-llm-response",
                "rel-llm-response-from-request"
              ],
              "primaryConceptIds": [
                "llm-execution",
                "llm-response"
              ],
              "primaryRelationshipIds": [
                "rel-llm-exec-produces-llmresponse"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "template-management-and-evals",
      "title": "Template Management and Evaluation",
      "description": "How admins manage prompt templates, define checks and test cases, and evaluate LLM behavior over time.",
      "concepts": [
        {
          "id": "template",
          "label": "Template",
          "category": "thing",
          "description": "A configurable artifact that defines how the system should prompt LLMs for a particular use case.",
          "aliases": [
            "template",
            "prompt template",
            "Template",
            "PromptTemplate",
            "template metadata",
            "template version"
          ],
          "notes": "A Template is a configurable artifact that defines how the system should prompt LLMs for a particular use case. It is stored in Firestore under the 'promptTemplates' collection as a metadata document plus a 'versions' subcollection. The worker side uses a resolved PromptTemplate (including the currently active version content) to render prompts and call LLMs. The UI side manages Template metadata and TemplateVersion records, including editing, versioning, and activation."
        },
        {
          "id": "template-version",
          "label": "Template version",
          "category": "thing",
          "description": "A specific revision of a template that can be activated, tested, and compared against others.",
          "aliases": [
            "TemplateVersion",
            "version",
            "template version",
            "prompt template version",
            "activeVersion",
            "versions"
          ],
          "notes": "A Template version is a specific saved revision of a prompt template. Each version captures the concrete prompt text (`template`), its variable placeholders, metadata about who created it and when, optional change notes, and the model it targets. Versions are stored under a parent Template (e.g., in a `versions` subcollection) and one of them can be marked as the active version for that Template. The active version is the one fetched and used at runtime for rendering and evaluation."
        },
        {
          "id": "active-template",
          "label": "Active template",
          "category": "state",
          "description": "The currently selected template version that production workflows use for LLM prompts.",
          "aliases": [
            "active-template",
            "active version",
            "activeVersion",
            "isActive template",
            "current template version",
            "production template version"
          ],
          "notes": "An Active template is the specific version of a prompt template that is currently designated for use in production workflows. It is identified by the `activeVersion` field on the template's metadata document and corresponds to a concrete version document in the `versions` subcollection. Fetching an active template always means: look up the template metadata by templateId, read its `activeVersion`, then load that exact version document and use its content (prompt text, variables, model, etc.) for rendering and for LLM calls. The `isActive` flag on the version record is expected to be true for the version referenced by `activeVersion`."
        },
        {
          "id": "template-editing",
          "label": "Template editing",
          "category": "activity",
          "description": "The activity of modifying template content, variables, and metadata through an editor interface.",
          "aliases": [
            "template-editing",
            "edit template",
            "editingTemplate",
            "isEditing",
            "TemplateEditorTab",
            "template editor",
            "template content editing"
          ],
          "notes": "Template editing is the activity where a user modifies the text body of a template (including embedded EJS-style variables and control tags), along with associated metadata such as change notes and model selection, through an interactive editor interface. In this system, the editor is implemented with a CodeMirror-based component configured for EJS-like syntax highlighting, and is toggled between editable and read-only modes via an `isEditing` flag. The user works on an editable copy (`editingTemplate`) of a specific template version, and can then save changes, update notes, or mark a version as active."
        },
        {
          "id": "test-case",
          "label": "Test case",
          "category": "thing",
          "description": "A predefined scenario with inputs and expected behavior used to evaluate a template or LLM workflow.",
          "aliases": [
            "TestCase",
            "test case",
            "template test case",
            "evals UI test case"
          ],
          "notes": "A test case is a predefined scenario, tied to a specific prompt template, that specifies input variables and associated checks to evaluate how the template or LLM workflow behaves. In this system it is currently a UI-only concept stored under a prompt template's 'testCases' collection. Each test case has metadata (name, description, tags, creator, timestamps), a set of inputVariables (mapped by variable name), and a list of checkIds indicating which evaluation checks should be run when the test case is executed. Test cases can be created, edited, deleted, and executed individually or as part of a batch for a given template."
        },
        {
          "id": "check",
          "label": "Check",
          "category": "thing",
          "description": "A rule or assertion applied to LLM outputs to determine whether they meet certain criteria.",
          "aliases": [
            "check",
            "LLM check",
            "validation check",
            "evaluation check"
          ],
          "notes": "A Check is a reusable, named rule or assertion that describes criteria for judging whether an LLM output is acceptable. It is authored and maintained by users, stored in a shared 'checks' collection, and later executed as part of test runs. Each Check includes human-readable criteria text and a preferred LLM model to use when evaluating those criteria via a dedicated check-validation prompt template. Checks are independent artifacts that can be attached to multiple test runs or test cases."
        },
        {
          "id": "test-execution",
          "label": "Test execution",
          "category": "activity",
          "description": "The process of running templates against test cases, executing checks, and collecting results.",
          "aliases": [
            "test-execution",
            "executeTest",
            "test execution job",
            "test run",
            "test case execution",
            "individual test execution"
          ],
          "notes": "Test execution is the process of running a single template test case: fetching the active template, rendering it with the test case's input variables, executing the LLM prompt, running assigned checks, and persisting the results as a test run. In the system, individual test executions are typically triggered via a callable function, enqueued into a worker job (optionally as part of a batch), and executed in the shared runtime. The UI tracks running tests and the last batch result, and prevents duplicate executions of the same test case concurrently."
        },
        {
          "id": "test-result",
          "label": "Test result",
          "category": "thing",
          "description": "The outcome of running a template against a test case, including pass/fail status and any errors.",
          "aliases": [
            "test-result",
            "test run",
            "TestRunPass",
            "TestRunFail",
            "TestRunError",
            "test run result",
            "check result",
            "CheckResult"
          ],
          "notes": "A test result is the recorded outcome of executing a specific template against a specific test case, optionally including the outcomes of one or more checks. In code this appears as discriminated union types TestRunPass, TestRunFail, and TestRunError, and is associated with CheckResult entries for individual checks."
        },
        {
          "id": "test-batch",
          "label": "Test batch",
          "category": "thing",
          "description": "A grouped set of test executions run together to evaluate a template across many scenarios.",
          "aliases": [
            "test-batch",
            "TestBatch",
            "batch"
          ],
          "notes": "A Test Batch is a grouped set of test executions that are run together for a specific prompt template, typically to evaluate that template across one or more test cases. All test executions in the system are associated with a batch (even a single-test execution creates a batch). A batch is stored in the 'testBatches' Firestore collection and is identified by a batchId (e.g., 'batch_<timestamp>_<random>'). It tracks aggregate progress (totalTestCases, completedCount) and an overall status (e.g., pending, running, completed, cancelled, failed). Batches are user-initiated and template-specific, and can be monitored via UI components such as BatchProgressIndicator and BatchDetailModal."
        },
        {
          "id": "evaluation-checks-page",
          "label": "Checks management view",
          "category": "other",
          "description": "An admin-facing view for browsing and managing checks used in evaluations.",
          "aliases": [
            "Checks management view",
            "Checks page",
            "Checks screen",
            "Checks admin view",
            "Checks management UI"
          ],
          "notes": "An admin-facing page for browsing and managing evaluation checks. Implemented as the Checks React page/component, it lists existing checks and allows authorized users to create, edit, and delete Check definitions via forms and modals. It is part of the Template Management and Evaluation model and operates on shared Check domain objects."
        },
        {
          "id": "template-manager-page",
          "label": "Template manager view",
          "category": "other",
          "description": "An admin-facing view for managing templates, versions, test cases, and results.",
          "aliases": [
            "template-manager-page",
            "TemplateManager",
            "Template manager view",
            "Template Management UI",
            "Template admin view"
          ],
          "notes": "The template manager view is an admin-facing page (TemplateManager component) that lets an authenticated user manage templates, their versions, associated test cases, and test results. It coordinates multiple tabs and sidebars: a template editor tab for editing template content and creating new versions, a version sidebar for selecting and activating versions, a test cases tab for defining and running test cases against a selected template/version, and a test results tab for reviewing execution outcomes. It loads templates and template versions from persistent storage, tracks the currently selected template and version, and passes these into the specialized subviews. The design explicitly separates saving a new template version from activating it, so admins can review and test changes before deployment."
        }
      ],
      "relationships": [
        {
          "id": "rel-template-has-versions",
          "from": "template",
          "to": "template-version",
          "phrase": "has versions",
          "category": "part_of",
          "description": "A Template has one or more TemplateVersions stored in a 'versions' subcollection; each version captures a specific revision of the prompt content and related metadata."
        },
        {
          "id": "rel-template-has-active-version",
          "from": "template",
          "to": "template-version",
          "phrase": "has active version",
          "category": "other",
          "description": "A Template designates exactly one TemplateVersion as its activeVersion, which is the version used by the worker when fetching the active template for LLM prompting."
        },
        {
          "id": "rel-template-version-belongs-to-template",
          "from": "template-version",
          "to": "template",
          "phrase": "belongs to",
          "category": "part_of",
          "description": "Each TemplateVersion belongs to a single Template, identified by the parent template document in the 'promptTemplates' collection."
        },
        {
          "id": "rel-template-version-created-by-user",
          "from": "template-version",
          "to": "user",
          "phrase": "is created by",
          "category": "other",
          "description": "Each TemplateVersion records the identifier of the User who created it in the createdBy field."
        },
        {
          "id": "rel-template-uses-model",
          "from": "template",
          "to": "llm-model",
          "phrase": "uses",
          "category": "uses",
          "description": "A Template (via its active TemplateVersion) specifies which LLM model should be used when rendering and sending prompts, chosen from a constrained set of model identifiers."
        },
        {
          "id": "rel-template-version-uses-variables",
          "from": "template-version",
          "to": "template-variable",
          "phrase": "uses variables",
          "category": "uses",
          "description": "A TemplateVersion declares a list of variables that are expected to be provided when rendering the template content into a concrete prompt."
        },
        {
          "id": "rel-template-version-derived-from-parent-version",
          "from": "template-version",
          "to": "template-version",
          "phrase": "is derived from",
          "category": "other",
          "description": "A TemplateVersion may reference a parentVersion, indicating it was derived from or based on a previous version of the same Template."
        },
        {
          "id": "rel-template-used-by-worker-to-prompt-llm",
          "from": "template",
          "to": "llm-prompt",
          "phrase": "defines",
          "category": "represents",
          "description": "The active Template for a use case defines the structure and content of the LLM prompt that the worker will render and send."
        },
        {
          "id": "rel-template-tagged-with-tags",
          "from": "template",
          "to": "tag",
          "phrase": "is tagged with",
          "category": "other",
          "description": "A Template can be associated with one or more tags to categorize or filter templates in the management UI and worker."
        },
        {
          "id": "rel-template-has-versions",
          "from": "template",
          "to": "template-version",
          "phrase": "has versions",
          "category": "part_of",
          "description": "A Template has one or more Template versions stored under it (e.g., in a `versions` subcollection)."
        },
        {
          "id": "rel-template-version-belongs-to-template",
          "from": "template-version",
          "to": "template",
          "phrase": "belongs to",
          "category": "part_of",
          "description": "Each Template version belongs to exactly one parent Template, identified by the Template's ID."
        },
        {
          "id": "rel-template-has-active-version",
          "from": "template",
          "to": "template-version",
          "phrase": "has active version",
          "category": "other",
          "description": "A Template records which Template version is currently active via its `activeVersion` field."
        },
        {
          "id": "rel-template-version-can-be-active-for-template",
          "from": "template-version",
          "to": "template",
          "phrase": "can be active for",
          "category": "other",
          "description": "A Template version can be designated as the active version for its parent Template, indicated by `isActive` on the version and `activeVersion` on the Template."
        },
        {
          "id": "rel-template-version-uses-model",
          "from": "template-version",
          "to": "llm-model",
          "phrase": "targets model",
          "category": "uses",
          "description": "A Template version specifies which LLM model it is intended for via its `model` field (e.g., `gemini-2.5-flash`, `gemini-2.5-pro`, `gemini-3-pro-preview`)."
        },
        {
          "id": "rel-template-version-has-variables",
          "from": "template-version",
          "to": "template-variable",
          "phrase": "has variables",
          "category": "part_of",
          "description": "A Template version defines a set of variable placeholders (`variables`) that must be provided when rendering the prompt."
        },
        {
          "id": "rel-template-version-created-by-user",
          "from": "template-version",
          "to": "user",
          "phrase": "is created by",
          "category": "other",
          "description": "Each Template version records the identifier of the user who created it in the `createdBy` field."
        },
        {
          "id": "rel-template-version-derived-from-parent-version",
          "from": "template-version",
          "to": "template-version",
          "phrase": "is derived from",
          "category": "precedes",
          "description": "A Template version may reference a `parentVersion`, indicating it was derived from an earlier Template version."
        },
        {
          "id": "rel-template-version-has-change-notes",
          "from": "template-version",
          "to": "change-notes",
          "phrase": "has change notes",
          "category": "other",
          "description": "A Template version can include `changeNotes` describing what changed in that revision."
        },
        {
          "id": "rel-template-version-used-as-prompt-template",
          "from": "template-version",
          "to": "prompt-template",
          "phrase": "is used as",
          "category": "represents",
          "description": "When fetched as the active version, a Template version is materialized as a PromptTemplate object used for rendering and evaluation."
        },
        {
          "id": "rel-active-template-of-template",
          "from": "active-template",
          "to": "prompt-template",
          "phrase": "is a version of",
          "category": "is_a",
          "description": "An active template is a specific version instance of a broader prompt template identified by a templateId."
        },
        {
          "id": "rel-template-has-active-version",
          "from": "prompt-template",
          "to": "active-template",
          "phrase": "has active version",
          "category": "part_of",
          "description": "A prompt template has one designated active template version, referenced by its metadata field `activeVersion`."
        },
        {
          "id": "rel-active-template-stored-in-collection",
          "from": "active-template",
          "to": "prompt-template-version-document",
          "phrase": "is stored as",
          "category": "represents",
          "description": "An active template is stored as a document in the `versions` subcollection under a `promptTemplates/{templateId}` document, with the document ID equal to the numeric activeVersion converted to string."
        },
        {
          "id": "rel-active-template-used-by-rendering",
          "from": "active-template",
          "to": "template-rendering",
          "phrase": "is used by",
          "category": "uses",
          "description": "The active template is used as input to the EJS-based rendering process that produces concrete LLM prompts."
        },
        {
          "id": "rel-active-template-enables-llm-prompts",
          "from": "active-template",
          "to": "llm-prompt",
          "phrase": "enables creation of",
          "category": "enables",
          "description": "The active template enables the creation of concrete LLM prompts by defining the template string and required variables."
        },
        {
          "id": "rel-active-template-uses-variables",
          "from": "active-template",
          "to": "template-variable",
          "phrase": "declares required",
          "category": "uses",
          "description": "An active template declares a set of required variables that must be provided when rendering the template."
        },
        {
          "id": "rel-active-template-associated-with-model",
          "from": "active-template",
          "to": "llm-model",
          "phrase": "is associated with",
          "category": "uses",
          "description": "An active template is associated with a specific LLM model via its `model` field, indicating which model should be used when executing prompts based on this template."
        },
        {
          "id": "rel-active-template-selected-by-production-workflows",
          "from": "production-workflow",
          "to": "active-template",
          "phrase": "selects",
          "category": "uses",
          "description": "Production workflows select and use the active template for a given templateId when generating prompts."
        },
        {
          "id": "rel-active-template-fetched-from-store",
          "from": "active-template",
          "to": "template-store",
          "phrase": "is fetched from",
          "category": "uses",
          "description": "The active template is fetched from the template store (backed by Firestore collections `promptTemplates` and their `versions` subcollections) when needed by workers and evaluation functions."
        },
        {
          "id": "rel-template-editing-uses-template-version",
          "from": "template-editing",
          "to": "template-version",
          "phrase": "edits",
          "category": "uses",
          "description": "Template editing operates on a specific template version, allowing the user to modify that version's template content and related metadata."
        },
        {
          "id": "rel-template-editing-uses-template-content",
          "from": "template-editing",
          "to": "template-content",
          "phrase": "modifies",
          "category": "uses",
          "description": "Template editing modifies the textual template content, including EJS-style delimiters, output, control, unescaped, and comment sections."
        },
        {
          "id": "rel-template-editing-uses-template-variables",
          "from": "template-editing",
          "to": "template-variables",
          "phrase": "is guided by",
          "category": "uses",
          "description": "Template editing is informed by the list of variables associated with a template version, so that the editor can present and maintain variable placeholders within the template content."
        },
        {
          "id": "rel-template-editing-uses-model-selection",
          "from": "template-editing",
          "to": "model-selection",
          "phrase": "updates",
          "category": "uses",
          "description": "During template editing, the user can change the selected model associated with the template version (e.g., 'gemini-2.5-flash', 'gemini-2.5-pro', 'gemini-3-pro-preview')."
        },
        {
          "id": "rel-template-editing-uses-change-notes",
          "from": "template-editing",
          "to": "template-change-notes",
          "phrase": "updates",
          "category": "uses",
          "description": "Template editing includes updating change notes that describe what was modified in the template version."
        },
        {
          "id": "rel-template-editing-uses-editor-interface",
          "from": "template-editing",
          "to": "template-editor-interface",
          "phrase": "is performed through",
          "category": "uses",
          "description": "Template editing is performed through a template editor interface, which includes a CodeMirror-based code editor and UI controls for saving, copying, and activating versions."
        },
        {
          "id": "rel-template-editing-uses-syntax-highlighting",
          "from": "template-editing",
          "to": "template-syntax-highlighting",
          "phrase": "uses",
          "category": "uses",
          "description": "Template editing uses EJS-specific syntax highlighting to visually distinguish delimiters, output, control, unescaped, and comment segments in the template content."
        },
        {
          "id": "rel-template-editing-precedes-save-template",
          "from": "template-editing",
          "to": "template-saving",
          "phrase": "precedes",
          "category": "precedes",
          "description": "Template editing typically occurs before a user saves the modified template version via the save-template action."
        },
        {
          "id": "rel-template-editing-precedes-make-active",
          "from": "template-editing",
          "to": "template-activation",
          "phrase": "may precede",
          "category": "precedes",
          "description": "After template editing and saving, a user may mark the edited version as the active template."
        },
        {
          "id": "rel-template-editing-uses-copy-to-clipboard",
          "from": "template-editing",
          "to": "template-copying",
          "phrase": "enables",
          "category": "enables",
          "description": "Within the template editor, users can copy template content or related items to the clipboard to reuse or inspect template definitions."
        },
        {
          "id": "rel-template-editing-uses-editing-flags",
          "from": "template-editing",
          "to": "editing-state-flag",
          "phrase": "is controlled by",
          "category": "uses",
          "description": "Template editing is controlled by an editing state flag (`isEditing` / `isEditingRef`) that determines whether the editor is in editable or read-only mode."
        },
        {
          "id": "rel-test-case-part-of-template",
          "from": "test-case",
          "to": "prompt-template",
          "phrase": "is stored under",
          "category": "part_of",
          "description": "Each test case belongs to a specific prompt template and is stored in that template's 'testCases' subcollection."
        },
        {
          "id": "rel-template-has-test-cases",
          "from": "prompt-template",
          "to": "test-case",
          "phrase": "has",
          "category": "part_of",
          "description": "A prompt template can have zero or more test cases defined to evaluate its behavior with different inputs."
        },
        {
          "id": "rel-test-case-uses-input-variables",
          "from": "test-case",
          "to": "input-variables",
          "phrase": "defines",
          "category": "uses",
          "description": "A test case defines a set of inputVariables that are supplied to the template or workflow when the test is executed."
        },
        {
          "id": "rel-test-case-selects-checks",
          "from": "test-case",
          "to": "check",
          "phrase": "selects",
          "category": "uses",
          "description": "A test case references one or more checks via checkIds, indicating which evaluation checks should be run for that scenario."
        },
        {
          "id": "rel-test-case-has-tags",
          "from": "test-case",
          "to": "tag",
          "phrase": "has",
          "category": "part_of",
          "description": "A test case can be labeled with tags to categorize or group related scenarios."
        },
        {
          "id": "rel-test-case-created-by-user",
          "from": "test-case",
          "to": "user",
          "phrase": "is created by",
          "category": "other",
          "description": "Each test case records the identifier of the user who created it in the createdBy field."
        },
        {
          "id": "rel-test-case-participates-in-test-run",
          "from": "test-case",
          "to": "test-run",
          "phrase": "is executed in",
          "category": "uses",
          "description": "When a test case is run, a test run record (pass, fail, or error) is created that references the testCaseId."
        },
        {
          "id": "rel-test-run-evaluates-test-case",
          "from": "test-run",
          "to": "test-case",
          "phrase": "evaluates",
          "category": "uses",
          "description": "A test run represents the execution of a specific test case against a particular template version."
        },
        {
          "id": "rel-test-case-executed-by-user",
          "from": "user",
          "to": "test-case",
          "phrase": "executes",
          "category": "other",
          "description": "A user can trigger execution of a test case, resulting in a test run."
        },
        {
          "id": "rel-test-case-included-in-test-batch",
          "from": "test-case",
          "to": "test-batch",
          "phrase": "is included in",
          "category": "part_of",
          "description": "A test case can be executed as part of a batch of tests for a template when batchRunning is active."
        },
        {
          "id": "rel-check-collection",
          "from": "check",
          "to": "checks-collection",
          "phrase": "is stored in",
          "category": "part_of",
          "description": "Each Check is persisted as a document in the Firestore 'checks' collection."
        },
        {
          "id": "rel-check-created-by-user",
          "from": "check",
          "to": "user",
          "phrase": "is created by",
          "category": "other",
          "description": "A Check records the identifier of the user who created it in the createdBy field."
        },
        {
          "id": "rel-check-uses-model",
          "from": "check",
          "to": "llm-model",
          "phrase": "prefers",
          "category": "uses",
          "description": "A Check specifies a preferred LLM model (e.g., Gemini variants) that should be used when evaluating its criteria."
        },
        {
          "id": "rel-check-used-in-test-run",
          "from": "check",
          "to": "test-run",
          "phrase": "is executed in",
          "category": "uses",
          "description": "One or more Checks are executed as part of a test run to evaluate a specific LLM output."
        },
        {
          "id": "rel-test-run-selects-checks",
          "from": "test-run",
          "to": "check",
          "phrase": "selects",
          "category": "uses",
          "description": "A test run references a set of Check IDs that should be applied to the test input and output."
        },
        {
          "id": "rel-check-produces-check-result",
          "from": "check",
          "to": "check-result",
          "phrase": "produces",
          "category": "causes",
          "description": "When executed in a test run, a Check yields a CheckResult indicating pass or fail, reasoning, and timing information."
        },
        {
          "id": "rel-check-uses-check-validation-template",
          "from": "check",
          "to": "check-validation-template",
          "phrase": "is evaluated via",
          "category": "uses",
          "description": "Each Check is evaluated by rendering and executing a dedicated 'check_validation' PromptTemplate that incorporates the Check's criteria, test input, and test output."
        },
        {
          "id": "rel-check-uses-prompt-template",
          "from": "check",
          "to": "prompt-template",
          "phrase": "is evaluated using",
          "category": "uses",
          "description": "Check execution uses a PromptTemplate to construct the LLM prompt that applies the Check's criteria to a given test case."
        },
        {
          "id": "rel-check-has-criteria",
          "from": "check",
          "to": "check-criteria",
          "phrase": "has",
          "category": "part_of",
          "description": "A Check contains human-readable criteria text that describes the rule or assertion to apply to an LLM output."
        },
        {
          "id": "rel-check-listed-in-ui",
          "from": "check",
          "to": "checks-list-view",
          "phrase": "appears in",
          "category": "other",
          "description": "Checks are displayed in a UI list where users can view, edit, and delete them."
        },
        {
          "id": "rel-check-edited-via-form",
          "from": "check",
          "to": "check-form",
          "phrase": "is edited via",
          "category": "uses",
          "description": "Users create and modify Checks through a CheckForm that captures name, criteria, and model."
        },
        {
          "id": "rel-test-execution-uses-template",
          "from": "test-execution",
          "to": "template",
          "phrase": "uses active version of",
          "category": "uses",
          "description": "A test execution fetches and uses the active version of a prompt template to generate the prompt that will be sent to the model."
        },
        {
          "id": "rel-test-execution-executes-test-case",
          "from": "test-execution",
          "to": "test-case",
          "phrase": "executes",
          "category": "uses",
          "description": "A test execution runs a specific test case, using its ID and input variables to drive the prompt rendering and checks."
        },
        {
          "id": "rel-test-execution-belongs-to-batch",
          "from": "test-execution",
          "to": "test-batch",
          "phrase": "belongs to",
          "category": "part_of",
          "description": "Each test execution is associated with a test batch via a batchId, allowing multiple test executions to be grouped and managed together."
        },
        {
          "id": "rel-test-execution-uses-input-variables",
          "from": "test-execution",
          "to": "input-variables",
          "phrase": "renders template with",
          "category": "uses",
          "description": "A test execution uses the input variables defined on the test case to render the template into a concrete prompt."
        },
        {
          "id": "rel-test-execution-uses-model",
          "from": "test-execution",
          "to": "llm-model",
          "phrase": "executes prompt on",
          "category": "uses",
          "description": "A test execution sends the rendered prompt to a specific LLM model (either the template's configured model or a default) to obtain a response."
        },
        {
          "id": "rel-test-execution-produces-test-run-result",
          "from": "test-execution",
          "to": "test-run-result",
          "phrase": "produces",
          "category": "causes",
          "description": "A test execution produces a test run result record, including the model output text, model name, overall status, and execution timestamp."
        },
        {
          "id": "rel-test-execution-runs-checks",
          "from": "test-execution",
          "to": "check",
          "phrase": "runs assigned",
          "category": "uses",
          "description": "A test execution runs the checks assigned to the test case against the model output and records individual check results."
        },
        {
          "id": "rel-test-execution-initiated-by-user",
          "from": "test-execution",
          "to": "user",
          "phrase": "is initiated by",
          "category": "causes",
          "description": "A user initiates a test execution via an authenticated callable function, which enqueues the work to a worker."
        },
        {
          "id": "rel-test-execution-enqueued-as-task",
          "from": "test-execution",
          "to": "test-execution-task",
          "phrase": "is represented by",
          "category": "represents",
          "description": "In the worker system, a test execution is represented as a TestExecutionTaskPayload task that the worker processes."
        },
        {
          "id": "rel-test-execution-checked-against-batch-status",
          "from": "test-execution",
          "to": "test-batch-status",
          "phrase": "is conditioned on",
          "category": "prevents",
          "description": "Before running, a test execution checks the status of its batch and is skipped if the batch is missing or cancelled."
        },
        {
          "id": "rel-test-execution-tracked-by-ui",
          "from": "test-execution",
          "to": "ui-running-tests-indicator",
          "phrase": "is tracked by",
          "category": "represents",
          "description": "The UI maintains a set of runningTests to represent which test executions are currently in progress and to prevent duplicate starts."
        },
        {
          "id": "rel-test-result-tests-test-case",
          "from": "test-result",
          "to": "test-case",
          "phrase": "evaluates",
          "category": "uses",
          "description": "Each test result is produced by running a specific test case; it records the outcome of evaluating that test case."
        },
        {
          "id": "rel-test-result-uses-template",
          "from": "test-result",
          "to": "template",
          "phrase": "uses",
          "category": "uses",
          "description": "Each test result is produced by executing a specific template (and version) against a test case."
        },
        {
          "id": "rel-test-result-refers-to-template-version",
          "from": "test-result",
          "to": "template-version",
          "phrase": "refers to",
          "category": "uses",
          "description": "Each test result records which version of the template was used when the test was executed, when that information is available."
        },
        {
          "id": "rel-test-result-executed-by-user",
          "from": "test-result",
          "to": "user",
          "phrase": "is executed by",
          "category": "uses",
          "description": "Each test result records the user who initiated or executed the test run."
        },
        {
          "id": "rel-test-result-in-batch",
          "from": "test-result",
          "to": "test-batch",
          "phrase": "belongs to",
          "category": "part_of",
          "description": "Individual test results are grouped into test batches, which represent a coordinated execution of multiple test runs for a template."
        },
        {
          "id": "rel-test-result-has-check-results",
          "from": "test-result",
          "to": "check-result",
          "phrase": "has",
          "category": "part_of",
          "description": "A test result may include multiple check results, each representing the outcome of a specific check applied to the test run."
        },
        {
          "id": "rel-check-result-applies-check",
          "from": "check-result",
          "to": "check",
          "phrase": "applies",
          "category": "uses",
          "description": "Each check result records the outcome of applying a specific check to a test run."
        },
        {
          "id": "rel-check-result-refers-to-test-result",
          "from": "check-result",
          "to": "test-result",
          "phrase": "refers to",
          "category": "part_of",
          "description": "Each check result is associated with a specific test run via its testRunId, tying the check outcome to a particular test result."
        },
        {
          "id": "rel-test-case-selects-checks",
          "from": "test-case",
          "to": "check",
          "phrase": "selects",
          "category": "uses",
          "description": "A test case specifies which checks should be run against it via its list of check IDs; these checks then produce check results within the test result."
        },
        {
          "id": "rel-test-result-refers-to-request",
          "from": "test-result",
          "to": "request",
          "phrase": "refers to",
          "category": "uses",
          "description": "A test result references the underlying request that was sent when executing the template, allowing traceability to the concrete LLM or data request."
        },
        {
          "id": "rel-test-result-refers-to-thread",
          "from": "test-result",
          "to": "thread",
          "phrase": "refers to",
          "category": "uses",
          "description": "A test result references the conversation or thread in which the test execution occurred, enabling navigation back to the interaction context."
        },
        {
          "id": "rel-test-batch-template",
          "from": "test-batch",
          "to": "prompt-template",
          "phrase": "evaluates",
          "category": "uses",
          "description": "A Test Batch evaluates a specific Prompt Template. Each batch document includes a templateId, and queries for batches are filtered by templateId to show batches for a given template."
        },
        {
          "id": "rel-test-batch-test-execution",
          "from": "test-batch",
          "to": "test-execution",
          "phrase": "groups",
          "category": "part_of",
          "description": "A Test Batch groups multiple Test Executions that belong to it. Each TestExecutionTaskPayload includes a batchId, indicating that all test executions are part of some batch."
        },
        {
          "id": "rel-test-batch-test-case",
          "from": "test-batch",
          "to": "test-case",
          "phrase": "runs",
          "category": "uses",
          "description": "A Test Batch runs one or more Test Cases. The executeTest function creates a batch even for a single testCaseId, and TestExecutionTaskPayload includes both batchId and testCaseId, linking each test case execution to its batch."
        },
        {
          "id": "rel-test-batch-user",
          "from": "test-batch",
          "to": "user",
          "phrase": "is initiated by",
          "category": "causes",
          "description": "A Test Batch is initiated by an authenticated User. The executeTest callable function requires request.auth and uses request.auth.uid as userId when creating a batch and its execution tasks."
        },
        {
          "id": "rel-test-batch-test-batch-result",
          "from": "test-batch",
          "to": "test-batch-result",
          "phrase": "has aggregate results",
          "category": "part_of",
          "description": "A Test Batch has associated Test Batch Results that summarize or detail the outcomes of the test executions in the batch. BatchDetailModal loads TestBatchResult records for a given batchId to display batch-level evaluation outcomes."
        },
        {
          "id": "rel-test-batch-debug-event",
          "from": "test-batch",
          "to": "debug-event",
          "phrase": "is associated with",
          "category": "uses",
          "description": "A Test Batch is associated with Debug Events (such as llm_request and llm_response) that capture diagnostic information for the LLM calls made during the batch's test executions. BatchDetailModal displays these debug events in the context of a specific batch."
        },
        {
          "id": "rel-checks-page-uses-check-entities",
          "from": "evaluation-checks-page",
          "to": "evaluation-check",
          "phrase": "lists and manages",
          "category": "uses",
          "description": "The Checks management view displays a collection of Check entities and allows admins to create, edit, and delete them."
        },
        {
          "id": "rel-checks-page-uses-check-form",
          "from": "evaluation-checks-page",
          "to": "evaluation-check-form",
          "phrase": "uses",
          "category": "uses",
          "description": "The Checks management view uses a Check form component to capture and edit Check details when creating or updating a Check."
        },
        {
          "id": "rel-checks-page-uses-check-item",
          "from": "evaluation-checks-page",
          "to": "evaluation-check-list-item",
          "phrase": "renders",
          "category": "uses",
          "description": "The Checks management view renders individual Check items to represent each Check in the list."
        },
        {
          "id": "rel-checks-page-uses-checks-hook",
          "from": "evaluation-checks-page",
          "to": "checks-collection-access",
          "phrase": "retrieves and mutates via",
          "category": "uses",
          "description": "The Checks management view uses a checks hook to load the list of Checks and to perform create, update, and delete operations."
        },
        {
          "id": "rel-checks-page-uses-auth-user",
          "from": "evaluation-checks-page",
          "to": "authenticated-user",
          "phrase": "depends on",
          "category": "uses",
          "description": "The Checks management view depends on the authenticated user state to determine when it can respond to create actions and open the Check creation modal."
        },
        {
          "id": "rel-checks-page-uses-modal",
          "from": "evaluation-checks-page",
          "to": "modal-dialog",
          "phrase": "opens",
          "category": "uses",
          "description": "The Checks management view opens a modal dialog to host the Check form for creating or editing a Check."
        },
        {
          "id": "rel-checks-page-uses-error-display",
          "from": "evaluation-checks-page",
          "to": "error-display",
          "phrase": "shows",
          "category": "uses",
          "description": "The Checks management view shows an error display component when loading or mutation errors occur while managing Checks."
        },
        {
          "id": "rel-checks-page-part-of-template-mgmt",
          "from": "evaluation-checks-page",
          "to": "template-management-and-evaluation",
          "phrase": "is part of",
          "category": "part_of",
          "description": "The Checks management view is part of the Template Management and Evaluation model, providing the admin interface for managing evaluation checks."
        },
        {
          "id": "rel-template-manager-manages-templates",
          "from": "template-manager-page",
          "to": "template",
          "phrase": "manages",
          "category": "uses",
          "description": "The template manager view loads, displays, and allows admins to manage a collection of templates, including selecting a template and updating its metadata such as name, description, tags, model, and active version."
        },
        {
          "id": "rel-template-manager-manages-template-versions",
          "from": "template-manager-page",
          "to": "template-version",
          "phrase": "manages versions of",
          "category": "uses",
          "description": "The template manager view manages multiple versions of each template, including creating new versions when saving changes, selecting a version, and marking a version as active via explicit actions."
        },
        {
          "id": "rel-template-manager-uses-template-editor-tab",
          "from": "template-manager-page",
          "to": "template-editor-tab",
          "phrase": "includes",
          "category": "part_of",
          "description": "The template manager view includes a TemplateEditorTab subview that allows admins to edit template content, extract variables, and save changes as new template versions."
        },
        {
          "id": "rel-template-manager-uses-template-version-sidebar",
          "from": "template-manager-page",
          "to": "template-version-sidebar",
          "phrase": "includes",
          "category": "part_of",
          "description": "The template manager view includes a TemplateVersionSidebar that lists template versions and allows admins to select a version and perform actions such as making a version active."
        },
        {
          "id": "rel-template-manager-uses-test-cases-tab",
          "from": "template-manager-page",
          "to": "test-cases-tab",
          "phrase": "includes",
          "category": "part_of",
          "description": "The template manager view includes a TestCasesTab that lets admins create, edit, delete, and execute test cases for the currently selected template and version."
        },
        {
          "id": "rel-template-manager-uses-test-results-tab",
          "from": "template-manager-page",
          "to": "test-results-tab",
          "phrase": "includes",
          "category": "part_of",
          "description": "The template manager view includes a TestResultsTab that displays test execution results for the selected template and version."
        },
        {
          "id": "rel-test-cases-tab-manages-test-cases",
          "from": "test-cases-tab",
          "to": "test-case",
          "phrase": "manages",
          "category": "uses",
          "description": "Within the template manager view, the TestCasesTab manages test cases for the selected template, including listing, creating, updating, and deleting test cases."
        },
        {
          "id": "rel-test-cases-tab-executes-test-case",
          "from": "test-cases-tab",
          "to": "test-execution",
          "phrase": "executes",
          "category": "uses",
          "description": "The TestCasesTab executes individual test cases against the selected template using a test execution mechanism, tracking running tests and handling execution results."
        },
        {
          "id": "rel-test-cases-tab-executes-test-batch",
          "from": "test-cases-tab",
          "to": "test-batch",
          "phrase": "executes batch of",
          "category": "uses",
          "description": "The TestCasesTab can execute a batch of test cases for the selected template, monitor batch progress, and cancel an ongoing batch."
        },
        {
          "id": "rel-template-manager-requires-user",
          "from": "template-manager-page",
          "to": "user",
          "phrase": "requires authenticated",
          "category": "constraint",
          "description": "The template manager view depends on an authenticated user; user identity is passed into subviews such as the TestCasesTab to execute tests and attribute created versions."
        },
        {
          "id": "rel-template-version-belongs-to-template",
          "from": "template-version",
          "to": "template",
          "phrase": "belongs to",
          "category": "part_of",
          "description": "Each template version is associated with a specific template and represents a particular revision of that template's content and variables."
        },
        {
          "id": "rel-test-case-belongs-to-template",
          "from": "test-case",
          "to": "template",
          "phrase": "is defined for",
          "category": "part_of",
          "description": "Each test case managed in the TestCasesTab is defined for a specific template, and test case operations are scoped to the currently selected template."
        },
        {
          "id": "rel-test-execution-targets-template-version",
          "from": "test-execution",
          "to": "template-version",
          "phrase": "targets",
          "category": "uses",
          "description": "Test executions initiated from the TestCasesTab run a test case against a specific template version, using that version's variables and model configuration."
        }
      ],
      "rules": [
        {
          "id": "rule-template-must-exist",
          "title": "Template must exist to be used",
          "text": "When fetching an active template by ID, the corresponding Template document in the 'promptTemplates' collection must exist; otherwise, the operation fails.",
          "kind": "constraint",
          "conceptIds": [
            "template"
          ]
        },
        {
          "id": "rule-template-must-have-active-version",
          "title": "Template must have an active version to be used",
          "text": "A Template must have an activeVersion value that points to an existing TemplateVersion document; otherwise, attempts to fetch the active template fail.",
          "kind": "constraint",
          "conceptIds": [
            "template"
          ]
        },
        {
          "id": "rule-template-version-activation-is-explicit",
          "title": "Template version activation is explicit",
          "text": "Saving changes to a Template creates a new TemplateVersion but does not automatically make it active; a separate explicit 'Make Active' action is required before the new version is used in production.",
          "kind": "policy",
          "conceptIds": [
            "template"
          ]
        },
        {
          "id": "rule-template-version-has-unique-version-number-per-template",
          "title": "Template version number is unique within a template",
          "text": "Within a given Template, each TemplateVersion is identified by a version number used as the document ID in the 'versions' subcollection, implying that version numbers are unique per Template.",
          "kind": "assumption",
          "conceptIds": [
            "template"
          ]
        },
        {
          "id": "rule-template-version-variables-match-template-content",
          "title": "Template version variables must correspond to template content",
          "text": "A TemplateVersion maintains a list of variables that are expected to be present in the template string, and these variables are extracted from the template content for correct prompt rendering.",
          "kind": "assumption",
          "conceptIds": [
            "template"
          ]
        },
        {
          "id": "rule-template-active-version-flag-consistent",
          "title": "Active template version is marked as active",
          "text": "The TemplateVersion referenced by a Template's activeVersion is expected to have its isActive flag set to true, ensuring consistency between metadata and version state.",
          "kind": "assumption",
          "conceptIds": [
            "template"
          ]
        },
        {
          "id": "rule-template-version-identified-by-version-number",
          "title": "Template version is identified by its version number within a Template",
          "text": "Within a given Template, each Template version is identified and retrieved by its numeric `version` value, which is used as the document key in the `versions` collection.",
          "kind": "invariant",
          "conceptIds": [
            "template-version"
          ]
        },
        {
          "id": "rule-template-must-have-existing-active-version",
          "title": "Template's activeVersion must reference an existing Template version",
          "text": "When fetching the active Template version, the Template's `activeVersion` field must correspond to an existing Template version document; otherwise, an error is raised.",
          "kind": "constraint",
          "conceptIds": [
            "template-version"
          ]
        },
        {
          "id": "rule-template-version-has-creation-metadata",
          "title": "Template version records creation metadata",
          "text": "Each Template version stores `createdAt` and `createdBy` fields to record when and by whom the version was created.",
          "kind": "assumption",
          "conceptIds": [
            "template-version"
          ]
        },
        {
          "id": "rule-template-version-has-prompt-and-variables",
          "title": "Template version must define prompt content and variables",
          "text": "Each Template version includes a `template` string and a `variables` list that together define the prompt structure for that revision.",
          "kind": "invariant",
          "conceptIds": [
            "template-version"
          ]
        },
        {
          "id": "rule-template-version-active-flag-consistent",
          "title": "Template version active flag reflects activation status",
          "text": "A Template version uses an `isActive` boolean to indicate whether it is currently marked as active for its Template; this should be consistent with the Template's `activeVersion` field.",
          "kind": "assumption",
          "conceptIds": [
            "template-version"
          ]
        },
        {
          "id": "rule-active-version-must-exist",
          "title": "Active version must exist for a template",
          "text": "For any templateId used in production, the template metadata document must exist and must specify an `activeVersion` that corresponds to an existing version document in the `versions` subcollection.",
          "kind": "constraint",
          "conceptIds": [
            "active-template"
          ]
        },
        {
          "id": "rule-active-version-document-must-exist",
          "title": "Active template version document must be present",
          "text": "When resolving an active template, the system must be able to load the version document whose ID matches the `activeVersion` value; otherwise, the operation fails.",
          "kind": "invariant",
          "conceptIds": [
            "active-template"
          ]
        },
        {
          "id": "rule-active-template-must-be-flagged-isActive",
          "title": "Active template version is marked as active",
          "text": "The version document referenced by `activeVersion` is expected to have its `isActive` flag set to true, indicating that it is the active version.",
          "kind": "assumption",
          "conceptIds": [
            "active-template"
          ]
        },
        {
          "id": "rule-active-template-requires-all-variables",
          "title": "Active template rendering requires all declared variables",
          "text": "When rendering an active template, all variables listed in the template's `variables` array must be provided; otherwise, rendering fails with an error about missing required variables.",
          "kind": "constraint",
          "conceptIds": [
            "active-template"
          ]
        },
        {
          "id": "rule-only-one-active-version-per-templateid",
          "title": "Only one active version per templateId",
          "text": "For a given templateId, at most one version is designated as the active template at any time, as indicated by the single `activeVersion` field on the template metadata.",
          "kind": "assumption",
          "conceptIds": [
            "active-template"
          ]
        },
        {
          "id": "rule-production-must-use-active-template",
          "title": "Production workflows use only the active template",
          "text": "Production workflows that generate prompts for a given templateId must use the version identified as the active template via the `activeVersion` metadata, not arbitrary or draft versions.",
          "kind": "policy",
          "conceptIds": [
            "active-template"
          ]
        },
        {
          "id": "rule-template-editing-requires-selected-version",
          "title": "Template editing requires a selected template version",
          "text": "Template editing can only operate when a specific template version is selected; the editor content and metadata fields are derived from the currently selected version.",
          "kind": "assumption",
          "conceptIds": [
            "template-editing"
          ]
        },
        {
          "id": "rule-template-editing-uses-editing-buffer",
          "title": "Template editing modifies an editing buffer",
          "text": "Template editing modifies an in-memory editing buffer (`editingTemplate`) rather than directly changing the persisted template version, and changes are only applied when the user invokes the save-template action.",
          "kind": "assumption",
          "conceptIds": [
            "template-editing"
          ]
        },
        {
          "id": "rule-template-editing-readonly-when-not-editing",
          "title": "Template editor is read-only when not in editing mode",
          "text": "When the editing state flag indicates that the user is not editing, the template editor interface presents the template content in read-only mode and hides or disables the caret and editing interactions.",
          "kind": "constraint",
          "conceptIds": [
            "template-editing"
          ]
        },
        {
          "id": "rule-template-editing-model-must-be-from-allowed-set",
          "title": "Template editing must select a model from the allowed set",
          "text": "When editing a template's associated model, the selected model must be one of the allowed options: 'gemini-2.5-flash', 'gemini-2.5-pro', or 'gemini-3-pro-preview'.",
          "kind": "constraint",
          "conceptIds": [
            "template-editing"
          ]
        },
        {
          "id": "rule-test-case-must-have-name",
          "title": "Test case must have a name",
          "text": "Every test case must have a non-empty name to identify the scenario in the UI and in listings.",
          "kind": "constraint",
          "conceptIds": [
            "test-case"
          ]
        },
        {
          "id": "rule-test-case-has-creator-and-timestamps",
          "title": "Test case records creator and timestamps",
          "text": "Every test case must record who created it (createdBy) and when it was created and last updated (createdAt, updatedAt).",
          "kind": "invariant",
          "conceptIds": [
            "test-case"
          ]
        },
        {
          "id": "rule-test-case-check-ids-list",
          "title": "Test case maintains list of checks to run",
          "text": "Each test case maintains a list of checkIds indicating which checks should be executed when the test case runs; this list may be empty if no checks are configured.",
          "kind": "assumption",
          "conceptIds": [
            "test-case"
          ]
        },
        {
          "id": "rule-test-case-input-variables-schema",
          "title": "Test case input variables are a name-value map",
          "text": "The inputVariables of a test case are represented as a map from variable name to value, where values may be strings or other JSON-serializable data.",
          "kind": "assumption",
          "conceptIds": [
            "test-case"
          ]
        },
        {
          "id": "rule-test-case-sorted-by-created-at",
          "title": "Test cases are ordered by creation time",
          "text": "When listing test cases for a template, they are sorted by createdAt in descending order so that the newest test cases appear first.",
          "kind": "policy",
          "conceptIds": [
            "test-case"
          ]
        },
        {
          "id": "rule-test-case-cannot-run-during-batch",
          "title": "Individual test case cannot run while batch is running",
          "text": "An individual test case cannot be executed from the UI while a batch of tests is running for the same template.",
          "kind": "policy",
          "conceptIds": [
            "test-case"
          ]
        },
        {
          "id": "rule-check-requires-name",
          "title": "Check must have a name",
          "text": "Every Check must have a non-empty name to be created or updated through the UI.",
          "kind": "constraint",
          "conceptIds": [
            "check"
          ]
        },
        {
          "id": "rule-check-requires-criteria",
          "title": "Check must have criteria",
          "text": "Every Check must define non-empty criteria text describing the rule or assertion to apply to LLM outputs.",
          "kind": "constraint",
          "conceptIds": [
            "check"
          ]
        },
        {
          "id": "rule-check-has-model",
          "title": "Check must specify a model",
          "text": "Every Check must specify a supported LLM model identifier that will be used when executing the Check.",
          "kind": "constraint",
          "conceptIds": [
            "check"
          ]
        },
        {
          "id": "rule-check-has-auditing-metadata",
          "title": "Check records creation metadata",
          "text": "Every Check records createdAt and createdBy metadata when stored, enabling auditing and display of authorship and creation time.",
          "kind": "assumption",
          "conceptIds": [
            "check"
          ]
        },
        {
          "id": "rule-check-execution-requires-criteria",
          "title": "Check execution depends on criteria",
          "text": "Executing a Check requires its criteria text to be available so it can be injected into the check_validation prompt template.",
          "kind": "invariant",
          "conceptIds": [
            "check"
          ]
        },
        {
          "id": "rule-check-execution-optional",
          "title": "Checks may be absent from a test run",
          "text": "If a test run specifies no Check IDs, no Checks are executed and no CheckResults are produced for that run.",
          "kind": "assumption",
          "conceptIds": [
            "check"
          ]
        },
        {
          "id": "rule-test-execution-auth-required",
          "title": "User must be authenticated to execute tests",
          "text": "A test execution can only be initiated via the callable function if the requesting user is authenticated.",
          "kind": "policy",
          "conceptIds": [
            "test-execution"
          ]
        },
        {
          "id": "rule-test-execution-required-inputs",
          "title": "Test execution requires template, test case, and input variables",
          "text": "To start a test execution, the system must receive a templateId, a testCaseId, and a set of inputVariables; otherwise the request is rejected.",
          "kind": "constraint",
          "conceptIds": [
            "test-execution"
          ]
        },
        {
          "id": "rule-test-execution-test-case-must-exist",
          "title": "Test case must exist for execution",
          "text": "A test execution cannot proceed if the referenced test case document does not exist in the template's testCases collection.",
          "kind": "invariant",
          "conceptIds": [
            "test-execution"
          ]
        },
        {
          "id": "rule-test-execution-input-variables-required-on-test-case",
          "title": "Test case must define input variables",
          "text": "A test execution requires the test case to define inputVariables; if they are missing, the execution fails.",
          "kind": "constraint",
          "conceptIds": [
            "test-execution"
          ]
        },
        {
          "id": "rule-test-execution-batch-must-be-active",
          "title": "Test execution only runs for active batches",
          "text": "A test execution associated with a batch will be skipped if the batch document does not exist or if its status is 'cancelled'.",
          "kind": "policy",
          "conceptIds": [
            "test-execution"
          ]
        },
        {
          "id": "rule-test-execution-no-duplicate-concurrent-runs",
          "title": "Prevent duplicate concurrent test executions per test case in UI",
          "text": "The UI prevents starting a new test execution for a test case if that test case is already marked as running in the runningTests set.",
          "kind": "constraint",
          "conceptIds": [
            "test-execution"
          ]
        },
        {
          "id": "rule-test-result-has-test-case-and-template",
          "title": "Test result must reference a test case and template",
          "text": "Every test result must be associated with exactly one test case and one template, identified by their IDs.",
          "kind": "invariant",
          "conceptIds": [
            "test-result"
          ]
        },
        {
          "id": "rule-test-result-has-executor-and-time",
          "title": "Test result must record executor and execution time",
          "text": "Every test result must record who executed the test and when it was executed.",
          "kind": "invariant",
          "conceptIds": [
            "test-result"
          ]
        },
        {
          "id": "rule-test-result-pass-has-request-thread-elapsed",
          "title": "Passing test result must include request, thread, and elapsed time",
          "text": "When a test result has status 'pass', it must include a request identifier, a thread identifier, and the elapsed execution time.",
          "kind": "constraint",
          "conceptIds": [
            "test-result"
          ]
        },
        {
          "id": "rule-test-result-fail-has-check-results",
          "title": "Failing test result must include check results",
          "text": "When a test result has status 'fail', it must include one or more check results describing which checks failed or passed.",
          "kind": "constraint",
          "conceptIds": [
            "test-result"
          ]
        },
        {
          "id": "rule-test-result-fail-has-request-thread-elapsed",
          "title": "Failing test result must include request, thread, and elapsed time",
          "text": "When a test result has status 'fail', it must include a request identifier, a thread identifier, and the elapsed execution time.",
          "kind": "constraint",
          "conceptIds": [
            "test-result"
          ]
        },
        {
          "id": "rule-test-result-error-has-error-message",
          "title": "Errored test result must include error message",
          "text": "When a test result has status 'error', it must include an error message describing why the test could not be successfully evaluated.",
          "kind": "constraint",
          "conceptIds": [
            "test-result"
          ]
        },
        {
          "id": "rule-check-result-links-check-and-test-run",
          "title": "Check result must link a check to a test run",
          "text": "Every check result must reference exactly one check and one test run, and must record its own pass/fail status and execution time.",
          "kind": "invariant",
          "conceptIds": [
            "test-result"
          ]
        },
        {
          "id": "rule-test-batch-auth-required",
          "title": "User must be authenticated to execute a Test Batch",
          "text": "A Test Batch can only be created and executed if the initiating user is authenticated. If request.auth is missing, the system rejects the operation with an 'unauthenticated' error.",
          "kind": "policy",
          "conceptIds": [
            "test-batch"
          ]
        },
        {
          "id": "rule-test-batch-identification",
          "title": "Test Batch must have a unique batchId",
          "text": "Each Test Batch is identified by a unique batchId, which is used both as the Firestore document id in the 'testBatches' collection and as the batchId referenced by all associated test execution tasks.",
          "kind": "invariant",
          "conceptIds": [
            "test-batch"
          ]
        },
        {
          "id": "rule-test-batch-template-link",
          "title": "Test Batch must reference a template",
          "text": "Each Test Batch must be associated with a specific Prompt Template via templateId. Queries for active batches filter by templateId, and batch creation requires a valid templateId.",
          "kind": "constraint",
          "conceptIds": [
            "test-batch"
          ]
        },
        {
          "id": "rule-test-batch-progress-bounds",
          "title": "Test Batch progress is bounded by total test cases",
          "text": "For a Test Batch, completedCount must not exceed totalTestCases, and progress percentage is computed as completedCount divided by totalTestCases (or 0 when totalTestCases is 0).",
          "kind": "assumption",
          "conceptIds": [
            "test-batch"
          ]
        },
        {
          "id": "rule-test-batch-execution-membership",
          "title": "All test executions belong to a Test Batch",
          "text": "Every test execution task must reference a batchId, meaning all test executions are part of some Test Batch, including single-test runs.",
          "kind": "invariant",
          "conceptIds": [
            "test-batch"
          ]
        },
        {
          "id": "rule-test-batch-required-inputs",
          "title": "Required inputs for creating a Test Batch execution",
          "text": "To create and execute a Test Batch for a test case, the system requires templateId, inputVariables, and testCaseId. If any of these are missing, the operation is rejected as an invalid argument.",
          "kind": "constraint",
          "conceptIds": [
            "test-batch"
          ]
        },
        {
          "id": "rule-checks-page-requires-auth-for-create-modal",
          "title": "Checks creation modal opens only after authentication is resolved",
          "text": "The Checks management view only opens the Check creation modal in response to the 'create=true' query parameter when the authenticated user is known and authentication loading has completed.",
          "kind": "constraint",
          "conceptIds": [
            "evaluation-checks-page"
          ]
        },
        {
          "id": "rule-checks-page-omits-system-fields-on-save",
          "title": "Checks management view does not edit system-managed Check fields",
          "text": "When saving a Check from the Checks management view, the data sent to create or update operations excludes the id, createdBy, createdAt, and updatedAt fields, which are managed by the system rather than by the admin user.",
          "kind": "assumption",
          "conceptIds": [
            "evaluation-checks-page"
          ]
        },
        {
          "id": "rule-template-version-activation-explicit",
          "title": "Template version activation must be explicit",
          "text": "Saving changes to a template creates a new template version but does not automatically activate it. An admin must perform an explicit 'Make Active' action to set a version as the active version for a template, allowing review and testing before deployment.",
          "kind": "policy",
          "conceptIds": [
            "template-manager-page"
          ]
        },
        {
          "id": "rule-test-execution-requires-selected-template-and-user",
          "title": "Test execution requires selected template and authenticated user",
          "text": "A test case can only be executed from the TestCasesTab when a template is selected and a user is authenticated; otherwise the execution is not performed.",
          "kind": "constraint",
          "conceptIds": [
            "template-manager-page"
          ]
        },
        {
          "id": "rule-test-cases-scoped-to-selected-template",
          "title": "Test cases are scoped to the selected template",
          "text": "The set of test cases managed and displayed in the TestCasesTab is scoped to the currently selected template; operations such as create, update, and delete apply only within that template's context.",
          "kind": "invariant",
          "conceptIds": [
            "template-manager-page"
          ]
        }
      ],
      "lifecycles": [
        {
          "id": "lifecycle-template-version-activation",
          "subjectConceptId": "template",
          "stateConceptIds": [
            "template-version-draft",
            "template-version-active"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "template-version-draft",
          "terminalStateIds": [
            "template-version-active"
          ]
        },
        {
          "id": "lifecycle-template-version-activation",
          "subjectConceptId": "template-version",
          "stateConceptIds": [
            "template-version-inactive",
            "template-version-active"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "template-version-inactive",
          "terminalStateIds": []
        },
        {
          "id": "lifecycle-template-editing-session",
          "subjectConceptId": "template-editing",
          "stateConceptIds": [
            "template-viewing",
            "template-being-edited"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "template-viewing",
          "terminalStateIds": [
            "template-viewing"
          ]
        },
        {
          "id": "lifecycle-check-basic",
          "subjectConceptId": "check",
          "stateConceptIds": [
            "check-draft",
            "check-active",
            "check-deleted"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "check-active",
          "terminalStateIds": [
            "check-deleted"
          ]
        },
        {
          "id": "lifecycle-test-execution-basic",
          "subjectConceptId": "test-execution",
          "stateConceptIds": [
            "test-execution-requested",
            "test-execution-queued",
            "test-execution-running",
            "test-execution-completed",
            "test-execution-skipped"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "test-execution-requested",
          "terminalStateIds": [
            "test-execution-completed",
            "test-execution-skipped"
          ]
        },
        {
          "id": "lifecycle-test-result-status",
          "subjectConceptId": "test-result",
          "stateConceptIds": [
            "test-result-pass",
            "test-result-fail",
            "test-result-error"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "test-result-pass",
          "terminalStateIds": [
            "test-result-pass",
            "test-result-fail",
            "test-result-error"
          ]
        },
        {
          "id": "lifecycle-test-batch-status",
          "subjectConceptId": "test-batch",
          "stateConceptIds": [
            "test-batch-pending",
            "test-batch-running",
            "test-batch-completed",
            "test-batch-cancelled",
            "test-batch-failed"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "test-batch-pending",
          "terminalStateIds": [
            "test-batch-completed",
            "test-batch-cancelled",
            "test-batch-failed"
          ]
        },
        {
          "id": "lifecycle-checks-page-modal",
          "subjectConceptId": "evaluation-checks-page",
          "stateConceptIds": [
            "checks-page-modal-closed",
            "checks-page-modal-open"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "checks-page-modal-closed",
          "terminalStateIds": [
            "checks-page-modal-closed"
          ]
        }
      ],
      "views": [
        {
          "id": "template-artifacts-structure",
          "name": "Template artifacts and versions",
          "kind": "structure",
          "description": "Shows how templates, their versions, and the active template state relate to each other and to the underlying prompt artifacts.",
          "conceptIds": [
            "template",
            "template-version",
            "active-template",
            "prompt-template",
            "prompt-template-version-document",
            "template-variable",
            "llm-model"
          ],
          "relationshipIds": [
            "rel-template-has-versions",
            "rel-template-version-belongs-to-template",
            "rel-template-version-derived-from-parent-version",
            "rel-template-version-has-variables",
            "rel-template-version-uses-model",
            "rel-template-version-used-as-prompt-template",
            "rel-active-template-of-template",
            "rel-template-has-active-version",
            "rel-active-template-stored-in-collection",
            "rel-active-template-associated-with-model"
          ]
        },
        {
          "id": "template-editing-lifecycle",
          "name": "Template editing and activation lifecycle",
          "kind": "lifecycle",
          "description": "Focuses on how admins edit template versions and move them toward being active in production.",
          "conceptIds": [
            "template-version",
            "template-editing",
            "template-content",
            "template-variables",
            "model-selection",
            "template-change-notes",
            "template-activation",
            "user"
          ],
          "relationshipIds": [
            "rel-template-version-created-by-user",
            "rel-template-editing-uses-template-version",
            "rel-template-editing-uses-template-content",
            "rel-template-editing-uses-template-variables",
            "rel-template-editing-uses-model-selection",
            "rel-template-editing-uses-change-notes",
            "rel-template-editing-precedes-save-template",
            "rel-template-editing-precedes-make-active"
          ]
        },
        {
          "id": "test-case-and-check-definition",
          "name": "Defining test cases and checks",
          "kind": "structure",
          "description": "Explains how test cases and checks are authored and connected to templates and inputs.",
          "conceptIds": [
            "test-case",
            "check",
            "template",
            "input-variables",
            "tag",
            "user",
            "checks-collection",
            "llm-model"
          ],
          "relationshipIds": [
            "rel-test-case-belongs-to-template",
            "rel-test-case-uses-input-variables",
            "rel-test-case-selects-checks",
            "rel-test-case-has-tags",
            "rel-test-case-created-by-user",
            "rel-check-collection",
            "rel-check-created-by-user",
            "rel-check-uses-model"
          ]
        },
        {
          "id": "test-execution-flow",
          "name": "Test execution and results flow",
          "kind": "lifecycle",
          "description": "Shows how a user runs tests for a template, how executions are grouped into batches, and how results and check results are produced.",
          "conceptIds": [
            "test-execution",
            "test-batch",
            "test-case",
            "template-version",
            "llm-model",
            "test-result",
            "check",
            "check-result"
          ],
          "relationshipIds": [
            "rel-test-execution-initiated-by-user",
            "rel-test-execution-targets-template-version",
            "rel-test-execution-executes-test-case",
            "rel-test-execution-belongs-to-batch",
            "rel-test-execution-uses-input-variables",
            "rel-test-execution-uses-model",
            "rel-test-execution-runs-checks",
            "rel-test-execution-produces-test-run-result",
            "rel-test-result-has-check-results",
            "rel-check-result-applies-check"
          ]
        },
        {
          "id": "template-manager-ui-overview",
          "name": "Template manager UI overview",
          "kind": "overview",
          "description": "Highlights how the template manager view organizes template editing, test cases, and test results for authenticated admins.",
          "conceptIds": [
            "template-manager-page",
            "template",
            "template-version",
            "test-case",
            "test-execution",
            "test-batch",
            "test-cases-tab",
            "test-results-tab"
          ],
          "relationshipIds": [
            "rel-template-manager-manages-templates",
            "rel-template-manager-manages-template-versions",
            "rel-template-manager-uses-test-cases-tab",
            "rel-template-manager-uses-test-results-tab",
            "rel-test-cases-tab-manages-test-cases",
            "rel-test-cases-tab-executes-test-case",
            "rel-test-cases-tab-executes-test-batch",
            "rel-test-batch-test-case",
            "rel-test-batch-test-execution"
          ]
        },
        {
          "id": "checks-management-ui",
          "name": "Checks management UI",
          "kind": "overview",
          "description": "Shows how the checks management view interacts with check entities and supporting UI components.",
          "conceptIds": [
            "evaluation-checks-page",
            "evaluation-check",
            "evaluation-check-form",
            "evaluation-check-list-item",
            "checks-collection-access",
            "authenticated-user",
            "modal-dialog",
            "error-display"
          ],
          "relationshipIds": [
            "rel-checks-page-uses-check-entities",
            "rel-checks-page-uses-check-form",
            "rel-checks-page-uses-check-item",
            "rel-checks-page-uses-checks-hook",
            "rel-checks-page-uses-auth-user",
            "rel-checks-page-uses-modal",
            "rel-checks-page-uses-error-display",
            "rel-checks-page-part-of-template-mgmt"
          ]
        }
      ],
      "storyViews": [
        {
          "id": "create-and-activate-new-template-version",
          "name": "Create and Activate a New Template Version",
          "kind": "admin_flow",
          "description": "An admin edits a template, creates a new version, tests it, and then makes it the active template for production workflows.",
          "tags": [
            "templates",
            "versions",
            "activation",
            "testing"
          ],
          "focusConceptId": "template-version",
          "steps": [
            {
              "id": "open-template-manager-and-select-template",
              "index": 0,
              "title": "Admin opens Template Manager and selects a template",
              "narrative": "An authenticated admin opens the Template manager view and selects an existing template to modify, seeing its current versions in the sidebar.",
              "conceptIds": [
                "template-manager-page",
                "template",
                "template-version"
              ],
              "relationshipIds": [
                "rel-template-manager-manages-templates",
                "rel-template-manager-manages-template-versions",
                "rel-template-manager-requires-user",
                "rel-template-has-versions"
              ],
              "primaryConceptIds": [
                "template-manager-page",
                "template"
              ],
              "primaryRelationshipIds": [
                "rel-template-manager-manages-templates"
              ]
            },
            {
              "id": "start-template-editing-on-selected-version",
              "index": 1,
              "title": "Admin starts editing the selected template version",
              "narrative": "The admin opens the template editor tab and begins template editing on the currently active or latest template version, adjusting content, variables, and model selection.",
              "conceptIds": [
                "template-manager-page",
                "template-editing",
                "template-version"
              ],
              "relationshipIds": [
                "rel-template-manager-uses-template-editor-tab",
                "rel-template-editing-uses-template-version"
              ],
              "primaryConceptIds": [
                "template-editing",
                "template-version"
              ],
              "primaryRelationshipIds": [
                "rel-template-editing-uses-template-version"
              ]
            },
            {
              "id": "save-edits-as-new-template-version",
              "index": 2,
              "title": "Edits are saved as a new template version",
              "narrative": "When the admin saves, the system creates a new template version derived from the previous one and associates it with the same template, recording the admin as the creator.",
              "conceptIds": [
                "template",
                "template-version"
              ],
              "relationshipIds": [
                "rel-template-version-belongs-to-template",
                "rel-template-version-derived-from-parent-version",
                "rel-template-version-created-by-user",
                "rel-template-has-versions"
              ],
              "primaryConceptIds": [
                "template-version"
              ],
              "primaryRelationshipIds": [
                "rel-template-version-derived-from-parent-version"
              ]
            },
            {
              "id": "run-test-batch-against-new-version",
              "index": 3,
              "title": "Admin runs a test batch against the new version",
              "narrative": "Before activating, the admin runs a test batch from the test cases tab, executing multiple test cases against the new template version to gather test results.",
              "conceptIds": [
                "template-manager-page",
                "test-cases-tab",
                "test-batch",
                "test-execution",
                "template-version"
              ],
              "relationshipIds": [
                "rel-template-manager-uses-test-cases-tab",
                "rel-test-cases-tab-executes-test-batch",
                "rel-test-batch-test-execution",
                "rel-test-execution-targets-template-version"
              ],
              "primaryConceptIds": [
                "test-batch",
                "test-execution"
              ],
              "primaryRelationshipIds": [
                "rel-test-cases-tab-executes-test-batch"
              ]
            },
            {
              "id": "review-test-results-for-new-version",
              "index": 4,
              "title": "Admin reviews test results for the new version",
              "narrative": "After the batch completes, the admin inspects test results for the new template version to confirm that behavior is acceptable across the evaluated test cases.",
              "conceptIds": [
                "template-manager-page",
                "test-result",
                "template-version",
                "test-batch"
              ],
              "relationshipIds": [
                "rel-template-manager-uses-test-results-tab",
                "rel-test-result-refers-to-template-version",
                "rel-test-result-in-batch"
              ],
              "primaryConceptIds": [
                "test-result",
                "template-version"
              ],
              "primaryRelationshipIds": [
                "rel-test-result-refers-to-template-version"
              ]
            },
            {
              "id": "make-new-version-active-template",
              "index": 5,
              "title": "Admin makes the new version the active template",
              "narrative": "Satisfied with the results, the admin activates the new template version so that production workflows now select this active template for LLM prompts.",
              "conceptIds": [
                "template",
                "template-version",
                "active-template"
              ],
              "relationshipIds": [
                "rel-template-has-active-version",
                "rel-template-version-can-be-active-for-template",
                "rel-active-template-selected-by-production-workflows"
              ],
              "primaryConceptIds": [
                "active-template",
                "template-version"
              ],
              "primaryRelationshipIds": [
                "rel-template-has-active-version"
              ]
            }
          ]
        },
        {
          "id": "define-test-cases-and-run-batch-evaluation",
          "name": "Define Test Cases and Run a Batch Evaluation",
          "kind": "admin_flow",
          "description": "An admin creates test cases for a template, associates checks, and runs a batch evaluation to understand template quality.",
          "tags": [
            "test-cases",
            "checks",
            "batch-testing"
          ],
          "focusConceptId": "test-case",
          "steps": [
            {
              "id": "open-test-cases-tab-for-template",
              "index": 0,
              "title": "Admin opens the Test Cases tab for a template",
              "narrative": "From the Template manager view, the admin navigates to the Test Cases tab for a specific template to define evaluation scenarios.",
              "conceptIds": [
                "template-manager-page",
                "test-cases-tab",
                "template"
              ],
              "relationshipIds": [
                "rel-template-manager-manages-templates",
                "rel-template-manager-uses-test-cases-tab",
                "rel-test-case-belongs-to-template"
              ],
              "primaryConceptIds": [
                "template-manager-page",
                "test-cases-tab"
              ],
              "primaryRelationshipIds": [
                "rel-template-manager-uses-test-cases-tab"
              ]
            },
            {
              "id": "create-test-cases-with-inputs",
              "index": 1,
              "title": "Admin creates test cases with input variables",
              "narrative": "The admin defines several test cases for the template, specifying representative input variables and tagging them for organization.",
              "conceptIds": [
                "test-case",
                "template",
                "input-variables"
              ],
              "relationshipIds": [
                "rel-test-case-belongs-to-template",
                "rel-test-case-uses-input-variables",
                "rel-test-case-created-by-user"
              ],
              "primaryConceptIds": [
                "test-case"
              ],
              "primaryRelationshipIds": [
                "rel-test-case-belongs-to-template"
              ]
            },
            {
              "id": "associate-checks-with-test-cases",
              "index": 2,
              "title": "Admin associates checks with each test case",
              "narrative": "For each test case, the admin selects appropriate checks that will later be run against LLM outputs to validate correctness and safety.",
              "conceptIds": [
                "test-case",
                "check"
              ],
              "relationshipIds": [
                "rel-test-case-selects-checks",
                "rel-check-used-in-test-run"
              ],
              "primaryConceptIds": [
                "test-case",
                "check"
              ],
              "primaryRelationshipIds": [
                "rel-test-case-selects-checks"
              ]
            },
            {
              "id": "launch-test-batch-for-template",
              "index": 3,
              "title": "Admin launches a test batch for the template",
              "narrative": "The admin triggers a test batch from the Test Cases tab, which groups all selected test cases to be run against the template’s current target model.",
              "conceptIds": [
                "test-cases-tab",
                "test-batch",
                "template"
              ],
              "relationshipIds": [
                "rel-test-cases-tab-executes-test-batch",
                "rel-test-batch-template",
                "rel-test-batch-test-case"
              ],
              "primaryConceptIds": [
                "test-batch"
              ],
              "primaryRelationshipIds": [
                "rel-test-cases-tab-executes-test-batch"
              ]
            },
            {
              "id": "execute-test-cases-with-checks",
              "index": 4,
              "title": "System executes test cases with checks",
              "narrative": "For each test case in the batch, the system performs a test execution that renders the template with the test inputs, calls the LLM model, and runs the assigned checks.",
              "conceptIds": [
                "test-execution",
                "test-case",
                "test-batch",
                "check",
                "template",
                "llm-model"
              ],
              "relationshipIds": [
                "rel-test-execution-executes-test-case",
                "rel-test-execution-belongs-to-batch",
                "rel-test-execution-uses-template",
                "rel-test-execution-uses-model",
                "rel-test-execution-runs-checks"
              ],
              "primaryConceptIds": [
                "test-execution"
              ],
              "primaryRelationshipIds": [
                "rel-test-execution-executes-test-case"
              ]
            },
            {
              "id": "collect-and-view-test-results",
              "index": 5,
              "title": "Admin collects and views test results",
              "narrative": "Once the batch completes, the admin reviews aggregated test results and individual check results to understand how the template performs across scenarios.",
              "conceptIds": [
                "test-result",
                "check-result",
                "test-batch",
                "template"
              ],
              "relationshipIds": [
                "rel-test-result-in-batch",
                "rel-test-result-uses-template",
                "rel-test-result-has-check-results",
                "rel-check-result-applies-check"
              ],
              "primaryConceptIds": [
                "test-result"
              ],
              "primaryRelationshipIds": [
                "rel-test-result-has-check-results"
              ]
            }
          ]
        },
        {
          "id": "manage-and-reuse-evaluation-checks",
          "name": "Manage and Reuse Evaluation Checks",
          "kind": "admin_flow",
          "description": "An admin curates reusable checks in the Checks management view and then applies them to template test cases.",
          "tags": [
            "checks",
            "governance",
            "reusability"
          ],
          "focusConceptId": "check",
          "steps": [
            {
              "id": "open-checks-management-view",
              "index": 0,
              "title": "Admin opens the Checks management view",
              "narrative": "An authenticated admin navigates to the Checks management view to browse existing checks and create new ones for evaluations.",
              "conceptIds": [
                "evaluation-checks-page",
                "check"
              ],
              "relationshipIds": [
                "rel-checks-page-uses-check-entities",
                "rel-checks-page-uses-auth-user"
              ],
              "primaryConceptIds": [
                "evaluation-checks-page"
              ],
              "primaryRelationshipIds": [
                "rel-checks-page-uses-check-entities"
              ]
            },
            {
              "id": "create-or-edit-check-definition",
              "index": 1,
              "title": "Admin creates or edits a check definition",
              "narrative": "Using the checks form, the admin defines or updates a check’s criteria and preferred model so it can be consistently applied across test cases.",
              "conceptIds": [
                "check",
                "llm-model"
              ],
              "relationshipIds": [
                "rel-check-created-by-user",
                "rel-check-uses-model",
                "rel-check-collection"
              ],
              "primaryConceptIds": [
                "check"
              ],
              "primaryRelationshipIds": [
                "rel-check-created-by-user"
              ]
            },
            {
              "id": "checks-appear-for-selection-in-test-cases",
              "index": 2,
              "title": "Checks appear for selection in template test cases",
              "narrative": "The newly defined checks are now available when admins configure test cases under a template, enabling consistent evaluation rules.",
              "conceptIds": [
                "test-case",
                "check",
                "template"
              ],
              "relationshipIds": [
                "rel-test-case-belongs-to-template",
                "rel-test-case-selects-checks"
              ],
              "primaryConceptIds": [
                "test-case",
                "check"
              ],
              "primaryRelationshipIds": [
                "rel-test-case-selects-checks"
              ]
            },
            {
              "id": "run-test-execution-using-reusable-checks",
              "index": 3,
              "title": "Test executions use the reusable checks",
              "narrative": "When a test execution runs for a template’s test case, it automatically executes the selected reusable checks against the LLM output.",
              "conceptIds": [
                "test-execution",
                "test-case",
                "check",
                "llm-model"
              ],
              "relationshipIds": [
                "rel-test-execution-executes-test-case",
                "rel-test-execution-runs-checks",
                "rel-test-execution-uses-model",
                "rel-check-used-in-test-run"
              ],
              "primaryConceptIds": [
                "test-execution",
                "check"
              ],
              "primaryRelationshipIds": [
                "rel-test-execution-runs-checks"
              ]
            },
            {
              "id": "inspect-check-results-to-refine-checks",
              "index": 4,
              "title": "Admin inspects check results and refines checks",
              "narrative": "By reviewing check results within test results, the admin identifies gaps or overly strict rules and returns to the Checks management view to refine the check definitions.",
              "conceptIds": [
                "test-result",
                "check-result",
                "check"
              ],
              "relationshipIds": [
                "rel-test-result-has-check-results",
                "rel-check-result-applies-check",
                "rel-check-collection"
              ],
              "primaryConceptIds": [
                "check-result",
                "check"
              ],
              "primaryRelationshipIds": [
                "rel-test-result-has-check-results"
              ]
            }
          ]
        },
        {
          "id": "system-executes-test-batch-and-records-results",
          "name": "System Executes a Test Batch and Records Results",
          "kind": "system_flow",
          "description": "A system-level view of how a test batch is executed, from enqueuing test executions to producing test and check results.",
          "tags": [
            "system",
            "execution",
            "results"
          ],
          "focusConceptId": "test-execution",
          "steps": [
            {
              "id": "batch-initiated-and-test-executions-created",
              "index": 0,
              "title": "Test batch is initiated and test executions are created",
              "narrative": "When a user starts a test batch for a template, the system creates individual test executions for each included test case and associates them with the batch.",
              "conceptIds": [
                "test-batch",
                "test-case",
                "test-execution",
                "user"
              ],
              "relationshipIds": [
                "rel-test-batch-user",
                "rel-test-batch-test-case",
                "rel-test-batch-test-execution",
                "rel-test-execution-initiated-by-user",
                "rel-test-execution-belongs-to-batch"
              ],
              "primaryConceptIds": [
                "test-batch",
                "test-execution"
              ],
              "primaryRelationshipIds": [
                "rel-test-batch-test-execution"
              ]
            },
            {
              "id": "render-template-and-call-llm",
              "index": 1,
              "title": "Each test execution renders the template and calls the LLM",
              "narrative": "For each test execution, the system uses the template and test case input variables to render a prompt and then executes it on the configured LLM model.",
              "conceptIds": [
                "test-execution",
                "template",
                "template-version",
                "test-case",
                "input-variables",
                "llm-model"
              ],
              "relationshipIds": [
                "rel-test-execution-uses-template",
                "rel-test-execution-targets-template-version",
                "rel-test-execution-executes-test-case",
                "rel-test-execution-uses-input-variables",
                "rel-test-execution-uses-model"
              ],
              "primaryConceptIds": [
                "test-execution"
              ],
              "primaryRelationshipIds": [
                "rel-test-execution-uses-template"
              ]
            },
            {
              "id": "run-assigned-checks-on-llm-output",
              "index": 2,
              "title": "Assigned checks are run on the LLM output",
              "narrative": "After receiving the LLM output, the test execution runs all checks selected by the test case, evaluating the output against each check’s criteria.",
              "conceptIds": [
                "test-execution",
                "test-case",
                "check"
              ],
              "relationshipIds": [
                "rel-test-execution-runs-checks",
                "rel-test-case-selects-checks",
                "rel-check-used-in-test-run"
              ],
              "primaryConceptIds": [
                "test-execution",
                "check"
              ],
              "primaryRelationshipIds": [
                "rel-test-execution-runs-checks"
              ]
            },
            {
              "id": "produce-test-result-and-check-results",
              "index": 3,
              "title": "System produces a test result and associated check results",
              "narrative": "For each test execution, the system records a test result that references the template, template version, and test case, and attaches individual check results for each executed check.",
              "conceptIds": [
                "test-result",
                "test-case",
                "template",
                "template-version",
                "check-result",
                "check",
                "test-batch"
              ],
              "relationshipIds": [
                "rel-test-result-tests-test-case",
                "rel-test-result-uses-template",
                "rel-test-result-refers-to-template-version",
                "rel-test-result-in-batch",
                "rel-test-result-has-check-results",
                "rel-check-result-applies-check",
                "rel-check-result-refers-to-test-result"
              ],
              "primaryConceptIds": [
                "test-result",
                "check-result"
              ],
              "primaryRelationshipIds": [
                "rel-test-result-has-check-results"
              ]
            },
            {
              "id": "aggregate-batch-outcomes-for-review",
              "index": 4,
              "title": "Batch outcomes are aggregated for review",
              "narrative": "Once all test executions in the batch complete, the system aggregates their test results so admins can review overall performance for the evaluated template.",
              "conceptIds": [
                "test-batch",
                "test-result",
                "template"
              ],
              "relationshipIds": [
                "rel-test-batch-test-execution",
                "rel-test-result-in-batch",
                "rel-test-batch-template"
              ],
              "primaryConceptIds": [
                "test-batch"
              ],
              "primaryRelationshipIds": [
                "rel-test-batch-template"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "data-request-observability",
      "title": "Data Request Tracking and Observability",
      "description": "How data requests, their executions, and related events are stored, monitored, and surfaced to users.",
      "concepts": [
        {
          "id": "data-request-detail-view",
          "label": "Data request detail view",
          "category": "other",
          "description": "A UI view that shows the full history, context, and status of a single data request.",
          "aliases": [
            "data-request-detail-view",
            "DataRequestDetail",
            "DataRequestDetailPage",
            "DataRequestDetail.tsx"
          ],
          "notes": "A UI view/page that focuses on a single data request and presents its full history, context, and status. It is implemented as a React component (DataRequestDetail.tsx) that loads data from Firestore, renders Slack-formatted request content via SlackMarkdown, shows LLM responses via LlmResponseTabs, and can display debug events related to the request. It is distinct from the list view of data requests and is navigated to with a specific data request identifier (via route params)."
        },
        {
          "id": "data-request-list",
          "label": "Data request list",
          "category": "thing",
          "description": "A collection of data requests that can be browsed and filtered for monitoring and analysis.",
          "aliases": [
            "Data request list",
            "DataRequestsList",
            "threads list",
            "data requests overview"
          ],
          "notes": "A Data request list is a browsable collection of data request threads, each represented by a ThreadDoc. It is used for monitoring and analyzing multiple data requests at once, including their status, requester information, and associated artifacts. In the UI, this appears as the DataRequestsList page, which shows many ThreadDoc entries ordered (e.g., by createdAt/updatedAt) and allows users to inspect individual requests."
        },
        {
          "id": "test-execution-result",
          "label": "Test execution result",
          "category": "thing",
          "description": "A structured record summarizing the outcome of a single test execution, including checks and metrics.",
          "aliases": [
            "TestExecutionResult",
            "test execution result",
            "single test execution result",
            "test run result (single test case)",
            "test result"
          ],
          "notes": "A TestExecutionResult is the structured outcome of executing a single test case against a specific model and prompt template. It summarizes the model’s response text, the model used, the associated test run identifier, the overall pass/fail status derived from checks, the execution timestamp, and the detailed check results. It is produced by the executeTest operation for one test case and is distinct from any higher-level aggregation of multiple test executions."
        },
        {
          "id": "thread-status",
          "label": "Thread status",
          "category": "state",
          "description": "The current processing state of a Slack thread, such as pending, in-progress, or completed.",
          "aliases": [
            "thread-status",
            "thread status",
            "status",
            "processing state of a Slack thread"
          ],
          "notes": "Thread status represents the current processing state of a Slack thread within the data request tracking and observability model. The worker adapter exposes an updateThreadStatus(rootTs, status) operation, indicating that status is stored per thread document (e.g., in a Firestore threads collection) and can be updated over time as the system processes the thread. The description suggests values such as pending, in-progress, and completed, but the specific enumeration is not enforced in the shown code."
        },
        {
          "id": "debug-log-view",
          "label": "Debug log view",
          "category": "other",
          "description": "A UI representation of debug events and errors associated with a data request or test run.",
          "aliases": [
            "debug-log-view",
            "DebugEventsDisplay",
            "debug events display",
            "debug log",
            "debug events view",
            "error display",
            "ErrorDisplay"
          ],
          "notes": "A debug log view is a UI representation that surfaces debug events and errors associated with a data request or test run. In the provided code, this is primarily embodied by the DebugEventsDisplay component, which renders a sequence of typed debug events (e.g., LLM requests/responses, Slack messages, timing metrics, thread creation) and by ErrorDisplay, which shows a focused error message with dismiss capability. The debug log view is oriented around observability of the system’s behavior for a single data request or evaluation run, allowing users to inspect inputs, outputs, timings, and failures."
        },
        {
          "id": "xml-response-structure",
          "label": "XML response structure",
          "category": "thing",
          "description": "An XML-formatted representation of LLM responses or results that can be parsed and inspected.",
          "aliases": [
            "XML response structure",
            "XML-formatted response",
            "XML content",
            "xmlContent",
            "structured XML elements",
            "XML representation of LLM response"
          ],
          "notes": "An XML response structure is an XML-formatted representation of an LLM response or result that can be parsed into discrete elements (tags, content, and attributes) for inspection and display in the evaluation UI. The UI component treats the XML as a structured payload, optionally wrapped in a <response> root element, and focuses on the meaningful child elements as the observable structure."
        },
        {
          "id": "slack-markdown-rendering",
          "label": "Slack markdown rendering",
          "category": "activity",
          "description": "The activity of displaying Slack-formatted content in the web UI for review and debugging.",
          "aliases": [
            "slack-markdown-rendering",
            "SlackMarkdown",
            "Slack-style markdown rendering",
            "Slack-formatted content rendering"
          ],
          "notes": "Slack markdown rendering is the activity of taking Slack-formatted text content and converting it into HTML for display in the web UI, primarily for review and debugging of Slack-based interactions. The SlackMarkdown component encapsulates this behavior by transforming a Slack markdown string into HTML via a Slack-specific markdown converter and then injecting the resulting HTML into the page for visual inspection."
        }
      ],
      "relationships": [
        {
          "id": "rel-data-request-detail-uses-data-request",
          "from": "data-request-detail-view",
          "to": "data-request",
          "phrase": "displays",
          "category": "represents",
          "description": "The data request detail view displays the full information for a single data request, including its context, history, and status."
        },
        {
          "id": "rel-data-request-detail-uses-debug-events",
          "from": "data-request-detail-view",
          "to": "debug-event",
          "phrase": "shows",
          "category": "uses",
          "description": "The data request detail view shows debug events (such as time_to_react, llm_classification, and thread_created) associated with the data request to support observability and analysis."
        },
        {
          "id": "rel-data-request-detail-uses-llm-responses",
          "from": "data-request-detail-view",
          "to": "llm-response",
          "phrase": "shows",
          "category": "uses",
          "description": "The data request detail view uses LlmResponseTabs to show one or more LLM responses related to the data request."
        },
        {
          "id": "rel-data-request-detail-uses-slack-markdown",
          "from": "data-request-detail-view",
          "to": "slack-message",
          "phrase": "renders",
          "category": "represents",
          "description": "The data request detail view renders the original Slack message content of the data request using SlackMarkdown, preserving Slack-specific formatting."
        },
        {
          "id": "rel-data-request-detail-part-of-tracking-observability",
          "from": "data-request-detail-view",
          "to": "data-request-tracking-and-observability",
          "phrase": "is part of",
          "category": "part_of",
          "description": "The data request detail view is part of the overall Data Request Tracking and Observability model, providing a focused view for inspecting a single request."
        },
        {
          "id": "rel-data-request-detail-preceded-by-auth",
          "from": "data-request-detail-view",
          "to": "authenticated-user-session",
          "phrase": "requires",
          "category": "prevents",
          "description": "The data request detail view requires an authenticated user session; without authentication, the view cannot access or display the data request details."
        },
        {
          "id": "rel-data-request-detail-uses-firestore",
          "from": "data-request-detail-view",
          "to": "data-request-store",
          "phrase": "reads from",
          "category": "uses",
          "description": "The data request detail view reads the data for a single data request and its related artifacts from the Firestore-backed data request store."
        },
        {
          "id": "rel-data-request-detail-navigated-from-list",
          "from": "data-request-detail-view",
          "to": "data-request-list-view",
          "phrase": "is navigated from",
          "category": "precedes",
          "description": "Users typically navigate to the data request detail view from the data request list view when they select a specific request."
        },
        {
          "id": "rel-data-request-list-contains-thread",
          "from": "data-request-list",
          "to": "data-request-thread",
          "phrase": "contains",
          "category": "part_of",
          "description": "A Data request list contains multiple data request threads (ThreadDoc records), each representing a single Slack-based data request and its processing details."
        },
        {
          "id": "rel-data-request-list-uses-status",
          "from": "data-request-list",
          "to": "data-request-status",
          "phrase": "uses",
          "category": "uses",
          "description": "A Data request list uses the status of each data request thread (processing, accepted, rejected, unhandled) to present and monitor the state of all tracked data requests."
        },
        {
          "id": "rel-data-request-list-uses-artifacts",
          "from": "data-request-list",
          "to": "data-request-artifacts",
          "phrase": "uses",
          "category": "uses",
          "description": "A Data request list uses artifacts attached to each data request thread (request text, clarifying questions, step-by-step instructions) to support analysis and understanding of the requests."
        },
        {
          "id": "rel-data-request-list-represents-slack-threads",
          "from": "data-request-list",
          "to": "slack-thread",
          "phrase": "represents",
          "category": "represents",
          "description": "A Data request list represents a set of Slack threads that have been identified as data requests and stored as ThreadDoc records."
        },
        {
          "id": "rel-data-request-list-is-viewed-by-user",
          "from": "user",
          "to": "data-request-list",
          "phrase": "views",
          "category": "uses",
          "description": "A User views the Data request list to monitor and analyze multiple data requests."
        },
        {
          "id": "rel-data-request-list-filters-by-requester",
          "from": "data-request-list",
          "to": "data-request-requester",
          "phrase": "can be filtered by",
          "category": "uses",
          "description": "A Data request list can be filtered or browsed by requester-related attributes such as requester, requesterName, or requesterHandle."
        },
        {
          "id": "rel-data-request-list-filters-by-channel",
          "from": "data-request-list",
          "to": "slack-channel",
          "phrase": "can be filtered by",
          "category": "uses",
          "description": "A Data request list can be filtered or browsed by channel or channelName to focus on requests from specific Slack channels."
        },
        {
          "id": "rel-data-request-list-orders-by-time",
          "from": "data-request-list",
          "to": "timestamp",
          "phrase": "orders by",
          "category": "uses",
          "description": "A Data request list orders its data request threads by temporal fields such as createdAt or updatedAt to support chronological monitoring."
        },
        {
          "id": "rel-test-execution-result-produced-by-execute-test",
          "from": "test-execution-result",
          "to": "test-execution",
          "phrase": "is produced by",
          "category": "causes",
          "description": "A TestExecutionResult is produced by executing a single test case via the executeTest operation."
        },
        {
          "id": "rel-test-execution-result-refers-to-test-run-result",
          "from": "test-execution-result",
          "to": "test-run-result",
          "phrase": "refers to",
          "category": "uses",
          "description": "A TestExecutionResult includes a testRunResultId that links it to a broader test run result context."
        },
        {
          "id": "rel-test-execution-result-summarizes-model-output",
          "from": "test-execution-result",
          "to": "model-output",
          "phrase": "summarizes",
          "category": "represents",
          "description": "A TestExecutionResult summarizes the model output text produced when executing the rendered prompt."
        },
        {
          "id": "rel-test-execution-result-uses-model",
          "from": "test-execution-result",
          "to": "llm-model",
          "phrase": "is generated by",
          "category": "uses",
          "description": "A TestExecutionResult records the modelName of the LLM model that generated the output being evaluated."
        },
        {
          "id": "rel-test-execution-result-derived-from-test-case-checks",
          "from": "test-execution-result",
          "to": "check-result",
          "phrase": "aggregates",
          "category": "part_of",
          "description": "A TestExecutionResult aggregates multiple checkResults, each representing the outcome of an individual check applied to the model output."
        },
        {
          "id": "rel-test-execution-result-overall-status-derived-from-checks",
          "from": "test-execution-result",
          "to": "check",
          "phrase": "derives overallStatus from",
          "category": "causes",
          "description": "The overallStatus of a TestExecutionResult (pass or fail) is derived from the outcomes of the checks assigned to the test case."
        },
        {
          "id": "rel-test-execution-result-associated-with-test-case",
          "from": "test-execution-result",
          "to": "test-case",
          "phrase": "evaluates",
          "category": "uses",
          "description": "A TestExecutionResult is the outcome of executing a specific test case, whose definition includes the checks to run."
        },
        {
          "id": "rel-test-execution-result-associated-with-template",
          "from": "test-execution-result",
          "to": "prompt-template",
          "phrase": "is based on",
          "category": "uses",
          "description": "A TestExecutionResult is based on a particular prompt template version that is rendered and executed during the test."
        },
        {
          "id": "rel-test-execution-result-associated-with-request",
          "from": "test-execution-result",
          "to": "request",
          "phrase": "is linked to",
          "category": "uses",
          "description": "A TestExecutionResult is linked to a request identifier used for debugging and tracking the specific test execution."
        },
        {
          "id": "rel-thread-status-belongs-to-thread",
          "from": "thread-status",
          "to": "slack-thread",
          "phrase": "belongs to",
          "category": "part_of",
          "description": "Each thread status is associated with a specific Slack thread, identified by its root timestamp (rootTs). The status is stored and updated per thread document in the threads collection."
        },
        {
          "id": "rel-thread-status-stored-in-thread-doc",
          "from": "thread-status",
          "to": "thread-document",
          "phrase": "is stored in",
          "category": "part_of",
          "description": "Thread status is persisted as part of a thread document (e.g., in the Firestore threads collection), alongside other per-thread data such as flags."
        },
        {
          "id": "rel-thread-status-updated-by-worker",
          "from": "thread-status",
          "to": "worker-process",
          "phrase": "is updated by",
          "category": "uses",
          "description": "Worker processes call updateThreadStatus(rootTs, status) to change the stored status of a Slack thread as it moves through processing."
        },
        {
          "id": "rel-debug-log-view-uses-debug-events",
          "from": "debug-log-view",
          "to": "debug-event",
          "phrase": "displays",
          "category": "represents",
          "description": "The debug log view displays a collection of debug events that describe what happened during handling of a data request or test run."
        },
        {
          "id": "rel-debug-log-view-uses-error",
          "from": "debug-log-view",
          "to": "error",
          "phrase": "displays",
          "category": "represents",
          "description": "The debug log view displays error messages associated with a data request or test run, allowing the user to see what went wrong."
        },
        {
          "id": "rel-debug-log-view-part-of-observability",
          "from": "debug-log-view",
          "to": "data-request-tracking-and-observability",
          "phrase": "is part of",
          "category": "part_of",
          "description": "The debug log view is part of the overall data request tracking and observability model, providing a visual window into internal events and errors."
        },
        {
          "id": "rel-debug-log-view-uses-llm-response-tabs",
          "from": "debug-log-view",
          "to": "llm-response-view",
          "phrase": "uses",
          "category": "uses",
          "description": "The debug log view uses LLM response and template variable tab views to present details of LLM-related debug events."
        },
        {
          "id": "rel-debug-log-view-represents-llm-interaction",
          "from": "debug-log-view",
          "to": "llm-interaction",
          "phrase": "represents",
          "category": "represents",
          "description": "The debug log view represents LLM interactions such as classification, requests, and responses as structured debug events."
        },
        {
          "id": "rel-debug-log-view-represents-slack-interaction",
          "from": "debug-log-view",
          "to": "slack-interaction",
          "phrase": "represents",
          "category": "represents",
          "description": "The debug log view represents Slack interactions such as incoming messages and thread creation as structured debug events."
        },
        {
          "id": "rel-debug-log-view-represents-timing-metrics",
          "from": "debug-log-view",
          "to": "timing-metric",
          "phrase": "represents",
          "category": "represents",
          "description": "The debug log view represents timing metrics (e.g., time to react, elapsed milliseconds) as debug events to support performance analysis."
        },
        {
          "id": "rel-error-display-part-of-debug-log-view",
          "from": "error-display",
          "to": "debug-log-view",
          "phrase": "is used by",
          "category": "part_of",
          "description": "The ErrorDisplay component is a specialized part of the debug log view that focuses on presenting a single error message with a dismiss action."
        },
        {
          "id": "rel-xml-uses-llm-response",
          "from": "xml-response-structure",
          "to": "llm-response",
          "phrase": "represents",
          "category": "represents",
          "description": "An XML response structure represents the content of an LLM response or result in a structured, machine-parseable format."
        },
        {
          "id": "rel-xml-part-of-eval-result",
          "from": "xml-response-structure",
          "to": "evaluation-result",
          "phrase": "is included in",
          "category": "part_of",
          "description": "An XML response structure is included in an evaluation result so that evaluators can inspect the structured output of the LLM."
        },
        {
          "id": "rel-xml-used-by-parser",
          "from": "xml-response-structure",
          "to": "xml-response-parser",
          "phrase": "is parsed by",
          "category": "uses",
          "description": "An XML response structure is parsed by the XML response parser component to extract elements, content, and attributes for display."
        },
        {
          "id": "rel-xml-has-elements",
          "from": "xml-response-structure",
          "to": "xml-element",
          "phrase": "has",
          "category": "part_of",
          "description": "An XML response structure has one or more XML elements, each with a tag name, content, and optional attributes."
        },
        {
          "id": "rel-xml-may-be-wrapped",
          "from": "xml-response-structure",
          "to": "xml-response-wrapper-element",
          "phrase": "may be wrapped by",
          "category": "part_of",
          "description": "An XML response structure may be wrapped by a <response> XML element that serves as a container for the meaningful child elements."
        },
        {
          "id": "rel-slack-markdown-rendering-uses-slack-markdown-content",
          "from": "slack-markdown-rendering",
          "to": "slack-markdown-content",
          "phrase": "uses",
          "category": "uses",
          "description": "Slack markdown rendering uses Slack-formatted text content as its input, expecting a string that follows Slack's markdown conventions."
        },
        {
          "id": "rel-slack-markdown-rendering-enables-web-ui-review",
          "from": "slack-markdown-rendering",
          "to": "web-ui-review-and-debugging",
          "phrase": "enables",
          "category": "enables",
          "description": "Slack markdown rendering enables web UI review and debugging by presenting Slack-formatted content in a human-readable HTML form."
        },
        {
          "id": "rel-slack-markdown-rendering-uses-slack-markdown-parser",
          "from": "slack-markdown-rendering",
          "to": "slack-markdown-parser",
          "phrase": "uses",
          "category": "uses",
          "description": "Slack markdown rendering uses a Slack-specific markdown parser/converter to transform Slack-formatted text into HTML."
        },
        {
          "id": "rel-slack-markdown-rendering-part-of-data-request-tracking-ui",
          "from": "slack-markdown-rendering",
          "to": "data-request-tracking-web-ui",
          "phrase": "is part of",
          "category": "part_of",
          "description": "Slack markdown rendering is part of the data request tracking and observability web UI, providing a way to display Slack-based request and evaluation content."
        }
      ],
      "rules": [
        {
          "id": "rule-data-request-detail-requires-id",
          "title": "Data Request Detail View Requires Request Identifier",
          "text": "The data request detail view must be provided with a valid data request identifier (for example, via route parameters) in order to load and display a specific data request.",
          "kind": "constraint",
          "conceptIds": [
            "data-request-detail-view"
          ]
        },
        {
          "id": "rule-data-request-detail-requires-auth",
          "title": "Data Request Detail View Requires Authentication",
          "text": "The data request detail view requires that a user is authenticated before it can access and display data request details from the backing store.",
          "kind": "policy",
          "conceptIds": [
            "data-request-detail-view"
          ]
        },
        {
          "id": "rule-data-request-detail-shows-json-serializable-data",
          "title": "Data Request Detail View Handles JSON-Serializable Values",
          "text": "The data request detail view assumes that request-related data and debug event payloads are JSON-serializable values, enabling them to be safely retrieved and rendered.",
          "kind": "assumption",
          "conceptIds": [
            "data-request-detail-view"
          ]
        },
        {
          "id": "rule-data-request-list-threads-are-threaddocs",
          "title": "Data request list entries must be ThreadDoc records",
          "text": "Every entry in a Data request list is a ThreadDoc representing a single data request thread with its associated metadata and artifacts.",
          "kind": "invariant",
          "conceptIds": [
            "data-request-list"
          ]
        },
        {
          "id": "rule-data-request-list-can-be-empty",
          "title": "Data request list may be empty",
          "text": "A Data request list may contain zero or more data request threads; it does not require at least one entry.",
          "kind": "assumption",
          "conceptIds": [
            "data-request-list"
          ]
        },
        {
          "id": "rule-data-request-list-uses-consistent-status-set",
          "title": "Data request list uses a fixed set of statuses",
          "text": "Statuses shown in a Data request list for each data request thread are limited to the defined set: processing, accepted, rejected, or unhandled.",
          "kind": "constraint",
          "conceptIds": [
            "data-request-list"
          ]
        },
        {
          "id": "rule-test-execution-result-has-overall-status",
          "title": "Test execution result must have an overall status",
          "text": "Each TestExecutionResult must record an overallStatus value indicating whether the test passed or failed.",
          "kind": "invariant",
          "conceptIds": [
            "test-execution-result"
          ]
        },
        {
          "id": "rule-test-execution-result-has-model-name",
          "title": "Test execution result must record model name",
          "text": "Each TestExecutionResult must record the modelName of the model used to generate the evaluated output.",
          "kind": "invariant",
          "conceptIds": [
            "test-execution-result"
          ]
        },
        {
          "id": "rule-test-execution-result-has-execution-timestamp",
          "title": "Test execution result must record execution time",
          "text": "Each TestExecutionResult must record executedAt, indicating when the test execution occurred.",
          "kind": "invariant",
          "conceptIds": [
            "test-execution-result"
          ]
        },
        {
          "id": "rule-test-execution-result-linked-to-test-run",
          "title": "Test execution result must be linked to a test run result",
          "text": "Each TestExecutionResult must include a testRunResultId that associates it with a broader test run context.",
          "kind": "constraint",
          "conceptIds": [
            "test-execution-result"
          ]
        },
        {
          "id": "rule-test-execution-result-may-have-check-results",
          "title": "Test execution result may include detailed check results",
          "text": "A TestExecutionResult may include a collection of checkResults detailing the outcome of individual checks applied to the model output.",
          "kind": "assumption",
          "conceptIds": [
            "test-execution-result"
          ]
        },
        {
          "id": "rule-test-execution-result-has-output-text",
          "title": "Test execution result must capture model output text",
          "text": "Each TestExecutionResult must capture the text produced by the model during the test execution.",
          "kind": "invariant",
          "conceptIds": [
            "test-execution-result"
          ]
        },
        {
          "id": "rule-thread-status-requires-thread-id",
          "title": "Thread status must be associated with a root thread timestamp",
          "text": "Any update to thread status must specify a root thread timestamp (rootTs) so that the status can be applied to the correct Slack thread document.",
          "kind": "constraint",
          "conceptIds": [
            "thread-status"
          ]
        },
        {
          "id": "rule-thread-status-single-current-value",
          "title": "A thread has a single current status value",
          "text": "For a given Slack thread document, at any point in time there is a single current thread status value that represents the latest known processing state.",
          "kind": "assumption",
          "conceptIds": [
            "thread-status"
          ]
        },
        {
          "id": "rule-debug-log-view-requires-debug-events-or-error",
          "title": "Debug log view shows debug events and/or errors",
          "text": "A debug log view is meaningful only when there are debug events and/or error messages associated with a data request or test run to display.",
          "kind": "assumption",
          "conceptIds": [
            "debug-log-view"
          ]
        },
        {
          "id": "rule-error-display-requires-error-text",
          "title": "Error display requires error text",
          "text": "An error display within the debug log view must be provided with an error message string to render.",
          "kind": "constraint",
          "conceptIds": [
            "debug-log-view"
          ]
        },
        {
          "id": "rule-error-display-supports-dismiss",
          "title": "Error display can be dismissed",
          "text": "An error shown in the debug log view can be dismissed by the user, removing it from the current view.",
          "kind": "policy",
          "conceptIds": [
            "debug-log-view"
          ]
        },
        {
          "id": "rule-debug-event-must-have-type-and-timestamp",
          "title": "Debug event has type and timestamp",
          "text": "Each debug event shown in the debug log view must have a specific event type and a timestamp indicating when it occurred.",
          "kind": "invariant",
          "conceptIds": [
            "debug-log-view"
          ]
        },
        {
          "id": "rule-xml-must-be-parseable",
          "title": "XML content must be parseable into elements",
          "text": "The XML response structure must be formatted such that it can be parsed into one or more <tag>content</tag> elements; otherwise, no structured XML elements will be detected for inspection.",
          "kind": "constraint",
          "conceptIds": [
            "xml-response-structure"
          ]
        },
        {
          "id": "rule-xml-may-be-wrapped-response",
          "title": "Optional response wrapper element is ignored",
          "text": "If the XML response structure is wrapped in a <response> element, that wrapper is ignored for inspection purposes and only its child elements are treated as the meaningful structured XML elements.",
          "kind": "assumption",
          "conceptIds": [
            "xml-response-structure"
          ]
        },
        {
          "id": "rule-xml-may-include-attributes",
          "title": "XML elements may include attributes",
          "text": "Elements within the XML response structure may include attributes expressed as key=\"value\" pairs, which are captured and made available for inspection when present.",
          "kind": "assumption",
          "conceptIds": [
            "xml-response-structure"
          ]
        },
        {
          "id": "rule-xml-may-be-embedded-in-code-block",
          "title": "XML content may be embedded in code block markers",
          "text": "The XML response structure may be embedded within markdown-style ```xml code block markers; these markers are removed before parsing so that the underlying XML can be inspected.",
          "kind": "assumption",
          "conceptIds": [
            "xml-response-structure"
          ]
        },
        {
          "id": "rule-slack-markdown-rendering-requires-string-content",
          "title": "Slack markdown rendering requires string content",
          "text": "Slack markdown rendering must receive Slack-formatted content as a string in order to perform the conversion and display.",
          "kind": "constraint",
          "conceptIds": [
            "slack-markdown-rendering"
          ]
        },
        {
          "id": "rule-slack-markdown-rendering-produces-html-output",
          "title": "Slack markdown rendering produces HTML output",
          "text": "Slack markdown rendering always produces HTML output from the provided Slack-formatted content, suitable for direct embedding in the web UI.",
          "kind": "assumption",
          "conceptIds": [
            "slack-markdown-rendering"
          ]
        },
        {
          "id": "rule-slack-markdown-rendering-is-read-only-display",
          "title": "Slack markdown rendering is read-only display",
          "text": "Slack markdown rendering is used for displaying Slack-formatted content for review and debugging and does not modify the underlying content.",
          "kind": "assumption",
          "conceptIds": [
            "slack-markdown-rendering"
          ]
        }
      ],
      "lifecycles": [
        {
          "id": "lifecycle-data-request-detail-view-loading",
          "subjectConceptId": "data-request-detail-view",
          "stateConceptIds": [
            "data-request-detail-view-loading",
            "data-request-detail-view-loaded"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "data-request-detail-view-loading",
          "terminalStateIds": [
            "data-request-detail-view-loaded"
          ]
        },
        {
          "id": "lifecycle-thread-status-basic",
          "subjectConceptId": "thread-status",
          "stateConceptIds": [
            "pending",
            "in-progress",
            "completed"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "pending",
          "terminalStateIds": [
            "completed"
          ]
        },
        {
          "id": "lifecycle-debug-log-view-visibility",
          "subjectConceptId": "debug-log-view",
          "stateConceptIds": [
            "debug-log-view-hidden",
            "debug-log-view-visible"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "debug-log-view-hidden",
          "terminalStateIds": [
            "debug-log-view-hidden"
          ]
        }
      ],
      "views": [
        {
          "id": "data-request-monitoring-overview",
          "name": "Monitoring data requests in the web UI",
          "kind": "overview",
          "description": "How users browse data requests and drill into a single request for detailed tracking and observability.",
          "conceptIds": [
            "user",
            "data-request-list",
            "data-request-list-view",
            "data-request",
            "data-request-detail-view",
            "data-request-tracking-and-observability",
            "data-request-status",
            "data-request-thread"
          ],
          "relationshipIds": [
            "rel-data-request-list-is-viewed-by-user",
            "rel-data-request-list-contains-thread",
            "rel-data-request-list-uses-status",
            "rel-data-request-detail-uses-data-request",
            "rel-data-request-detail-part-of-tracking-observability",
            "rel-debug-log-view-part-of-observability",
            "rel-data-request-detail-navigated-from-list"
          ]
        },
        {
          "id": "data-request-detail-and-debugging",
          "name": "Data request detail and debugging views",
          "kind": "structure",
          "description": "How the data request detail view and debug log view present underlying events, responses, and errors for a single request.",
          "conceptIds": [
            "data-request-detail-view",
            "debug-log-view",
            "debug-event",
            "llm-response",
            "slack-message",
            "error",
            "llm-interaction",
            "slack-interaction"
          ],
          "relationshipIds": [
            "rel-data-request-detail-uses-debug-events",
            "rel-data-request-detail-uses-llm-responses",
            "rel-data-request-detail-uses-slack-markdown",
            "rel-debug-log-view-uses-debug-events",
            "rel-debug-log-view-uses-error",
            "rel-debug-log-view-represents-llm-interaction",
            "rel-debug-log-view-represents-slack-interaction"
          ]
        },
        {
          "id": "thread-processing-status",
          "name": "Slack thread processing and status tracking",
          "kind": "lifecycle",
          "description": "How the processing status of a Slack thread is stored and updated during background processing.",
          "conceptIds": [
            "slack-thread",
            "thread-status",
            "thread-document",
            "worker-process",
            "timing-metric",
            "debug-log-view",
            "debug-event"
          ],
          "relationshipIds": [
            "rel-thread-status-belongs-to-thread",
            "rel-thread-status-stored-in-thread-doc",
            "rel-thread-status-updated-by-worker",
            "rel-debug-log-view-represents-timing-metrics",
            "rel-debug-log-view-uses-debug-events"
          ]
        },
        {
          "id": "test-execution-results-structure",
          "name": "Structure of a test execution result",
          "kind": "structure",
          "description": "How a test execution result aggregates checks, model output, and related artifacts.",
          "conceptIds": [
            "test-execution-result",
            "test-execution",
            "test-run-result",
            "model-output",
            "llm-model",
            "check-result",
            "check",
            "test-case"
          ],
          "relationshipIds": [
            "rel-test-execution-result-produced-by-execute-test",
            "rel-test-execution-result-refers-to-test-run-result",
            "rel-test-execution-result-summarizes-model-output",
            "rel-test-execution-result-uses-model",
            "rel-test-execution-result-derived-from-test-case-checks",
            "rel-test-execution-result-overall-status-derived-from-checks",
            "rel-test-execution-result-associated-with-test-case"
          ]
        },
        {
          "id": "xml-response-and-evaluation",
          "name": "XML response structure within evaluation results",
          "kind": "implementation",
          "description": "How XML-formatted LLM responses are structured, parsed, and embedded in evaluation results.",
          "conceptIds": [
            "xml-response-structure",
            "llm-response",
            "evaluation-result",
            "xml-response-parser",
            "xml-element",
            "xml-response-wrapper-element"
          ],
          "relationshipIds": [
            "rel-xml-uses-llm-response",
            "rel-xml-part-of-eval-result",
            "rel-xml-used-by-parser",
            "rel-xml-has-elements",
            "rel-xml-may-be-wrapped"
          ]
        },
        {
          "id": "slack-markdown-in-tracking-ui",
          "name": "Slack markdown rendering for review and debugging",
          "kind": "implementation",
          "description": "How Slack-formatted content is parsed and rendered in the data request tracking web UI to support review and debugging.",
          "conceptIds": [
            "slack-markdown-rendering",
            "slack-markdown-content",
            "slack-markdown-parser",
            "web-ui-review-and-debugging",
            "data-request-tracking-web-ui",
            "slack-message",
            "data-request-detail-view"
          ],
          "relationshipIds": [
            "rel-slack-markdown-rendering-uses-slack-markdown-content",
            "rel-slack-markdown-rendering-uses-slack-markdown-parser",
            "rel-slack-markdown-rendering-enables-web-ui-review",
            "rel-slack-markdown-rendering-part-of-data-request-tracking-ui",
            "rel-data-request-detail-uses-slack-markdown"
          ]
        }
      ],
      "storyViews": [
        {
          "id": "analyst-browses-requests-and-drills-into-one-thread",
          "name": "Analyst browses data requests and drills into one thread",
          "kind": "user_flow",
          "description": "An analyst signs in, scans the list of data requests, filters to find a specific Slack thread, and opens the detail view to inspect its history and artifacts.",
          "tags": [
            "monitoring",
            "triage",
            "browsing"
          ],
          "focusConceptId": "data-request-list",
          "steps": [
            {
              "id": "analyst-opens-request-list",
              "index": 0,
              "title": "Analyst opens the data request list",
              "narrative": "A signed-in user navigates to the web UI and lands on the data request list, which summarizes Slack threads as trackable data requests.",
              "conceptIds": [
                "data-request-list"
              ],
              "relationshipIds": [
                "rel-data-request-list-is-viewed-by-user",
                "rel-data-request-list-represents-slack-threads"
              ],
              "primaryConceptIds": [
                "data-request-list"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-list-is-viewed-by-user"
              ]
            },
            {
              "id": "analyst-filters-by-channel-and-requester",
              "index": 1,
              "title": "Analyst filters by Slack channel and requester",
              "narrative": "To narrow down the list, the analyst filters requests by a specific Slack channel and requester, then sorts by most recent activity.",
              "conceptIds": [
                "data-request-list"
              ],
              "relationshipIds": [
                "rel-data-request-list-filters-by-channel",
                "rel-data-request-list-filters-by-requester",
                "rel-data-request-list-orders-by-time"
              ],
              "primaryConceptIds": [
                "data-request-list"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-list-filters-by-channel",
                "rel-data-request-list-filters-by-requester"
              ]
            },
            {
              "id": "analyst-scans-status-and-artifacts",
              "index": 2,
              "title": "Analyst scans request status and artifacts",
              "narrative": "The analyst scans the filtered list, using each request’s status and available artifacts to decide which thread needs deeper investigation.",
              "conceptIds": [
                "data-request-list"
              ],
              "relationshipIds": [
                "rel-data-request-list-uses-status",
                "rel-data-request-list-uses-artifacts"
              ],
              "primaryConceptIds": [
                "data-request-list"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-list-uses-status"
              ]
            },
            {
              "id": "analyst-selects-one-thread",
              "index": 3,
              "title": "Analyst selects a specific Slack thread",
              "narrative": "From the list, the analyst clicks a row representing a particular Slack thread to open its detailed history and context.",
              "conceptIds": [
                "data-request-list"
              ],
              "relationshipIds": [
                "rel-data-request-list-contains-thread"
              ],
              "primaryConceptIds": [
                "data-request-list"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-list-contains-thread"
              ]
            },
            {
              "id": "system-navigates-to-detail-view",
              "index": 4,
              "title": "System navigates to the data request detail view",
              "narrative": "The UI transitions from the list to the data request detail view for the selected thread, preparing to load its full record.",
              "conceptIds": [
                "data-request-detail-view",
                "data-request-list"
              ],
              "relationshipIds": [
                "rel-data-request-detail-navigated-from-list"
              ],
              "primaryConceptIds": [
                "data-request-detail-view"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-detail-navigated-from-list"
              ]
            }
          ]
        },
        {
          "id": "engineer-inspects-single-request-with-logs-and-slack-context",
          "name": "Engineer inspects a single data request with logs and Slack context",
          "kind": "user_flow",
          "description": "An engineer opens a specific data request detail view, reviews its Slack context, LLM responses, and debug logs to understand what happened.",
          "tags": [
            "debugging",
            "detail-view",
            "observability"
          ],
          "focusConceptId": "data-request-detail-view",
          "steps": [
            {
              "id": "auth-check-before-detail-view",
              "index": 0,
              "title": "Authenticated session required for detail view",
              "narrative": "Before loading the detail view, the system verifies that the user has an authenticated session to access request internals.",
              "conceptIds": [
                "data-request-detail-view"
              ],
              "relationshipIds": [
                "rel-data-request-detail-preceded-by-auth"
              ],
              "primaryConceptIds": [
                "data-request-detail-view"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-detail-preceded-by-auth"
              ]
            },
            {
              "id": "detail-view-loads-from-store",
              "index": 1,
              "title": "Detail view loads request data from the store",
              "narrative": "The data request detail view reads the selected request’s record from the data request store, including its history and status.",
              "conceptIds": [
                "data-request-detail-view"
              ],
              "relationshipIds": [
                "rel-data-request-detail-uses-firestore",
                "rel-data-request-detail-uses-data-request"
              ],
              "primaryConceptIds": [
                "data-request-detail-view"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-detail-uses-firestore"
              ]
            },
            {
              "id": "detail-view-renders-slack-context",
              "index": 2,
              "title": "Detail view renders Slack messages and context",
              "narrative": "The view renders the original Slack messages and thread context so the engineer can see what the requester asked and how the bot replied.",
              "conceptIds": [
                "data-request-detail-view",
                "slack-markdown-rendering"
              ],
              "relationshipIds": [
                "rel-data-request-detail-uses-slack-markdown",
                "rel-slack-markdown-rendering-uses-slack-markdown-content",
                "rel-slack-markdown-rendering-uses-slack-markdown-parser"
              ],
              "primaryConceptIds": [
                "data-request-detail-view",
                "slack-markdown-rendering"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-detail-uses-slack-markdown"
              ]
            },
            {
              "id": "detail-view-shows-llm-responses",
              "index": 3,
              "title": "Detail view shows LLM responses and evaluation results",
              "narrative": "The engineer inspects the LLM responses associated with the request, including any structured XML response segments used for evaluation.",
              "conceptIds": [
                "data-request-detail-view",
                "xml-response-structure"
              ],
              "relationshipIds": [
                "rel-data-request-detail-uses-llm-responses",
                "rel-xml-uses-llm-response",
                "rel-xml-part-of-eval-result"
              ],
              "primaryConceptIds": [
                "data-request-detail-view"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-detail-uses-llm-responses"
              ]
            },
            {
              "id": "detail-view-surfaces-debug-events",
              "index": 4,
              "title": "Detail view surfaces debug events and errors",
              "narrative": "To understand anomalies, the engineer opens the debug section of the detail view, which shows debug events and any errors that occurred during processing.",
              "conceptIds": [
                "data-request-detail-view",
                "debug-log-view"
              ],
              "relationshipIds": [
                "rel-data-request-detail-uses-debug-events",
                "rel-debug-log-view-uses-debug-events",
                "rel-debug-log-view-uses-error"
              ],
              "primaryConceptIds": [
                "debug-log-view"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-detail-uses-debug-events"
              ]
            },
            {
              "id": "engineer-completes-investigation",
              "index": 5,
              "title": "Engineer completes investigation with full observability",
              "narrative": "With Slack context, LLM responses, and debug logs in one place, the engineer can explain the behavior of the request and decide on any follow-up actions.",
              "conceptIds": [
                "data-request-detail-view",
                "debug-log-view"
              ],
              "relationshipIds": [
                "rel-debug-log-view-part-of-observability",
                "rel-data-request-detail-part-of-tracking-observability"
              ],
              "primaryConceptIds": [
                "data-request-detail-view"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-detail-part-of-tracking-observability"
              ]
            }
          ]
        },
        {
          "id": "system-updates-thread-status-and-logs-llm-interactions",
          "name": "System updates thread status and logs LLM interactions",
          "kind": "system_flow",
          "description": "A worker processes a Slack thread, updates its status over time, and records detailed LLM and Slack interaction logs for later inspection.",
          "tags": [
            "background-processing",
            "status-tracking",
            "logging"
          ],
          "focusConceptId": "thread-status",
          "steps": [
            {
              "id": "worker-picks-up-thread",
              "index": 0,
              "title": "Worker picks up a new Slack thread",
              "narrative": "A worker process detects a new Slack thread that has been turned into a data request and begins processing it.",
              "conceptIds": [
                "thread-status"
              ],
              "relationshipIds": [
                "rel-thread-status-belongs-to-thread",
                "rel-thread-status-stored-in-thread-doc"
              ],
              "primaryConceptIds": [
                "thread-status"
              ],
              "primaryRelationshipIds": [
                "rel-thread-status-belongs-to-thread"
              ]
            },
            {
              "id": "worker-sets-status-in-progress",
              "index": 1,
              "title": "Worker sets thread status to in-progress",
              "narrative": "The worker updates the thread’s status field in the thread document to indicate that processing is underway.",
              "conceptIds": [
                "thread-status"
              ],
              "relationshipIds": [
                "rel-thread-status-updated-by-worker",
                "rel-thread-status-stored-in-thread-doc"
              ],
              "primaryConceptIds": [
                "thread-status"
              ],
              "primaryRelationshipIds": [
                "rel-thread-status-updated-by-worker"
              ]
            },
            {
              "id": "worker-invokes-llm-and-logs-interaction",
              "index": 2,
              "title": "Worker invokes LLM and logs interaction details",
              "narrative": "As the worker calls the LLM and exchanges messages with Slack, it records LLM interaction events, Slack interaction events, and timing metrics for observability.",
              "conceptIds": [
                "debug-log-view"
              ],
              "relationshipIds": [
                "rel-debug-log-view-represents-llm-interaction",
                "rel-debug-log-view-represents-slack-interaction",
                "rel-debug-log-view-represents-timing-metrics"
              ],
              "primaryConceptIds": [
                "debug-log-view"
              ],
              "primaryRelationshipIds": [
                "rel-debug-log-view-represents-llm-interaction"
              ]
            },
            {
              "id": "worker-completes-thread-and-updates-status",
              "index": 3,
              "title": "Worker completes processing and updates status",
              "narrative": "Once all LLM calls and Slack replies are finished, the worker updates the thread status to completed in the thread document.",
              "conceptIds": [
                "thread-status"
              ],
              "relationshipIds": [
                "rel-thread-status-updated-by-worker",
                "rel-thread-status-stored-in-thread-doc"
              ],
              "primaryConceptIds": [
                "thread-status"
              ],
              "primaryRelationshipIds": [
                "rel-thread-status-updated-by-worker"
              ]
            },
            {
              "id": "status-and-logs-available-in-ui",
              "index": 4,
              "title": "Status and logs become visible in tracking UI",
              "narrative": "The updated thread status and accumulated interaction logs are now available to the data request tracking and debug views for user inspection.",
              "conceptIds": [
                "thread-status",
                "debug-log-view"
              ],
              "relationshipIds": [
                "rel-debug-log-view-part-of-observability"
              ],
              "primaryConceptIds": [
                "thread-status",
                "debug-log-view"
              ],
              "primaryRelationshipIds": [
                "rel-debug-log-view-part-of-observability"
              ]
            }
          ]
        },
        {
          "id": "llm-evaluation-run-produces-test-execution-results",
          "name": "LLM evaluation run produces test execution results",
          "kind": "system_flow",
          "description": "A test execution runs against an LLM model, parses XML responses, aggregates check results, and stores a summarized test execution result linked to the originating request.",
          "tags": [
            "evaluation",
            "testing",
            "llm"
          ],
          "focusConceptId": "test-execution-result",
          "steps": [
            {
              "id": "test-execution-invokes-model",
              "index": 0,
              "title": "Test execution invokes the LLM model",
              "narrative": "A test execution runs a test case against a specific LLM model using a prompt template and the original request context.",
              "conceptIds": [
                "test-execution-result"
              ],
              "relationshipIds": [
                "rel-test-execution-result-uses-model",
                "rel-test-execution-result-associated-with-test-case",
                "rel-test-execution-result-associated-with-template",
                "rel-test-execution-result-associated-with-request"
              ],
              "primaryConceptIds": [
                "test-execution-result"
              ],
              "primaryRelationshipIds": [
                "rel-test-execution-result-uses-model"
              ]
            },
            {
              "id": "model-produces-xml-structured-output",
              "index": 1,
              "title": "Model produces XML-structured output",
              "narrative": "The LLM returns a response that includes an XML response structure, which is parsed into elements for downstream checks.",
              "conceptIds": [
                "xml-response-structure"
              ],
              "relationshipIds": [
                "rel-xml-uses-llm-response",
                "rel-xml-used-by-parser",
                "rel-xml-has-elements",
                "rel-xml-may-be-wrapped"
              ],
              "primaryConceptIds": [
                "xml-response-structure"
              ],
              "primaryRelationshipIds": [
                "rel-xml-used-by-parser"
              ]
            },
            {
              "id": "checks-run-on-model-output",
              "index": 2,
              "title": "Checks run on parsed model output",
              "narrative": "Automated checks evaluate the parsed model output, producing individual check results that capture pass/fail and metrics.",
              "conceptIds": [
                "test-execution-result"
              ],
              "relationshipIds": [
                "rel-test-execution-result-derived-from-test-case-checks",
                "rel-test-execution-result-overall-status-derived-from-checks",
                "rel-test-execution-result-summarizes-model-output"
              ],
              "primaryConceptIds": [
                "test-execution-result"
              ],
              "primaryRelationshipIds": [
                "rel-test-execution-result-derived-from-test-case-checks"
              ]
            },
            {
              "id": "aggregate-test-execution-result-created",
              "index": 3,
              "title": "Aggregate test execution result is created",
              "narrative": "The system aggregates all check results and model output into a single test execution result object, including an overall status.",
              "conceptIds": [
                "test-execution-result"
              ],
              "relationshipIds": [
                "rel-test-execution-result-produced-by-execute-test",
                "rel-test-execution-result-refers-to-test-run-result"
              ],
              "primaryConceptIds": [
                "test-execution-result"
              ],
              "primaryRelationshipIds": [
                "rel-test-execution-result-produced-by-execute-test"
              ]
            },
            {
              "id": "evaluation-result-linked-back-to-request",
              "index": 4,
              "title": "Evaluation result is linked back to the data request",
              "narrative": "The test execution result, including its XML response structure, is associated with the originating request so it can be surfaced in the data request detail and debug views.",
              "conceptIds": [
                "test-execution-result",
                "xml-response-structure"
              ],
              "relationshipIds": [
                "rel-test-execution-result-associated-with-request",
                "rel-xml-part-of-eval-result"
              ],
              "primaryConceptIds": [
                "test-execution-result"
              ],
              "primaryRelationshipIds": [
                "rel-test-execution-result-associated-with-request"
              ]
            }
          ]
        },
        {
          "id": "debugging-a-failed-request-with-errors-and-xml-parsing-issues",
          "name": "Debugging a failed request with errors and XML parsing issues",
          "kind": "error_flow",
          "description": "An engineer investigates a failed data request where the LLM returned malformed XML, causing parsing errors that are surfaced in the debug log view.",
          "tags": [
            "error",
            "xml",
            "debugging"
          ],
          "focusConceptId": "debug-log-view",
          "steps": [
            {
              "id": "request-fails-during-processing",
              "index": 0,
              "title": "Request fails during processing due to malformed XML",
              "narrative": "During processing of a data request, the LLM returns a response with malformed XML, triggering errors in the XML response parser.",
              "conceptIds": [
                "xml-response-structure"
              ],
              "relationshipIds": [
                "rel-xml-used-by-parser"
              ],
              "primaryConceptIds": [
                "xml-response-structure"
              ],
              "primaryRelationshipIds": [
                "rel-xml-used-by-parser"
              ]
            },
            {
              "id": "errors-and-debug-events-recorded",
              "index": 1,
              "title": "Errors and debug events are recorded",
              "narrative": "The system records debug events and error objects that capture the parsing failure, timing, and related LLM interaction details.",
              "conceptIds": [
                "debug-log-view"
              ],
              "relationshipIds": [
                "rel-debug-log-view-uses-debug-events",
                "rel-debug-log-view-uses-error",
                "rel-debug-log-view-represents-llm-interaction"
              ],
              "primaryConceptIds": [
                "debug-log-view"
              ],
              "primaryRelationshipIds": [
                "rel-debug-log-view-uses-error"
              ]
            },
            {
              "id": "engineer-opens-detail-view-for-failed-request",
              "index": 2,
              "title": "Engineer opens the detail view for the failed request",
              "narrative": "Noticing a failed status in the data request list, an engineer opens the data request detail view to investigate the failure.",
              "conceptIds": [
                "data-request-list",
                "data-request-detail-view"
              ],
              "relationshipIds": [
                "rel-data-request-detail-navigated-from-list",
                "rel-data-request-detail-uses-data-request"
              ],
              "primaryConceptIds": [
                "data-request-detail-view"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-detail-navigated-from-list"
              ]
            },
            {
              "id": "engineer-inspects-debug-log-view",
              "index": 3,
              "title": "Engineer inspects the debug log view for errors",
              "narrative": "Within the detail view, the engineer opens the debug log view to see the recorded errors, debug events, and timing metrics around the failure.",
              "conceptIds": [
                "debug-log-view",
                "data-request-detail-view"
              ],
              "relationshipIds": [
                "rel-data-request-detail-uses-debug-events",
                "rel-debug-log-view-uses-debug-events",
                "rel-debug-log-view-represents-timing-metrics"
              ],
              "primaryConceptIds": [
                "debug-log-view"
              ],
              "primaryRelationshipIds": [
                "rel-debug-log-view-uses-debug-events"
              ]
            },
            {
              "id": "engineer-reviews-raw-llm-response-and-xml",
              "index": 4,
              "title": "Engineer reviews raw LLM response and XML structure",
              "narrative": "Using the LLM response tabs and XML response structure, the engineer compares the raw response to the expected XML format to pinpoint the malformed segment.",
              "conceptIds": [
                "debug-log-view",
                "xml-response-structure"
              ],
              "relationshipIds": [
                "rel-debug-log-view-uses-llm-response-tabs",
                "rel-xml-uses-llm-response",
                "rel-xml-has-elements"
              ],
              "primaryConceptIds": [
                "xml-response-structure"
              ],
              "primaryRelationshipIds": [
                "rel-debug-log-view-uses-llm-response-tabs"
              ]
            },
            {
              "id": "engineer-derives-fix-from-observability-data",
              "index": 5,
              "title": "Engineer derives a fix from observability data",
              "narrative": "Armed with precise error messages, timing metrics, and the malformed XML, the engineer can adjust prompts or parsing rules to prevent similar failures.",
              "conceptIds": [
                "debug-log-view"
              ],
              "relationshipIds": [
                "rel-debug-log-view-part-of-observability"
              ],
              "primaryConceptIds": [
                "debug-log-view"
              ],
              "primaryRelationshipIds": [
                "rel-debug-log-view-part-of-observability"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "infrastructure-and-runtime",
      "title": "Infrastructure, Tasks, and Shared Runtime",
      "description": "The shared infrastructure concepts that support background processing, configuration, and error handling across the system.",
      "concepts": [
        {
          "id": "background-task",
          "label": "Background task",
          "category": "thing",
          "description": "A unit of asynchronous work scheduled and executed by workers, such as LLM jobs or test executions.",
          "aliases": [
            "background task",
            "task",
            "Cloud Task",
            "work",
            "job",
            "LLM job",
            "test execution task",
            "worker task",
            "TaskPayload",
            "TestExecutionTaskPayload"
          ],
          "notes": "A background task is a unit of asynchronous work that is enqueued to a task queue (e.g., Google Cloud Tasks) and later executed by a worker service. In this system, background tasks primarily represent LLM-related jobs triggered from Slack interactions and test execution jobs triggered from evaluation functions. The payload types (TaskPayload, TestExecutionTaskPayload) capture the domain-specific data needed by workers to process these tasks."
        },
        {
          "id": "test-batch-lifecycle",
          "label": "Test batch lifecycle",
          "category": "state",
          "description": "The progression of a test batch from creation through execution, completion, or cancellation.",
          "aliases": [
            "Test batch lifecycle",
            "batch lifecycle",
            "test batch status progression",
            "batch status lifecycle"
          ],
          "notes": "Test batch lifecycle describes how a TestBatch progresses through its statuses (e.g., running, completed, cancelled, failed) from creation until it reaches a terminal state. It is observed via fields such as status, completedCount, and totalTestCases, and is surfaced in UI components like BatchProgressIndicator and in backend functions that create and execute batches."
        },
        {
          "id": "firestore-database",
          "label": "Firestore database",
          "category": "place",
          "description": "The persistent store for threads, templates, test results, debug events, and related artifacts.",
          "aliases": [
            "firestore-database",
            "Firestore",
            "db",
            "getDb",
            "FirestoreLike"
          ],
          "notes": "The Firestore database is the central persistent store for the system. It holds threads and their associated subcollections (including debug events), as well as other artifacts such as templates, test results, and related data. Multiple applications (worker, ingest, evals UI) share the same logical Firestore database, accessed either via server-side credentials (ADC) or client-side Firebase initialization. A minimal FirestoreLike interface is defined so shared runtime utilities (e.g., debug event recording) can operate against Firestore or compatible test doubles without depending on full Firestore APIs."
        },
        {
          "id": "cloud-functions-environment",
          "label": "Cloud Functions environment",
          "category": "place",
          "description": "The serverless environment where HTTP endpoints and background functions for tests and LLM calls run.",
          "aliases": [
            "Cloud Functions environment",
            "Firebase Functions",
            "functions environment",
            "serverless environment for tests",
            "serverless environment for LLM calls",
            "evals-functions"
          ],
          "notes": "The Cloud Functions environment is the serverless runtime where callable HTTP-style endpoints and background logic for tests and LLM calls execute. In this project it is represented by the `apps/evals-functions` package, initialized with Firebase Admin and Firebase Functions v2 HTTPS callable handlers. It is configured via environment parameters (e.g., worker URL, Cloud Tasks settings, service account) and has access to Firestore and shared utilities for executing LLM prompts and recording debug events."
        },
        {
          "id": "worker-environment",
          "label": "Worker environment",
          "category": "place",
          "description": "The long-running worker processes that consume tasks, call LLMs, and interact with Slack.",
          "aliases": [
            "worker environment",
            "worker config",
            "worker process",
            "worker",
            "long-running worker",
            "LLM worker",
            "Slack worker"
          ],
          "notes": "The worker environment is the runtime context and configuration in which long-running worker processes operate. These workers consume queued tasks, call shared LLM runtime functions, interact with Slack, and read/write to the database. The environment is characterized by configuration values (Slack bot token, cloud project, region) and access to shared infrastructure (Firestore DB, LLM providers, Slack API). It is assumed to be long-lived and capable of processing multiple jobs over time."
        },
        {
          "id": "environment-configuration",
          "label": "Environment configuration",
          "category": "thing",
          "description": "The set of environment variables and configuration values required for the system to operate safely.",
          "aliases": [
            "environment configuration",
            "environment variables",
            "env",
            "env config",
            "config",
            "required environment variables"
          ],
          "notes": "Environment configuration is the set of environment variables and their values that must be present for each part of the system (worker, ingest app, shared runtime, evals functions) to operate safely. It includes secrets (e.g., Slack tokens, signing secrets), infrastructure identifiers (e.g., Google Cloud project ID, region), and operational parameters (e.g., task queue name). Some variables are treated as strictly required (via requireEnv, or by throwing if missing), while others may have fallbacks or be optional. Each application reads its own subset of environment variables at startup and uses them to connect to external services and infrastructure."
        },
        {
          "id": "authentication-session",
          "label": "Authentication session",
          "category": "state",
          "description": "The authenticated state of a user accessing the evaluation UI, typically via Google sign-in.",
          "aliases": [
            "authentication session",
            "auth session",
            "authenticated state",
            "Firebase auth state",
            "Google sign-in session"
          ],
          "notes": "An authentication session represents the period during which a user is recognized as authenticated in the evaluation UI, backed by Firebase Authentication and typically established via Google sign-in. The exported `auth` object from Firebase is the runtime handle through which this authenticated state is observed and managed."
        },
        {
          "id": "application-error",
          "label": "Application error",
          "category": "thing",
          "description": "A structured description of a failure within the system, including severity and context.",
          "aliases": [
            "application-error",
            "AppError",
            "error",
            "structured error",
            "structured error event"
          ],
          "notes": "An application error is a structured description of a failure within the Slack-based data request and LLM evaluation system. It captures a machine-readable code, a user-facing message, a severity level, recoverability, and optional technical/context data so that failures can be logged, analyzed, and communicated consistently across apps and the shared runtime."
        },
        {
          "id": "logging",
          "label": "Logging",
          "category": "activity",
          "description": "The activity of recording informational and error logs associated with requests and operations.",
          "aliases": [
            "logging",
            "log",
            "logs",
            "structured logging",
            "info log",
            "error log",
            "logInfo",
            "logError",
            "request logging",
            "withRequest"
          ],
          "notes": "Logging is the activity of recording structured informational and error messages about requests and operations. Logs are emitted as JSON objects with at least a `level` and `message`, and may include additional contextual fields (e.g., request-related fields) merged via helper functions. Logging is shared infrastructure used by multiple services in the system."
        },
        {
          "id": "task-queue",
          "label": "Task queue",
          "category": "thing",
          "description": "The queueing mechanism used to schedule and distribute background tasks to workers.",
          "aliases": [
            "task-queue",
            "tasksQueue",
            "Cloud Tasks queue",
            "queue",
            "requests queue"
          ],
          "notes": "The task queue is a named Cloud Tasks queue (e.g., 'requests') in a specific location (e.g., 'us-central1') used to schedule and distribute background tasks to worker services. It is configured via environment/parameter values and is associated with a service account used for OIDC tokens when invoking the worker."
        }
      ],
      "relationships": [
        {
          "id": "rel-background-task-uses-task-payload",
          "from": "background-task",
          "to": "task-payload",
          "phrase": "is parameterized by",
          "category": "uses",
          "description": "A background task that represents Slack/LLM work carries a TaskPayload describing the Slack channel, root message timestamp, optional message timestamp, user, text, and metadata."
        },
        {
          "id": "rel-background-task-uses-test-execution-task-payload",
          "from": "background-task",
          "to": "test-execution-task-payload",
          "phrase": "is parameterized by",
          "category": "uses",
          "description": "A background task that represents a test execution carries a TestExecutionTaskPayload describing the batch, test case, template, and user responsible for the execution."
        },
        {
          "id": "rel-background-task-precedes-worker-processing",
          "from": "background-task",
          "to": "worker-processing",
          "phrase": "is executed by",
          "category": "precedes",
          "description": "A background task is eventually delivered to and executed by a worker endpoint (e.g., the /tasks/llm handler on the worker service)."
        },
        {
          "id": "rel-background-task-part-of-test-batch",
          "from": "background-task",
          "to": "test-batch",
          "phrase": "belongs to",
          "category": "part_of",
          "description": "A background task for test execution is associated with a TestBatch via its batchId, indicating that the execution is part of a larger batch of tests."
        },
        {
          "id": "rel-background-task-uses-prompt-template",
          "from": "background-task",
          "to": "prompt-template",
          "phrase": "uses",
          "category": "uses",
          "description": "A background task for test execution references a PromptTemplate via templateId, and the worker uses the active template version to run the test."
        },
        {
          "id": "rel-background-task-originates-from-slack-event",
          "from": "background-task",
          "to": "slack-event",
          "phrase": "is triggered by",
          "category": "causes",
          "description": "A background task carrying TaskPayload is triggered by a Slack event or message, using channel and timestamp fields to link back to the originating Slack context."
        },
        {
          "id": "rel-background-task-originates-from-test-execution-request",
          "from": "background-task",
          "to": "test-execution-request",
          "phrase": "is created from",
          "category": "causes",
          "description": "A background task for test execution is created when a client invokes the executeTest callable function with a templateId, inputVariables, and testCaseId."
        },
        {
          "id": "rel-background-task-associated-with-user",
          "from": "background-task",
          "to": "user",
          "phrase": "is initiated by",
          "category": "uses",
          "description": "A background task records the initiating user (Slack user or authenticated Firebase user) so that results and permissions can be associated with that user."
        },
        {
          "id": "rel-test-batch-lifecycle-uses-test-batch",
          "from": "test-batch-lifecycle",
          "to": "test-batch",
          "phrase": "uses",
          "category": "uses",
          "description": "Test batch lifecycle is expressed through the status and progress-related fields of a TestBatch (e.g., status, completedCount, totalTestCases, id)."
        },
        {
          "id": "rel-test-batch-lifecycle-precedes-test-execution",
          "from": "test-batch-lifecycle",
          "to": "test-execution-task",
          "phrase": "precedes",
          "category": "precedes",
          "description": "A test batch lifecycle begins when a batch is created and enqueued for execution, and it precedes and encompasses the execution of one or more test execution tasks."
        },
        {
          "id": "rel-test-batch-lifecycle-enables-batch-cancellation",
          "from": "test-batch-lifecycle",
          "to": "batch-cancellation",
          "phrase": "enables",
          "category": "enables",
          "description": "The test batch lifecycle includes a running state during which a user may invoke cancellation, enabling a transition to a cancelled state."
        },
        {
          "id": "rel-firestore-threads",
          "from": "firestore-database",
          "to": "thread",
          "phrase": "stores",
          "category": "uses",
          "description": "The Firestore database stores threads as documents in the 'threads' collection, each identified by a root timestamp or similar thread identifier."
        },
        {
          "id": "rel-firestore-debug-events",
          "from": "firestore-database",
          "to": "debug-event",
          "phrase": "stores",
          "category": "uses",
          "description": "The Firestore database stores debug events as documents in a 'debugEvents' subcollection under each thread document."
        },
        {
          "id": "rel-thread-has-debug-events",
          "from": "thread",
          "to": "debug-event",
          "phrase": "has debug events in subcollection",
          "category": "part_of",
          "description": "Each thread document in Firestore can have a 'debugEvents' subcollection containing debug event documents associated with that thread."
        },
        {
          "id": "rel-firestore-shared-runtime",
          "from": "shared-runtime",
          "to": "firestore-database",
          "phrase": "uses for recording debug events",
          "category": "uses",
          "description": "The shared runtime utilities use the Firestore database (or a FirestoreLike instance) to record debug events and errors under the appropriate thread."
        },
        {
          "id": "rel-firestore-worker-app",
          "from": "worker-app",
          "to": "firestore-database",
          "phrase": "connects to",
          "category": "uses",
          "description": "The worker application obtains a Firestore handle via getDb and uses it as the persistent store for its operations."
        },
        {
          "id": "rel-firestore-ingest-app",
          "from": "ingest-app",
          "to": "firestore-database",
          "phrase": "connects to",
          "category": "uses",
          "description": "The ingest application obtains a Firestore handle via getDb and uses it to persist ingested data and related artifacts."
        },
        {
          "id": "rel-firestore-evals-app",
          "from": "evals-app",
          "to": "firestore-database",
          "phrase": "connects to",
          "category": "uses",
          "description": "The evals application initializes Firebase and obtains a Firestore instance (db) to read and write evaluation-related data such as test results and templates."
        },
        {
          "id": "rel-firestore-auth",
          "from": "auth-system",
          "to": "firestore-database",
          "phrase": "protects access to",
          "category": "enables",
          "description": "The Firebase authentication system (e.g., GoogleAuthProvider) is used by the evals app to control and secure access to the Firestore database."
        },
        {
          "id": "rel-firestore-functions",
          "from": "cloud-functions",
          "to": "firestore-database",
          "phrase": "interact with",
          "category": "uses",
          "description": "Firebase Cloud Functions, configured for a specific region, interact with the Firestore database as part of backend processing for the system."
        },
        {
          "id": "rel-cloud-functions-uses-worker-url",
          "from": "cloud-functions-environment",
          "to": "worker-cloud-run-service",
          "phrase": "routes work to",
          "category": "uses",
          "description": "The Cloud Functions environment uses the configured worker URL to route test execution work to a separate worker Cloud Run service."
        },
        {
          "id": "rel-cloud-functions-uses-cloud-tasks-queue",
          "from": "cloud-functions-environment",
          "to": "cloud-tasks-queue",
          "phrase": "enqueues tasks in",
          "category": "uses",
          "description": "The Cloud Functions environment enqueues background work for test execution into a configured Cloud Tasks queue."
        },
        {
          "id": "rel-cloud-functions-uses-tasks-service-account",
          "from": "cloud-functions-environment",
          "to": "tasks-service-account",
          "phrase": "uses for task authentication",
          "category": "uses",
          "description": "The Cloud Functions environment uses a dedicated service account to obtain OIDC tokens when calling Cloud Tasks targets."
        },
        {
          "id": "rel-cloud-functions-uses-firestore",
          "from": "cloud-functions-environment",
          "to": "firestore-database",
          "phrase": "reads and writes",
          "category": "uses",
          "description": "The Cloud Functions environment uses Firestore to fetch active templates, create test batches, and record debug events for LLM requests."
        },
        {
          "id": "rel-cloud-functions-exposes-echo-endpoint",
          "from": "cloud-functions-environment",
          "to": "echo-function-endpoint",
          "phrase": "exposes",
          "category": "part_of",
          "description": "The Cloud Functions environment exposes an `echo` callable endpoint used for simple connectivity and environment testing."
        },
        {
          "id": "rel-cloud-functions-exposes-execute-test-endpoint",
          "from": "cloud-functions-environment",
          "to": "execute-test-endpoint",
          "phrase": "exposes",
          "category": "part_of",
          "description": "The Cloud Functions environment exposes an `executeTest` callable endpoint that initiates test execution for a single test case."
        },
        {
          "id": "rel-cloud-functions-uses-llm-execution",
          "from": "cloud-functions-environment",
          "to": "llm-execution",
          "phrase": "executes prompts via",
          "category": "uses",
          "description": "The Cloud Functions environment uses shared LLM execution utilities to send prompts to models and obtain responses as part of test runs or other LLM calls."
        },
        {
          "id": "rel-cloud-functions-records-debug-events",
          "from": "cloud-functions-environment",
          "to": "llm-debug-event",
          "phrase": "records",
          "category": "causes",
          "description": "When executing LLM prompts with debug context, the Cloud Functions environment records LLM request debug events in Firestore."
        },
        {
          "id": "rel-cloud-functions-requires-authenticated-user-for-tests",
          "from": "cloud-functions-environment",
          "to": "authenticated-user",
          "phrase": "requires to execute tests",
          "category": "constraint",
          "description": "The Cloud Functions environment requires a caller to be an authenticated user in order to invoke the `executeTest` endpoint."
        },
        {
          "id": "rel-cloud-functions-fetches-active-template",
          "from": "cloud-functions-environment",
          "to": "active-template-version",
          "phrase": "fetches before executing test",
          "category": "precedes",
          "description": "Before enqueuing or executing a test, the Cloud Functions environment fetches the active template version for the requested template ID."
        },
        {
          "id": "rel-cloud-functions-creates-test-batch",
          "from": "cloud-functions-environment",
          "to": "test-batch",
          "phrase": "creates",
          "category": "causes",
          "description": "When handling an `executeTest` request, the Cloud Functions environment creates a test batch document representing the single test case execution."
        },
        {
          "id": "rel-worker-env-uses-slack-token",
          "from": "worker-environment",
          "to": "slack-bot-token",
          "phrase": "uses",
          "category": "uses",
          "description": "The worker environment uses a Slack bot token from configuration to authenticate and perform Slack API operations such as posting messages, adding reactions, and fetching thread messages."
        },
        {
          "id": "rel-worker-env-uses-cloud-project",
          "from": "worker-environment",
          "to": "cloud-project-id",
          "phrase": "uses",
          "category": "uses",
          "description": "The worker environment uses a Google Cloud project ID from configuration to connect to cloud resources such as Firestore and LLM services."
        },
        {
          "id": "rel-worker-env-uses-region",
          "from": "worker-environment",
          "to": "cloud-region",
          "phrase": "uses",
          "category": "uses",
          "description": "The worker environment uses a configured cloud region to determine where its cloud resources (e.g., LLM endpoints, databases) are hosted."
        },
        {
          "id": "rel-worker-env-runs-llm-jobs",
          "from": "worker-environment",
          "to": "llm-job",
          "phrase": "runs",
          "category": "enables",
          "description": "The worker environment enables execution of long-running LLM jobs that process Slack messages, call LLMs, and post results back to Slack."
        },
        {
          "id": "rel-worker-env-runs-test-execution-jobs",
          "from": "worker-environment",
          "to": "test-execution-job",
          "phrase": "runs",
          "category": "enables",
          "description": "The worker environment enables execution of test execution jobs that process individual test executions in parallel batches using the shared runtime."
        },
        {
          "id": "rel-worker-env-consumes-tasks",
          "from": "worker-environment",
          "to": "task-payload",
          "phrase": "consumes",
          "category": "uses",
          "description": "The worker environment consumes task payloads (such as TaskPayload and TestExecutionTaskPayload) that describe work to be performed."
        },
        {
          "id": "rel-worker-env-uses-shared-runtime",
          "from": "worker-environment",
          "to": "shared-runtime",
          "phrase": "uses",
          "category": "uses",
          "description": "The worker environment uses shared runtime functions (such as executeTest and other utilities from @gcp-data-request/shared-runtime) to perform LLM-related operations and test executions."
        },
        {
          "id": "rel-worker-env-uses-llm-provider",
          "from": "worker-environment",
          "to": "llm-provider",
          "phrase": "uses",
          "category": "uses",
          "description": "The worker environment uses an LLM provider (e.g., via getGenerativeModel) to execute language model calls as part of jobs."
        },
        {
          "id": "rel-worker-env-uses-firestore-db",
          "from": "worker-environment",
          "to": "database",
          "phrase": "uses",
          "category": "uses",
          "description": "The worker environment uses a Firestore database connection to read and write domain data such as test batches, prompt templates, test cases, and Slack threads."
        },
        {
          "id": "rel-worker-env-interacts-with-slack-threads",
          "from": "worker-environment",
          "to": "slack-thread",
          "phrase": "interacts with",
          "category": "uses",
          "description": "The worker environment interacts with Slack threads by fetching messages, posting messages and blocks, and adding or removing reactions."
        },
        {
          "id": "rel-worker-env-updates-test-batches",
          "from": "worker-environment",
          "to": "test-batch",
          "phrase": "checks and updates",
          "category": "uses",
          "description": "The worker environment checks the status of test batches and may update related data when executing test execution jobs."
        },
        {
          "id": "rel-worker-env-reads-test-cases",
          "from": "worker-environment",
          "to": "test-case",
          "phrase": "reads",
          "category": "uses",
          "description": "The worker environment reads test case data, including input variables, from the database to execute tests."
        },
        {
          "id": "rel-worker-env-reads-prompt-templates",
          "from": "worker-environment",
          "to": "prompt-template",
          "phrase": "reads",
          "category": "uses",
          "description": "The worker environment reads prompt templates from the database as part of executing test cases."
        },
        {
          "id": "rel-worker-env-updates-thread-metadata",
          "from": "worker-environment",
          "to": "thread-metadata",
          "phrase": "updates",
          "category": "uses",
          "description": "The worker environment updates metadata for Slack threads (such as reacted, greeted, updatedAt) in the database when processing LLM jobs."
        },
        {
          "id": "rel-worker-env-determines-data-requests",
          "from": "worker-environment",
          "to": "data-request",
          "phrase": "classifies and processes",
          "category": "uses",
          "description": "The worker environment uses helper functions like isDataRequest, iterateDataRequest, and reviewDataRequest to classify and process Slack messages as data requests."
        },
        {
          "id": "rel-env-config-uses-process-env",
          "from": "environment-configuration",
          "to": "os-process-environment",
          "phrase": "is read from",
          "category": "represents",
          "description": "Environment configuration is represented by key–value pairs stored in the OS process environment (process.env)."
        },
        {
          "id": "rel-env-config-enables-worker",
          "from": "environment-configuration",
          "to": "worker-application",
          "phrase": "enables",
          "category": "enables",
          "description": "Environment configuration enables the worker application to operate by providing its Slack bot token, Google Cloud project ID, and region."
        },
        {
          "id": "rel-env-config-enables-ingest",
          "from": "environment-configuration",
          "to": "ingest-application",
          "phrase": "enables",
          "category": "enables",
          "description": "Environment configuration enables the ingest application to operate by providing its Slack signing secret, Google Cloud project ID, task queue name, and region."
        },
        {
          "id": "rel-env-config-enables-shared-runtime",
          "from": "environment-configuration",
          "to": "shared-runtime",
          "phrase": "is enforced by",
          "category": "enables",
          "description": "The shared runtime uses helper functions (requireEnv, optionalEnv) to enforce and access environment configuration values required by various parts of the system."
        },
        {
          "id": "rel-env-config-enables-external-services",
          "from": "environment-configuration",
          "to": "external-services",
          "phrase": "configures access to",
          "category": "enables",
          "description": "Environment configuration configures access to external services such as Slack and Google Cloud by supplying tokens, signing secrets, project IDs, and regions."
        },
        {
          "id": "rel-env-config-part-of-infrastructure",
          "from": "environment-configuration",
          "to": "infrastructure",
          "phrase": "is part of",
          "category": "part_of",
          "description": "Environment configuration is part of the overall infrastructure setup required for the Slack-based data request and LLM evaluation system to run."
        },
        {
          "id": "rel-env-config-used-by-tasks",
          "from": "environment-configuration",
          "to": "task-queue",
          "phrase": "names",
          "category": "uses",
          "description": "Environment configuration provides the task queue name used by the ingest application to enqueue work."
        },
        {
          "id": "rel-auth-session-uses-firebase-auth",
          "from": "authentication-session",
          "to": "firebase-auth-service",
          "phrase": "is managed by",
          "category": "uses",
          "description": "Each authentication session is managed through the Firebase Authentication service obtained via `getAuth(app)`."
        },
        {
          "id": "rel-auth-session-uses-google-provider",
          "from": "authentication-session",
          "to": "google-auth-provider",
          "phrase": "is established via",
          "category": "uses",
          "description": "An authentication session is typically established using the GoogleAuthProvider, representing Google sign-in as the identity provider."
        },
        {
          "id": "rel-auth-session-associated-with-firebase-app",
          "from": "authentication-session",
          "to": "firebase-app",
          "phrase": "is scoped to",
          "category": "part_of",
          "description": "An authentication session is scoped to a specific initialized Firebase app instance created with the project configuration."
        },
        {
          "id": "rel-auth-session-enables-firestore-access",
          "from": "authentication-session",
          "to": "firestore-database",
          "phrase": "enables access to",
          "category": "enables",
          "description": "An active authentication session enables the authenticated user to access Firestore data according to security rules tied to their identity."
        },
        {
          "id": "rel-auth-session-enables-cloud-functions-access",
          "from": "authentication-session",
          "to": "cloud-functions-backend",
          "phrase": "enables authenticated calls to",
          "category": "enables",
          "description": "An authentication session enables the client to invoke Cloud Functions as an authenticated user, whether against the deployed backend or the local emulator."
        },
        {
          "id": "rel-auth-session-enables-evaluation-ui-usage",
          "from": "authentication-session",
          "to": "evaluation-ui",
          "phrase": "enables use of",
          "category": "enables",
          "description": "An authentication session enables a user to access and interact with the evaluation UI as an authenticated participant."
        },
        {
          "id": "rel-auth-session-identifies-user",
          "from": "authentication-session",
          "to": "user",
          "phrase": "identifies",
          "category": "represents",
          "description": "An authentication session represents the authenticated identity of a specific user while they are using the evaluation UI."
        },
        {
          "id": "rel-app-error-has-severity",
          "from": "application-error",
          "to": "error-severity",
          "phrase": "has",
          "category": "part_of",
          "description": "Each application error is assigned an error severity indicating how serious the failure is (low, medium, high, critical)."
        },
        {
          "id": "rel-app-error-used-in-operation-result",
          "from": "application-error",
          "to": "operation-result",
          "phrase": "is contained in",
          "category": "part_of",
          "description": "An application error may be included in an operation result to describe why an operation failed."
        },
        {
          "id": "rel-operation-result-caused-by-app-error",
          "from": "operation-result",
          "to": "application-error",
          "phrase": "is failed because of",
          "category": "causes",
          "description": "A failed operation result references an application error that explains the cause of the failure."
        },
        {
          "id": "rel-app-error-logged-by-error-handler",
          "from": "application-error",
          "to": "error-handler",
          "phrase": "is logged by",
          "category": "uses",
          "description": "Application errors are processed and logged by the structured error handling service."
        },
        {
          "id": "rel-error-handler-represents-app-error",
          "from": "error-handler",
          "to": "application-error",
          "phrase": "processes",
          "category": "uses",
          "description": "The error handler consumes application errors to perform consistent logging and messaging."
        },
        {
          "id": "rel-firebase-error-converted-to-app-error",
          "from": "firebase-error",
          "to": "application-error",
          "phrase": "is converted into",
          "category": "represents",
          "description": "Raw Firebase errors are translated into structured application errors for consistent handling."
        },
        {
          "id": "rel-react-error-boundary-logs-application-error",
          "from": "react-error-boundary",
          "to": "application-error",
          "phrase": "logs as",
          "category": "uses",
          "description": "The React error boundary captures uncaught UI errors and logs them as structured application error events via the shared runtime."
        },
        {
          "id": "rel-app-error-includes-context",
          "from": "application-error",
          "to": "error-context",
          "phrase": "includes",
          "category": "part_of",
          "description": "An application error may include additional context data (such as component stack or operation details) to aid debugging."
        },
        {
          "id": "rel-app-error-has-recoverability",
          "from": "application-error",
          "to": "recoverability-flag",
          "phrase": "has",
          "category": "part_of",
          "description": "Each application error indicates whether the failed operation can be retried or recovered from."
        },
        {
          "id": "rel-logging-uses-request-context",
          "from": "logging",
          "to": "request",
          "phrase": "uses contextual fields from",
          "category": "uses",
          "description": "Logging can include request-related contextual fields (such as identifiers or metadata) by merging them into the structured log record via helpers like `withRequest`."
        },
        {
          "id": "rel-logging-part-of-shared-runtime",
          "from": "logging",
          "to": "shared-runtime",
          "phrase": "is part of",
          "category": "part_of",
          "description": "Logging is a shared capability provided in the shared runtime layer (`shared-types`) and is used by multiple services in the system."
        },
        {
          "id": "rel-logging-records-operations",
          "from": "logging",
          "to": "operation",
          "phrase": "records information about",
          "category": "represents",
          "description": "Logging records informational and error messages that describe the behavior and outcomes of operations performed by the system."
        },
        {
          "id": "rel-logging-records-errors",
          "from": "logging",
          "to": "error",
          "phrase": "records",
          "category": "represents",
          "description": "Error-level logging captures information about errors that occur during handling of requests or execution of operations."
        },
        {
          "id": "rel-task-queue-uses-location",
          "from": "task-queue",
          "to": "tasks-location",
          "phrase": "is defined in",
          "category": "part_of",
          "description": "A task queue exists in a specific Cloud Tasks location (region), such as 'us-central1'."
        },
        {
          "id": "rel-task-queue-uses-service-account",
          "from": "task-queue",
          "to": "tasks-service-account",
          "phrase": "uses",
          "category": "uses",
          "description": "A task queue uses a designated service account to obtain OIDC tokens for authenticated calls from queued tasks to the worker service."
        },
        {
          "id": "rel-task-queue-targets-worker",
          "from": "task-queue",
          "to": "worker-service",
          "phrase": "delivers tasks to",
          "category": "enables",
          "description": "The task queue delivers scheduled background tasks to the worker Cloud Run service identified by the worker URL."
        }
      ],
      "rules": [
        {
          "id": "rule-background-task-requires-queue-config",
          "title": "Background task requires queue configuration",
          "text": "A background task can only be enqueued if the worker URL, project ID, region, and task queue name are all configured; otherwise, task creation fails.",
          "kind": "constraint",
          "conceptIds": [
            "background-task"
          ]
        },
        {
          "id": "rule-test-execution-task-requires-identifiers",
          "title": "Test execution background task requires identifiers",
          "text": "A background task representing a test execution must include a templateId, inputVariables, and testCaseId in the request that leads to its creation; missing any of these prevents task creation.",
          "kind": "constraint",
          "conceptIds": [
            "background-task"
          ]
        },
        {
          "id": "rule-test-execution-task-belongs-to-batch",
          "title": "Test execution background task must belong to a batch",
          "text": "Every background task that executes a test case must be associated with a batchId, ensuring that all test executions are part of a batch.",
          "kind": "invariant",
          "conceptIds": [
            "background-task"
          ]
        },
        {
          "id": "rule-background-task-authenticated-user-for-tests",
          "title": "Background test execution task requires authenticated user",
          "text": "A background task for executing tests is only created if the caller is an authenticated user; unauthenticated requests are rejected.",
          "kind": "policy",
          "conceptIds": [
            "background-task"
          ]
        },
        {
          "id": "rule-test-batch-lifecycle-progress-bounds",
          "title": "Batch progress is bounded by total test cases",
          "text": "For a test batch, the completedCount used to compute progress must not exceed totalTestCases, and if totalTestCases is zero, the computed progress percentage is treated as 0%.",
          "kind": "constraint",
          "conceptIds": [
            "test-batch-lifecycle"
          ]
        },
        {
          "id": "rule-test-batch-lifecycle-cancellable-only-when-running",
          "title": "Only running batches can be cancelled",
          "text": "A test batch can only be cancelled while its status is running; once it is completed, cancelled, or failed, cancellation is no longer available.",
          "kind": "policy",
          "conceptIds": [
            "test-batch-lifecycle"
          ]
        },
        {
          "id": "rule-test-batch-lifecycle-requires-authenticated-user",
          "title": "Executing a test batch requires authentication",
          "text": "Creation and execution of a test batch via the executeTest operation requires an authenticated user.",
          "kind": "policy",
          "conceptIds": [
            "test-batch-lifecycle"
          ]
        },
        {
          "id": "rule-firestore-ignore-undefined",
          "title": "Firestore ignores undefined properties",
          "text": "When server-side applications obtain a Firestore handle, it is configured to ignore undefined properties in stored documents, ensuring that undefined fields are not persisted.",
          "kind": "assumption",
          "conceptIds": [
            "firestore-database"
          ]
        },
        {
          "id": "rule-debug-event-id-format",
          "title": "Debug event document ID format",
          "text": "Each debug event stored in Firestore must use a document ID composed of the event type, an underscore, and the event timestamp (e.g., 'error_occurred_2024-01-01T00:00:00.000Z').",
          "kind": "invariant",
          "conceptIds": [
            "firestore-database"
          ]
        },
        {
          "id": "rule-debug-events-under-thread",
          "title": "Debug events are stored under their root thread",
          "text": "Each debug event must be stored in the 'debugEvents' subcollection of the thread document identified by the root timestamp or thread identifier.",
          "kind": "invariant",
          "conceptIds": [
            "firestore-database"
          ]
        },
        {
          "id": "rule-debug-event-subcollection-optional",
          "title": "Debug event recording is best-effort",
          "text": "If the Firestore-like implementation does not support subcollections or if writing a debug event fails, the system logs the error but does not fail the main operation.",
          "kind": "policy",
          "conceptIds": [
            "firestore-database"
          ]
        },
        {
          "id": "rule-single-project-id",
          "title": "Single Firestore project for the system",
          "text": "All applications in the system (worker, ingest, evals) are expected to connect to the same logical Firestore project, ensuring a shared persistent store for threads, debug events, and related artifacts.",
          "kind": "assumption",
          "conceptIds": [
            "firestore-database"
          ]
        },
        {
          "id": "rule-cloud-functions-auth-required-for-execute-test",
          "title": "Authenticated user required to execute tests",
          "text": "The Cloud Functions environment must reject any `executeTest` call that does not include an authenticated user context.",
          "kind": "policy",
          "conceptIds": [
            "cloud-functions-environment"
          ]
        },
        {
          "id": "rule-cloud-functions-execute-test-required-arguments",
          "title": "ExecuteTest requires template and test identifiers",
          "text": "The Cloud Functions environment must reject an `executeTest` call unless `templateId`, `inputVariables`, and `testCaseId` are all provided in the request data.",
          "kind": "constraint",
          "conceptIds": [
            "cloud-functions-environment"
          ]
        },
        {
          "id": "rule-cloud-functions-default-llm-model",
          "title": "Default LLM model for prompt execution",
          "text": "When executing an LLM prompt without an explicit model name, the Cloud Functions environment must default the model name to `gemini-2.5-flash`.",
          "kind": "assumption",
          "conceptIds": [
            "cloud-functions-environment"
          ]
        },
        {
          "id": "rule-cloud-functions-records-llm-debug-events-when-context-provided",
          "title": "LLM debug events recorded when debug context is available",
          "text": "When executing an LLM prompt and a debug context is provided, the Cloud Functions environment must record an LLM request debug event in Firestore before sending the prompt to the model.",
          "kind": "invariant",
          "conceptIds": [
            "cloud-functions-environment"
          ]
        },
        {
          "id": "rule-worker-env-requires-slack-token",
          "title": "Worker environment should have a Slack bot token configured",
          "text": "The worker environment is expected to have a valid Slack bot token available via configuration so that it can authenticate to Slack and perform required operations. If the token is missing or empty, Slack interactions may fail.",
          "kind": "assumption",
          "conceptIds": [
            "worker-environment"
          ]
        },
        {
          "id": "rule-worker-env-requires-project-id",
          "title": "Worker environment should have a cloud project ID configured",
          "text": "The worker environment is expected to have a Google Cloud project ID configured so that it can connect to the correct cloud resources, including the database and LLM services.",
          "kind": "assumption",
          "conceptIds": [
            "worker-environment"
          ]
        },
        {
          "id": "rule-worker-env-requires-region",
          "title": "Worker environment should have a cloud region configured",
          "text": "The worker environment is expected to have a cloud region configured to determine where its cloud resources are hosted and to route LLM and database calls appropriately.",
          "kind": "assumption",
          "conceptIds": [
            "worker-environment"
          ]
        },
        {
          "id": "rule-worker-env-checks-batch-status-before-test",
          "title": "Worker environment must check test batch status before executing a test",
          "text": "Before executing a test execution job, the worker environment must verify that the associated test batch exists and is not cancelled. If the batch does not exist or is cancelled, the test execution is skipped.",
          "kind": "invariant",
          "conceptIds": [
            "worker-environment"
          ]
        },
        {
          "id": "rule-worker-env-requires-test-case-input-variables",
          "title": "Worker environment requires input variables to execute a test case",
          "text": "When executing a test case, the worker environment must ensure that the test case exists and has defined inputVariables. If inputVariables are missing, the test execution fails with an error.",
          "kind": "constraint",
          "conceptIds": [
            "worker-environment"
          ]
        },
        {
          "id": "rule-worker-env-requires-slack-channel-and-rootTs",
          "title": "Worker environment requires Slack channel and root timestamp to run an LLM job",
          "text": "To process an LLM job for a Slack thread, the worker environment requires both a Slack channel and a rootTs (root message timestamp). If either is missing, the LLM job is not executed.",
          "kind": "constraint",
          "conceptIds": [
            "worker-environment"
          ]
        },
        {
          "id": "rule-worker-env-updates-thread-timestamps",
          "title": "Worker environment updates thread metadata timestamps",
          "text": "When processing an LLM job for a Slack thread, the worker environment must update the thread document's updatedAt field to reflect the time of the latest processing.",
          "kind": "invariant",
          "conceptIds": [
            "worker-environment"
          ]
        },
        {
          "id": "rule-env-required-missing-error",
          "title": "Missing required environment variable causes failure",
          "text": "If a required environment variable is not set, the system must fail fast by throwing an error rather than running with an undefined or unsafe configuration.",
          "kind": "invariant",
          "conceptIds": [
            "environment-configuration"
          ]
        },
        {
          "id": "rule-env-shared-runtime-requireenv",
          "title": "Shared runtime must use requireEnv for mandatory values",
          "text": "When a configuration value is mandatory for correct operation, the shared runtime must access it via a mechanism equivalent to requireEnv so that absence of the variable is detected immediately.",
          "kind": "policy",
          "conceptIds": [
            "environment-configuration"
          ]
        },
        {
          "id": "rule-env-fallbacks-allowed-for-optional",
          "title": "Optional environment variables may have fallbacks",
          "text": "Optional environment variables may be read with a fallback value, allowing the system to operate with defaults when those variables are not explicitly set.",
          "kind": "assumption",
          "conceptIds": [
            "environment-configuration"
          ]
        },
        {
          "id": "rule-env-worker-core-vars",
          "title": "Worker requires Slack bot token, project ID, and region",
          "text": "The worker application requires environment configuration values for the Slack bot token, Google Cloud project ID, and region in order to function correctly.",
          "kind": "constraint",
          "conceptIds": [
            "environment-configuration"
          ]
        },
        {
          "id": "rule-env-ingest-core-vars",
          "title": "Ingest requires Slack signing secret, project ID, queue, and region",
          "text": "The ingest application requires environment configuration values for the Slack signing secret, Google Cloud project ID, task queue name, and region in order to function correctly.",
          "kind": "constraint",
          "conceptIds": [
            "environment-configuration"
          ]
        },
        {
          "id": "rule-auth-session-requires-firebase-app",
          "title": "Authentication session requires initialized Firebase app",
          "text": "An authentication session can only exist in the context of an initialized Firebase app configured with the project’s Firebase settings.",
          "kind": "constraint",
          "conceptIds": [
            "authentication-session"
          ]
        },
        {
          "id": "rule-auth-session-uses-google-provider",
          "title": "Authentication session is typically created via Google sign-in",
          "text": "In this system, authentication sessions for the evaluation UI are typically created using Google sign-in through the GoogleAuthProvider.",
          "kind": "assumption",
          "conceptIds": [
            "authentication-session"
          ]
        },
        {
          "id": "rule-auth-session-required-for-protected-backend",
          "title": "Authentication session required for authenticated backend access",
          "text": "To access protected Firestore data or invoke authenticated Cloud Functions from the evaluation UI, a user must have an active authentication session.",
          "kind": "policy",
          "conceptIds": [
            "authentication-session"
          ]
        },
        {
          "id": "rule-app-error-must-have-code-message-severity-recoverable",
          "title": "Application error must define core attributes",
          "text": "Every application error must have a machine-readable code, a user-friendly message, a severity level, and a recoverable flag.",
          "kind": "invariant",
          "conceptIds": [
            "application-error"
          ]
        },
        {
          "id": "rule-app-error-severity-drives-logging-level",
          "title": "Error severity determines logging level",
          "text": "The severity of an application error determines how it is logged: critical and high severities are logged as errors, medium as warnings, and low as informational messages.",
          "kind": "policy",
          "conceptIds": [
            "application-error"
          ]
        },
        {
          "id": "rule-app-error-message-user-friendly",
          "title": "Application error message is user-friendly",
          "text": "The message field of an application error is intended to be understandable by end users, while technical details are placed in a separate technical field.",
          "kind": "assumption",
          "conceptIds": [
            "application-error"
          ]
        },
        {
          "id": "rule-firebase-error-mapped-to-app-error",
          "title": "Firebase errors are mapped to structured application errors",
          "text": "When an operation fails due to a Firebase error, the Firebase error code is mapped to a user-friendly message and recoverability flag in a structured application error.",
          "kind": "policy",
          "conceptIds": [
            "application-error"
          ]
        },
        {
          "id": "rule-operation-result-error-exclusive-with-success",
          "title": "Operation result error implies failure",
          "text": "If an operation result contains an application error, the success flag of that operation result must be false.",
          "kind": "constraint",
          "conceptIds": [
            "application-error"
          ]
        },
        {
          "id": "rule-logging-structured-json",
          "title": "Logs are structured JSON records",
          "text": "Each log entry must be emitted as a JSON object containing at least a `level` and `message` field, with optional additional fields for context.",
          "kind": "invariant",
          "conceptIds": [
            "logging"
          ]
        },
        {
          "id": "rule-logging-levels-info-error",
          "title": "Supported log levels are info and error",
          "text": "Logging distinguishes at least two levels of log entries: `info` for informational messages and `error` for error conditions.",
          "kind": "assumption",
          "conceptIds": [
            "logging"
          ]
        },
        {
          "id": "rule-logging-context-merge",
          "title": "Request context can be merged into log fields",
          "text": "When logging request-related events, request context fields may be merged with additional fields to form a single structured log record.",
          "kind": "policy",
          "conceptIds": [
            "logging"
          ]
        },
        {
          "id": "rule-task-queue-must-have-name",
          "title": "Task queue must have a name",
          "text": "Each task queue must be identified by a non-empty queue name (e.g., 'requests').",
          "kind": "constraint",
          "conceptIds": [
            "task-queue"
          ]
        },
        {
          "id": "rule-task-queue-must-have-location",
          "title": "Task queue must have a location",
          "text": "Each task queue must be associated with a Cloud Tasks location (region), such as 'us-central1'.",
          "kind": "constraint",
          "conceptIds": [
            "task-queue"
          ]
        },
        {
          "id": "rule-task-queue-must-have-service-account",
          "title": "Task queue must specify a service account for task execution",
          "text": "Each task queue must reference a service account that will be used to obtain OIDC tokens for tasks executed against the worker service.",
          "kind": "policy",
          "conceptIds": [
            "task-queue"
          ]
        }
      ],
      "lifecycles": [
        {
          "id": "lifecycle-background-task-basic",
          "subjectConceptId": "background-task",
          "stateConceptIds": [
            "background-task-pending",
            "background-task-executing",
            "background-task-completed",
            "background-task-failed"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "background-task-pending",
          "terminalStateIds": [
            "background-task-completed",
            "background-task-failed"
          ]
        },
        {
          "id": "lifecycle-test-batch-status",
          "subjectConceptId": "test-batch-lifecycle",
          "stateConceptIds": [
            "test-batch-status-running",
            "test-batch-status-completed",
            "test-batch-status-cancelled",
            "test-batch-status-failed"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "test-batch-status-running",
          "terminalStateIds": [
            "test-batch-status-completed",
            "test-batch-status-cancelled",
            "test-batch-status-failed"
          ]
        },
        {
          "id": "lifecycle-env-config-validity",
          "subjectConceptId": "environment-configuration",
          "stateConceptIds": [
            "env-missing-required-values",
            "env-complete-and-valid"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "env-missing-required-values",
          "terminalStateIds": [
            "env-complete-and-valid"
          ]
        },
        {
          "id": "lifecycle-auth-session-basic",
          "subjectConceptId": "authentication-session",
          "stateConceptIds": [
            "auth-session-absent",
            "auth-session-active"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "auth-session-absent",
          "terminalStateIds": [
            "auth-session-absent"
          ]
        }
      ],
      "views": [
        {
          "id": "background-tasks-and-workers",
          "name": "Background tasks and worker processing",
          "kind": "overview",
          "description": "Shows how background tasks are created, parameterized, and executed by workers as part of test batches.",
          "conceptIds": [
            "background-task",
            "task-payload",
            "test-execution-task-payload",
            "worker-processing",
            "test-batch",
            "slack-event",
            "test-execution-request",
            "user"
          ],
          "relationshipIds": [
            "rel-background-task-uses-task-payload",
            "rel-background-task-uses-test-execution-task-payload",
            "rel-background-task-precedes-worker-processing",
            "rel-background-task-part-of-test-batch",
            "rel-background-task-uses-prompt-template",
            "rel-background-task-originates-from-slack-event",
            "rel-background-task-originates-from-test-execution-request",
            "rel-background-task-associated-with-user"
          ]
        },
        {
          "id": "test-batch-lifecycle",
          "name": "Test batch lifecycle and execution",
          "kind": "lifecycle",
          "description": "Focuses on how a test batch progresses through its lifecycle, spawns execution tasks, and can be cancelled.",
          "conceptIds": [
            "test-batch-lifecycle",
            "test-batch",
            "test-execution-task",
            "batch-cancellation",
            "worker-environment",
            "test-execution-job"
          ],
          "relationshipIds": [
            "rel-test-batch-lifecycle-uses-test-batch",
            "rel-test-batch-lifecycle-precedes-test-execution",
            "rel-test-batch-lifecycle-enables-batch-cancellation",
            "rel-worker-env-runs-test-execution-jobs",
            "rel-worker-env-updates-test-batches"
          ]
        },
        {
          "id": "cloud-functions-and-task-queue",
          "name": "Cloud Functions routing and task queue",
          "kind": "implementation",
          "description": "Shows how the Cloud Functions environment routes work to workers via Cloud Tasks and interacts with Firestore.",
          "conceptIds": [
            "cloud-functions-environment",
            "worker-cloud-run-service",
            "cloud-tasks-queue",
            "tasks-service-account",
            "firestore-database",
            "test-batch",
            "llm-execution",
            "llm-debug-event"
          ],
          "relationshipIds": [
            "rel-cloud-functions-uses-worker-url",
            "rel-cloud-functions-uses-cloud-tasks-queue",
            "rel-cloud-functions-uses-tasks-service-account",
            "rel-cloud-functions-uses-firestore",
            "rel-cloud-functions-exposes-echo-endpoint",
            "rel-cloud-functions-exposes-execute-test-endpoint",
            "rel-cloud-functions-uses-llm-execution",
            "rel-cloud-functions-records-debug-events",
            "rel-cloud-functions-fetches-active-template",
            "rel-cloud-functions-creates-test-batch"
          ]
        },
        {
          "id": "worker-runtime-and-slack-integration",
          "name": "Worker environment and Slack / LLM integration",
          "kind": "implementation",
          "description": "Details how the worker environment is configured and how it consumes tasks, runs LLM jobs, and interacts with Slack and Firestore.",
          "conceptIds": [
            "worker-environment",
            "slack-bot-token",
            "cloud-project-id",
            "cloud-region",
            "task-payload",
            "llm-job",
            "llm-provider",
            "slack-thread"
          ],
          "relationshipIds": [
            "rel-worker-env-uses-slack-token",
            "rel-worker-env-uses-cloud-project",
            "rel-worker-env-uses-region",
            "rel-worker-env-consumes-tasks",
            "rel-worker-env-runs-llm-jobs",
            "rel-worker-env-uses-llm-provider",
            "rel-worker-env-interacts-with-slack-threads",
            "rel-worker-env-uses-firestore-db"
          ]
        },
        {
          "id": "firestore-and-app-surfaces",
          "name": "Firestore and connected applications",
          "kind": "datastore",
          "description": "Shows Firestore as the central datastore and how worker, ingest, evals apps and auth system interact with it, including threads and debug events.",
          "conceptIds": [
            "firestore-database",
            "thread",
            "debug-event",
            "worker-app",
            "ingest-app",
            "evals-app",
            "auth-system",
            "shared-runtime"
          ],
          "relationshipIds": [
            "rel-firestore-threads",
            "rel-firestore-debug-events",
            "rel-thread-has-debug-events",
            "rel-firestore-worker-app",
            "rel-firestore-ingest-app",
            "rel-firestore-evals-app",
            "rel-firestore-auth",
            "rel-firestore-shared-runtime"
          ]
        },
        {
          "id": "environment-config-and-auth-session",
          "name": "Environment configuration and authentication session",
          "kind": "overview",
          "description": "Explains how environment configuration enables applications and shared runtime, and how authentication sessions gate access to backend services.",
          "conceptIds": [
            "environment-configuration",
            "os-process-environment",
            "worker-application",
            "ingest-application",
            "shared-runtime",
            "external-services",
            "authentication-session",
            "firestore-database"
          ],
          "relationshipIds": [
            "rel-env-config-uses-process-env",
            "rel-env-config-enables-worker",
            "rel-env-config-enables-ingest",
            "rel-env-config-enables-shared-runtime",
            "rel-env-config-enables-external-services",
            "rel-env-config-part-of-infrastructure",
            "rel-auth-session-uses-firebase-auth",
            "rel-auth-session-uses-google-provider",
            "rel-auth-session-enables-firestore-access",
            "rel-auth-session-identifies-user"
          ]
        },
        {
          "id": "errors-and-logging-runtime",
          "name": "Application errors and shared logging runtime",
          "kind": "structure",
          "description": "Shows how application errors are structured, processed, and logged as part of the shared runtime.",
          "conceptIds": [
            "application-error",
            "error-severity",
            "error-context",
            "recoverability-flag",
            "operation-result",
            "error-handler",
            "firebase-error",
            "logging"
          ],
          "relationshipIds": [
            "rel-app-error-has-severity",
            "rel-app-error-includes-context",
            "rel-app-error-has-recoverability",
            "rel-app-error-used-in-operation-result",
            "rel-operation-result-caused-by-app-error",
            "rel-app-error-logged-by-error-handler",
            "rel-error-handler-represents-app-error",
            "rel-firebase-error-converted-to-app-error",
            "rel-logging-part-of-shared-runtime",
            "rel-logging-records-errors"
          ]
        }
      ],
      "storyViews": [
        {
          "id": "worker-processes-background-task-from-queue",
          "name": "Worker processes a background task from the task queue",
          "kind": "system_flow",
          "description": "A background task is scheduled into a task queue and then consumed by a worker environment, which uses shared runtime logging and Firestore to complete the work.",
          "tags": [
            "background-task",
            "worker",
            "task-queue",
            "logging"
          ],
          "focusConceptId": "background-task",
          "steps": [
            {
              "id": "task-created-and-enqueued",
              "index": 0,
              "title": "Background task is created and enqueued",
              "narrative": "A new background task is created to perform asynchronous work and is associated with a specific task queue configured for this type of job.",
              "conceptIds": [
                "background-task",
                "task-queue",
                "environment-configuration"
              ],
              "relationshipIds": [
                "rel-env-config-used-by-tasks",
                "rel-task-queue-uses-location",
                "rel-task-queue-uses-service-account"
              ],
              "primaryConceptIds": [
                "background-task",
                "task-queue"
              ],
              "primaryRelationshipIds": [
                "rel-env-config-used-by-tasks"
              ]
            },
            {
              "id": "worker-polls-queue",
              "index": 1,
              "title": "Worker environment polls the task queue",
              "narrative": "A worker environment process, started with the correct environment configuration, connects to the task queue and pulls a pending background task for execution.",
              "conceptIds": [
                "worker-environment",
                "task-queue",
                "environment-configuration"
              ],
              "relationshipIds": [
                "rel-env-config-enables-worker",
                "rel-worker-env-consumes-tasks",
                "rel-task-queue-targets-worker"
              ],
              "primaryConceptIds": [
                "worker-environment",
                "task-queue"
              ],
              "primaryRelationshipIds": [
                "rel-task-queue-targets-worker"
              ]
            },
            {
              "id": "worker-executes-task-logic",
              "index": 2,
              "title": "Worker executes task logic using shared runtime",
              "narrative": "The worker environment begins processing the background task, using the shared runtime’s logging facilities to record operations and any errors that occur.",
              "conceptIds": [
                "worker-environment",
                "background-task",
                "logging"
              ],
              "relationshipIds": [
                "rel-background-task-precedes-worker-processing",
                "rel-worker-env-uses-shared-runtime",
                "rel-logging-part-of-shared-runtime",
                "rel-logging-records-operations"
              ],
              "primaryConceptIds": [
                "background-task",
                "worker-environment"
              ],
              "primaryRelationshipIds": [
                "rel-background-task-precedes-worker-processing"
              ]
            },
            {
              "id": "worker-persists-results",
              "index": 3,
              "title": "Worker persists task results to Firestore",
              "narrative": "As the task completes, the worker environment writes any resulting artifacts or status updates to the Firestore database for later retrieval by other parts of the system.",
              "conceptIds": [
                "worker-environment",
                "firestore-database"
              ],
              "relationshipIds": [
                "rel-worker-env-uses-firestore-db",
                "rel-firestore-worker-app"
              ],
              "primaryConceptIds": [
                "worker-environment",
                "firestore-database"
              ],
              "primaryRelationshipIds": [
                "rel-firestore-worker-app"
              ]
            },
            {
              "id": "task-completion-logged",
              "index": 4,
              "title": "Task completion is logged",
              "narrative": "The shared runtime logging records the successful completion of the background task, including contextual information about the operation for observability.",
              "conceptIds": [
                "logging",
                "background-task"
              ],
              "relationshipIds": [
                "rel-logging-records-operations"
              ],
              "primaryConceptIds": [
                "logging"
              ],
              "primaryRelationshipIds": [
                "rel-logging-records-operations"
              ]
            }
          ]
        },
        {
          "id": "test-batch-executed-by-workers",
          "name": "Test batch lifecycle executed by workers",
          "kind": "system_flow",
          "description": "A test batch is created by the Cloud Functions environment, then individual test execution tasks are processed by workers and persisted to Firestore.",
          "tags": [
            "test-batch-lifecycle",
            "cloud-functions-environment",
            "worker-environment"
          ],
          "focusConceptId": "test-batch-lifecycle",
          "steps": [
            {
              "id": "cloud-functions-create-test-batch",
              "index": 0,
              "title": "Cloud Functions create a new test batch",
              "narrative": "The Cloud Functions environment receives a request to run evaluations and creates a new test batch record that will govern the lifecycle of multiple test executions.",
              "conceptIds": [
                "cloud-functions-environment",
                "test-batch-lifecycle",
                "firestore-database"
              ],
              "relationshipIds": [
                "rel-cloud-functions-creates-test-batch",
                "rel-test-batch-lifecycle-uses-test-batch",
                "rel-cloud-functions-uses-firestore"
              ],
              "primaryConceptIds": [
                "test-batch-lifecycle"
              ],
              "primaryRelationshipIds": [
                "rel-cloud-functions-creates-test-batch"
              ]
            },
            {
              "id": "batch-schedules-test-execution-tasks",
              "index": 1,
              "title": "Test batch lifecycle schedules execution tasks",
              "narrative": "Based on the test batch definition, the test batch lifecycle initiates a series of test execution tasks that will be run asynchronously by workers.",
              "conceptIds": [
                "test-batch-lifecycle",
                "background-task",
                "task-queue"
              ],
              "relationshipIds": [
                "rel-test-batch-lifecycle-precedes-test-execution",
                "rel-background-task-part-of-test-batch",
                "rel-env-config-used-by-tasks"
              ],
              "primaryConceptIds": [
                "test-batch-lifecycle",
                "background-task"
              ],
              "primaryRelationshipIds": [
                "rel-test-batch-lifecycle-precedes-test-execution"
              ]
            },
            {
              "id": "workers-consume-test-execution-tasks",
              "index": 2,
              "title": "Worker environments consume test execution tasks",
              "narrative": "Worker environments pull test-related background tasks from the task queue, using environment configuration to connect to the correct project and region.",
              "conceptIds": [
                "worker-environment",
                "background-task",
                "task-queue",
                "environment-configuration"
              ],
              "relationshipIds": [
                "rel-worker-env-consumes-tasks",
                "rel-task-queue-targets-worker",
                "rel-worker-env-uses-cloud-project",
                "rel-worker-env-uses-region"
              ],
              "primaryConceptIds": [
                "worker-environment"
              ],
              "primaryRelationshipIds": [
                "rel-worker-env-consumes-tasks"
              ]
            },
            {
              "id": "workers-read-test-definitions-and-templates",
              "index": 3,
              "title": "Workers read test cases and prompt templates",
              "narrative": "For each test execution, the worker environment reads the relevant test cases and prompt templates from Firestore to construct the LLM calls.",
              "conceptIds": [
                "worker-environment",
                "firestore-database"
              ],
              "relationshipIds": [
                "rel-worker-env-reads-test-cases",
                "rel-worker-env-reads-prompt-templates",
                "rel-firestore-worker-app"
              ],
              "primaryConceptIds": [
                "worker-environment",
                "firestore-database"
              ],
              "primaryRelationshipIds": [
                "rel-firestore-worker-app"
              ]
            },
            {
              "id": "workers-update-test-batch-status",
              "index": 4,
              "title": "Workers update test batch status in Firestore",
              "narrative": "As individual tests complete, the worker environment writes results and updates the overall test batch status in Firestore, allowing the lifecycle to reflect progress or completion.",
              "conceptIds": [
                "worker-environment",
                "test-batch-lifecycle",
                "firestore-database"
              ],
              "relationshipIds": [
                "rel-worker-env-updates-test-batches",
                "rel-test-batch-lifecycle-uses-test-batch",
                "rel-firestore-worker-app"
              ],
              "primaryConceptIds": [
                "worker-environment",
                "test-batch-lifecycle"
              ],
              "primaryRelationshipIds": [
                "rel-worker-env-updates-test-batches"
              ]
            }
          ]
        },
        {
          "id": "evaluation-ui-authenticated-access-to-backend",
          "name": "Authenticated user accesses evaluation UI and backend",
          "kind": "user_flow",
          "description": "A user signs in via Google, establishing an authentication session that enables secure access to Firestore and Cloud Functions for evaluation tasks.",
          "tags": [
            "authentication-session",
            "evaluation-ui",
            "firestore-database"
          ],
          "focusConceptId": "authentication-session",
          "steps": [
            {
              "id": "user-initiates-google-sign-in",
              "index": 0,
              "title": "User initiates Google sign-in",
              "narrative": "A user opens the evaluation UI and starts the Google sign-in flow, which is handled by Firebase Auth using the Google provider.",
              "conceptIds": [
                "authentication-session"
              ],
              "relationshipIds": [
                "rel-auth-session-uses-firebase-auth",
                "rel-auth-session-uses-google-provider",
                "rel-auth-session-associated-with-firebase-app"
              ],
              "primaryConceptIds": [
                "authentication-session"
              ],
              "primaryRelationshipIds": [
                "rel-auth-session-uses-google-provider"
              ]
            },
            {
              "id": "auth-session-established",
              "index": 1,
              "title": "Authentication session is established",
              "narrative": "Upon successful sign-in, an authentication session is created that identifies the user and is scoped to the Firebase app used by the evaluation UI.",
              "conceptIds": [
                "authentication-session"
              ],
              "relationshipIds": [
                "rel-auth-session-identifies-user",
                "rel-auth-session-associated-with-firebase-app"
              ],
              "primaryConceptIds": [
                "authentication-session"
              ],
              "primaryRelationshipIds": [
                "rel-auth-session-identifies-user"
              ]
            },
            {
              "id": "auth-session-enables-ui-and-firestore",
              "index": 2,
              "title": "Authentication session enables UI and Firestore access",
              "narrative": "The active authentication session allows the user to interact with the evaluation UI and securely read or write evaluation data in Firestore.",
              "conceptIds": [
                "authentication-session",
                "firestore-database"
              ],
              "relationshipIds": [
                "rel-auth-session-enables-evaluation-ui-usage",
                "rel-auth-session-enables-firestore-access"
              ],
              "primaryConceptIds": [
                "authentication-session"
              ],
              "primaryRelationshipIds": [
                "rel-auth-session-enables-firestore-access"
              ]
            },
            {
              "id": "auth-session-enables-cloud-functions",
              "index": 3,
              "title": "Authentication session enables Cloud Functions calls",
              "narrative": "When the user triggers evaluations or test runs from the UI, the authentication session is used to make authenticated calls to the Cloud Functions backend.",
              "conceptIds": [
                "authentication-session"
              ],
              "relationshipIds": [
                "rel-auth-session-enables-cloud-functions-access"
              ],
              "primaryConceptIds": [
                "authentication-session"
              ],
              "primaryRelationshipIds": [
                "rel-auth-session-enables-cloud-functions-access"
              ]
            }
          ]
        },
        {
          "id": "shared-runtime-logs-operations-and-errors",
          "name": "Shared runtime logs operations and handles application errors",
          "kind": "error_flow",
          "description": "A worker operation uses shared runtime logging; when an error occurs, it is converted into an application error, logged, and attached to an operation result.",
          "tags": [
            "logging",
            "application-error",
            "shared-runtime"
          ],
          "focusConceptId": "application-error",
          "steps": [
            {
              "id": "operation-starts-with-logging-context",
              "index": 0,
              "title": "Operation starts with logging context",
              "narrative": "A background operation begins in the worker environment, and the shared runtime initializes logging with request context so that subsequent actions are traceable.",
              "conceptIds": [
                "worker-environment",
                "logging"
              ],
              "relationshipIds": [
                "rel-worker-env-uses-shared-runtime",
                "rel-logging-part-of-shared-runtime",
                "rel-logging-uses-request-context"
              ],
              "primaryConceptIds": [
                "logging"
              ],
              "primaryRelationshipIds": [
                "rel-logging-part-of-shared-runtime"
              ]
            },
            {
              "id": "operation-encounters-error",
              "index": 1,
              "title": "Operation encounters an error",
              "narrative": "During the operation, a lower-level error (for example from Firebase) occurs and is converted into a structured application error with severity and context.",
              "conceptIds": [
                "application-error"
              ],
              "relationshipIds": [
                "rel-firebase-error-converted-to-app-error",
                "rel-app-error-has-severity",
                "rel-app-error-includes-context",
                "rel-app-error-has-recoverability"
              ],
              "primaryConceptIds": [
                "application-error"
              ],
              "primaryRelationshipIds": [
                "rel-firebase-error-converted-to-app-error"
              ]
            },
            {
              "id": "error-logged-by-shared-runtime",
              "index": 2,
              "title": "Application error is logged by shared runtime",
              "narrative": "The shared runtime’s error handler processes the application error and records it via the logging system for later debugging and monitoring.",
              "conceptIds": [
                "application-error",
                "logging"
              ],
              "relationshipIds": [
                "rel-app-error-logged-by-error-handler",
                "rel-error-handler-represents-app-error",
                "rel-logging-records-errors"
              ],
              "primaryConceptIds": [
                "application-error"
              ],
              "primaryRelationshipIds": [
                "rel-logging-records-errors"
              ]
            },
            {
              "id": "operation-result-marked-failed",
              "index": 3,
              "title": "Operation result is marked as failed",
              "narrative": "The operation result is constructed to include the application error, indicating that the operation failed due to this specific issue.",
              "conceptIds": [
                "application-error"
              ],
              "relationshipIds": [
                "rel-app-error-used-in-operation-result",
                "rel-operation-result-caused-by-app-error"
              ],
              "primaryConceptIds": [
                "application-error"
              ],
              "primaryRelationshipIds": [
                "rel-operation-result-caused-by-app-error"
              ]
            }
          ]
        },
        {
          "id": "environment-configuration-enables-infrastructure",
          "name": "Environment configuration enables shared infrastructure",
          "kind": "admin_flow",
          "description": "An administrator configures environment variables that are read by the applications, enabling workers, ingest, shared runtime, and external services to function correctly.",
          "tags": [
            "environment-configuration",
            "infrastructure"
          ],
          "focusConceptId": "environment-configuration",
          "steps": [
            {
              "id": "admin-sets-process-environment",
              "index": 0,
              "title": "Admin sets OS process environment variables",
              "narrative": "An administrator configures environment variables such as project IDs, regions, and API keys in the OS process environment for the deployment.",
              "conceptIds": [
                "environment-configuration"
              ],
              "relationshipIds": [
                "rel-env-config-uses-process-env"
              ],
              "primaryConceptIds": [
                "environment-configuration"
              ],
              "primaryRelationshipIds": [
                "rel-env-config-uses-process-env"
              ]
            },
            {
              "id": "env-config-enables-core-apps",
              "index": 1,
              "title": "Environment configuration enables core applications",
              "narrative": "The worker and ingest applications read the environment configuration at startup, allowing them to connect to the correct infrastructure and services.",
              "conceptIds": [
                "environment-configuration"
              ],
              "relationshipIds": [
                "rel-env-config-enables-worker",
                "rel-env-config-enables-ingest"
              ],
              "primaryConceptIds": [
                "environment-configuration"
              ],
              "primaryRelationshipIds": [
                "rel-env-config-enables-worker"
              ]
            },
            {
              "id": "env-config-enables-shared-runtime-and-external-services",
              "index": 2,
              "title": "Environment configuration enables shared runtime and external services",
              "narrative": "The shared runtime validates required configuration and uses it to safely access external services such as LLM providers and Slack.",
              "conceptIds": [
                "environment-configuration"
              ],
              "relationshipIds": [
                "rel-env-config-enables-shared-runtime",
                "rel-env-config-enables-external-services"
              ],
              "primaryConceptIds": [
                "environment-configuration"
              ],
              "primaryRelationshipIds": [
                "rel-env-config-enables-shared-runtime"
              ]
            },
            {
              "id": "env-config-integrated-into-infrastructure",
              "index": 3,
              "title": "Environment configuration becomes part of infrastructure",
              "narrative": "Once validated and in use, the environment configuration is treated as a core part of the system infrastructure, including naming of task queues and other shared resources.",
              "conceptIds": [
                "environment-configuration",
                "task-queue"
              ],
              "relationshipIds": [
                "rel-env-config-part-of-infrastructure",
                "rel-env-config-used-by-tasks"
              ],
              "primaryConceptIds": [
                "environment-configuration"
              ],
              "primaryRelationshipIds": [
                "rel-env-config-part-of-infrastructure"
              ]
            }
          ]
        }
      ]
    }
  ]
}