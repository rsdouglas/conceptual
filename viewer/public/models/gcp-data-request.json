{
  "id": "gcp-data-request",
  "name": "Slack-based Data Request and Evaluation System",
  "summary": "A system where employees request data via Slack, an AI assistant helps review and process those requests, and admins configure and evaluate the AI behavior using templates and tests.",
  "description": "The system connects Slack conversations to an AI-driven workflow for classifying, iterating on, and reviewing data access requests. A worker processes Slack threads using LLMs and templates, while Firebase/Firestore stores threads, templates, tests, and debug events. An admin-facing evaluation UI lets teams design prompt templates, define checks, run test batches, and inspect results to improve the AI’s performance and governance around data requests.",
  "models": [
    {
      "id": "system-overview",
      "title": "Slack Data Request System Overview",
      "description": "High-level view of how Slack users, the AI worker, templates, tests, and storage work together to support and evaluate data requests raised in Slack.",
      "concepts": [
        {
          "id": "slack-user",
          "label": "Slack user",
          "category": "role",
          "description": "An employee or stakeholder who interacts in Slack channels and threads, sometimes asking for data or analysis.",
          "aliases": [
            "slack-user",
            "user",
            "userId"
          ],
          "notes": "A Slack user is an employee or stakeholder identified by a Slack user ID who participates in Slack channels and threads. In this system, the Slack user is primarily the originator or participant of Slack events (messages, threads) that may trigger data requests or evaluations. The user is referenced in event envelopes and task payloads but is not managed or stored as a rich domain entity here; instead, the system treats the user as an external actor identified by a string ID coming from Slack."
        },
        {
          "id": "slack-thread",
          "label": "Slack thread",
          "category": "thing",
          "description": "A conversation in Slack where a user may ask for data; the system treats each thread as a potential data request context.",
          "aliases": [
            "slack-thread",
            "thread",
            "thread_ts",
            "rootTs",
            "threadTs"
          ],
          "notes": "A Slack thread is the conversation context, identified by a root message timestamp, in which a user may ask for data. The system treats each thread (keyed by rootTs/threadTs) as the unit of context for data requests, reactions, and bot responses. All bot interactions in a given conversation are associated back to this root thread identifier."
        },
        {
          "id": "data-request",
          "label": "Data request",
          "category": "thing",
          "description": "A user’s request for data or analysis, usually expressed in a Slack thread and interpreted, classified, and iterated on by the AI worker.",
          "aliases": [
            "data request",
            "request",
            "data_request",
            "is_data_request",
            "review_data_request",
            "iterate_data_request"
          ],
          "notes": "A Data request is a user’s ask for data or analysis, typically expressed in a Slack thread. The system first classifies whether a Slack thread/message is a data request (vs. something else). For confirmed data requests, the AI worker produces and iteratively refines structured artifacts: a clear, well-documented request for the data team, clarifying questions for the user, step-by-step self-service instructions (usually for Looker) when possible, and a direct answer when the user is asking a meta question about fields, terminology, or data structures rather than actual data values. Iteration happens in-thread as the user replies, and the artifacts are updated to reflect the latest information."
        },
        {
          "id": "ai-worker",
          "label": "AI worker",
          "category": "role",
          "description": "A background worker that uses LLMs and templates to classify Slack threads, iterate on data requests, review them, and post responses back to Slack.",
          "aliases": [
            "ai-worker",
            "worker",
            "LLM worker",
            "background worker",
            "LLM job",
            "runLlmJob",
            "long-running LLM stub"
          ],
          "notes": "The AI worker is a background process that reacts to Slack thread activity and uses LLMs plus predefined context/templates to classify Slack threads as data requests, iterate on those data requests, review them, and then post responses back into Slack. It also manages Slack reactions and greeting behavior per thread and records thread-level metadata in Firestore."
        },
        {
          "id": "prompt-template",
          "label": "Prompt template",
          "category": "thing",
          "description": "A configurable template, often with EJS variables, that shapes how the AI worker talks to the LLM about data requests and Slack context.",
          "aliases": [
            "prompt-template",
            "PromptTemplate",
            "template",
            "EJS prompt template"
          ],
          "notes": "A Prompt Template is a configurable, versioned text pattern (often containing EJS variables) that defines how the AI worker talks to the LLM about data requests and Slack context. It is stored in Firestore under a promptTemplates collection with per-version subdocuments. Each Prompt Template specifies its raw template string, the variables it expects, metadata (name, description, tags, change notes, parentVersion), status (isActive), version number, creator and creation time, and optionally the target LLM model. Active templates are fetched and cached by the worker and can be used in test executions via templateId references."
        },
        {
          "id": "evaluation-check",
          "label": "Evaluation check",
          "category": "thing",
          "description": "A rule or script that inspects an AI response to see whether it meets certain criteria, such as safety, completeness, or policy compliance.",
          "aliases": [
            "evaluation-check",
            "check",
            "validation check",
            "AI response check"
          ],
          "notes": "An evaluation check is a named, stored rule that describes criteria for judging an AI response (e.g., safety, completeness, policy compliance). Each check has human-authored criteria text and an associated model used to perform the evaluation. During a test run, the system loads the relevant checks, renders a check-validation prompt that includes the test input, the AI test output, and the check's criteria, and then asks an LLM to decide whether the response passes or fails the check. The outcome is recorded as a CheckResult with status pass/fail and reasoning."
        },
        {
          "id": "test-case",
          "label": "Test case",
          "category": "thing",
          "description": "A predefined scenario, including inputs and expected outcomes, used to evaluate how well a prompt template and AI behavior handle specific kinds of data requests.",
          "aliases": [
            "TestCase",
            "test case",
            "test-case"
          ],
          "notes": "A test case is a predefined evaluation scenario for a prompt template in the Slack-based Data Request and Evaluation System. It bundles a human-readable name and description with a set of inputVariables (mapped by variable name) and a list of checkIds specifying which evaluation checks should be applied. Test cases are created and edited via the evals UI, tagged for organization, and then executed to produce test runs and check results. The current implementation notes that this TestCase type is UI-only and not yet shared with worker/ingest apps, implying it is primarily used for manual or semi-manual evaluation workflows rather than fully automated cross-app testing."
        },
        {
          "id": "test-batch",
          "label": "Test batch",
          "category": "activity",
          "description": "A group of test cases executed together against a template or model configuration to assess AI performance at scale.",
          "aliases": [
            "TestBatch",
            "batch",
            "test batch"
          ],
          "notes": "A test batch groups one or more test case executions that are run together against a specific prompt template (and implicitly its model configuration) to evaluate AI performance. Every test execution task references a batchId, so all executions are organized into batches, even when there is only a single test case. Batches are persisted (e.g., as Firestore documents) and can be inspected in UI components such as BatchDetailModal, which display batch metadata and associated batch results."
        },
        {
          "id": "evaluation-result",
          "label": "Evaluation result",
          "category": "thing",
          "description": "The recorded outcome of running checks and tests on AI responses, including passes, failures, and errors, used to improve templates and policies.",
          "aliases": [
            "evaluation result",
            "test run result",
            "TestRunPass",
            "TestRunFail",
            "TestRunError",
            "testRunResultId",
            "TestExecutionResult",
            "check result",
            "CheckResult",
            "overallStatus"
          ],
          "notes": "An evaluation result is the recorded outcome of executing a test case against a prompt template (and underlying model), including the overall status (pass/fail/error), timing, linkage to the originating test case and template, and any individual check results. It is used to understand how an AI response performed under defined checks and to inform improvements to templates and policies."
        },
        {
          "id": "admin-evaluator",
          "label": "Admin / evaluator",
          "category": "role",
          "description": "A person who configures templates, defines checks, runs test batches, and inspects results to govern and improve the AI’s handling of data requests.",
          "aliases": [
            "admin",
            "evaluator",
            "authenticated user",
            "signed-in user",
            "authorized user"
          ],
          "notes": "An admin/evaluator is a signed-in, authorized person who uses the evals web UI to configure and govern how the Slack-based data request assistant behaves. In the code, this person appears as the currently authenticated Firebase User and is allowed to manage checks, templates, test cases, and to inspect data request threads. They are distinct from Slack requesters; they work in a separate evaluation/admin interface."
        },
        {
          "id": "data-store",
          "label": "Data store",
          "category": "place",
          "description": "The shared storage (primarily Firestore) where threads, templates, test cases, test batches, debug events, and results are persisted.",
          "aliases": [
            "data store",
            "db",
            "Firestore",
            "FirestoreLike",
            "database",
            "shared storage"
          ],
          "notes": "The data store is the shared persistence layer for the Slack-based Data Request and Evaluation System. In practice it is implemented primarily as Google Cloud Firestore, accessed both from backend workers (via @google-cloud/firestore) and from the evals UI (via Firebase Web SDK). A minimal FirestoreLike interface is used where only a subset of Firestore behavior is needed (e.g., for recording debug events). The data store holds domain objects such as threads and their debug events, and—per the higher-level description—also templates, test cases, test batches, and results."
        }
      ],
      "relationships": [
        {
          "id": "rel-slack-user-sends-event-envelope",
          "from": "slack-user",
          "to": "event-envelope",
          "phrase": "sends message that is represented by",
          "category": "represents",
          "description": "A Slack user sends a message in Slack, and that incoming Slack message is represented in the system as an EventEnvelope, which may include the user's Slack ID in the `user` field."
        },
        {
          "id": "rel-slack-user-associated-with-task-payload",
          "from": "slack-user",
          "to": "task-payload",
          "phrase": "is associated with",
          "category": "represents",
          "description": "A Slack user is associated with a TaskPayload via the optional `user` field, indicating which Slack user initiated or is relevant to the task derived from a Slack thread or message."
        },
        {
          "id": "rel-slack-user-initiates-test-execution-task",
          "from": "slack-user",
          "to": "test-execution-task-payload",
          "phrase": "is recorded as user for",
          "category": "represents",
          "description": "A Slack user (or more generally, a system user) is recorded as the `userId` in a TestExecutionTaskPayload, indicating which user is responsible for or associated with the test execution task. In this context, the user may be the same Slack user who initiated the underlying request."
        },
        {
          "id": "rel-slack-user-receives-thread-messages",
          "from": "slack-user",
          "to": "outgoing-slack-message",
          "phrase": "receives",
          "category": "uses",
          "description": "A Slack user receives outgoing Slack messages posted by the system into a thread (via `postThreadMessage` or `postThreadBlocks`), which are responses or follow-ups to the user's original Slack message or request."
        },
        {
          "id": "rel-slack-thread-has-channel",
          "from": "slack-thread",
          "to": "slack-channel",
          "phrase": "occurs in",
          "category": "part_of",
          "description": "Each Slack thread occurs within a specific Slack channel, referenced by the channel ID in events and task payloads."
        },
        {
          "id": "rel-slack-thread-has-root-message",
          "from": "slack-thread",
          "to": "slack-message",
          "phrase": "is identified by root message timestamp",
          "category": "represents",
          "description": "A Slack thread is identified by the timestamp of its root message (rootTs or threadTs), which is used as the thread_ts when posting replies and as the key for associating events and debug records."
        },
        {
          "id": "rel-slack-thread-uses-event-envelope",
          "from": "slack-thread",
          "to": "event-envelope",
          "phrase": "is referenced by",
          "category": "uses",
          "description": "Slack threads are referenced in incoming Slack events via the EventEnvelope, which carries channel, ts, and optional threadTs to indicate whether a message belongs to a thread."
        },
        {
          "id": "rel-slack-thread-uses-task-payload",
          "from": "slack-thread",
          "to": "task-payload",
          "phrase": "is processed via",
          "category": "uses",
          "description": "Background processing related to a Slack thread uses TaskPayload objects that include channel and rootTs to identify the thread context for data request handling."
        },
        {
          "id": "rel-slack-thread-receives-robot-reaction",
          "from": "slack-thread",
          "to": "slack-bot-reaction",
          "phrase": "receives",
          "category": "causes",
          "description": "When the system recognizes a relevant message, the root message of the Slack thread receives a robot_face reaction from the bot, marking the thread as being handled by the system."
        },
        {
          "id": "rel-slack-thread-receives-bot-greeting",
          "from": "slack-thread",
          "to": "slack-bot-message",
          "phrase": "receives greeting message in",
          "category": "causes",
          "description": "The system can post an initial greeting or explanatory message into the Slack thread, using the rootTs as thread_ts to anchor the response in that conversation."
        },
        {
          "id": "rel-slack-thread-receives-bot-messages",
          "from": "slack-thread",
          "to": "slack-bot-message",
          "phrase": "receives messages from",
          "category": "causes",
          "description": "The system posts text or block-based messages into the Slack thread as it processes data requests, always referencing the thread by its rootTs."
        },
        {
          "id": "rel-slack-thread-has-debug-events",
          "from": "slack-thread",
          "to": "debug-event",
          "phrase": "is associated with",
          "category": "uses",
          "description": "Outgoing Slack messages posted into a thread generate DebugEvent records keyed by the thread's rootTs, allowing the system to trace activity within that thread."
        },
        {
          "id": "rel-data-request-expressed-in-slack-thread",
          "from": "data-request",
          "to": "slack-thread",
          "phrase": "is expressed in",
          "category": "part_of",
          "description": "A data request is expressed within a Slack thread, using one or more Slack messages as its natural language input."
        },
        {
          "id": "rel-user-makes-data-request",
          "from": "user",
          "to": "data-request",
          "phrase": "makes",
          "category": "causes",
          "description": "A user makes a data request by posting messages in a Slack thread that ask for data or analysis."
        },
        {
          "id": "rel-data-request-classified-by-llm",
          "from": "data-request",
          "to": "llm-classification",
          "phrase": "is identified by",
          "category": "uses",
          "description": "The system uses an LLM-based classification step to determine whether a Slack thread or message constitutes a data request."
        },
        {
          "id": "rel-data-request-has-review-artifacts",
          "from": "data-request",
          "to": "review-artifacts",
          "phrase": "has",
          "category": "part_of",
          "description": "Each data request is associated with review artifacts produced by the AI assistant: a refined request, clarifying questions, self-service step-by-step instructions, and an optional direct answer."
        },
        {
          "id": "rel-data-request-reviewed-by-ai-assistant",
          "from": "ai-assistant",
          "to": "data-request",
          "phrase": "reviews and structures",
          "category": "uses",
          "description": "The AI assistant reviews a data request to ensure it is well documented and unambiguous, producing structured artifacts for the data team and the user."
        },
        {
          "id": "rel-data-request-has-clarifying-questions",
          "from": "data-request",
          "to": "clarifying-questions",
          "phrase": "has",
          "category": "part_of",
          "description": "A data request may have associated clarifying questions that the AI assistant asks the user when the request is ambiguous or incomplete."
        },
        {
          "id": "rel-data-request-has-step-by-step-instructions",
          "from": "data-request",
          "to": "self-service-step-by-step-instructions",
          "phrase": "may have",
          "category": "part_of",
          "description": "When self-service is feasible, a data request is accompanied by step-by-step instructions (typically for Looker) that allow the user to obtain the answer themselves."
        },
        {
          "id": "rel-data-request-may-have-direct-answer",
          "from": "data-request",
          "to": "direct-answer",
          "phrase": "may have",
          "category": "part_of",
          "description": "If the user’s request is a meta question about field meanings, business terminology, or data structures, the data request may be satisfied with a direct answer instead of or in addition to data retrieval."
        },
        {
          "id": "rel-data-request-iterated-by-ai",
          "from": "data-request",
          "to": "iteration-cycle",
          "phrase": "is refined through",
          "category": "precedes",
          "description": "A data request is refined through an in-thread iteration cycle where the AI assistant updates the request, clarifying questions, self-service instructions, and direct answer based on new user replies."
        },
        {
          "id": "rel-data-request-linked-to-debug-events",
          "from": "data-request",
          "to": "debug-event",
          "phrase": "is associated with",
          "category": "uses",
          "description": "A data request is associated with debug events such as LLM classification results and thread creation events, which are recorded for evaluation and monitoring."
        },
        {
          "id": "rel-ai-worker-uses-llm-models",
          "from": "ai-worker",
          "to": "llm-model",
          "phrase": "uses",
          "category": "uses",
          "description": "The AI worker uses generative LLM models (via Vertex AI) to analyze and generate content for Slack data requests."
        },
        {
          "id": "rel-ai-worker-uses-context",
          "from": "ai-worker",
          "to": "llm-context",
          "phrase": "uses",
          "category": "uses",
          "description": "The AI worker uses named context documents (markdown files) as prompt context when running LLM-based classification, iteration, and review of data requests."
        },
        {
          "id": "rel-ai-worker-classifies-thread",
          "from": "ai-worker",
          "to": "slack-thread",
          "phrase": "classifies",
          "category": "causes",
          "description": "The AI worker classifies a Slack thread to determine whether it is a data request."
        },
        {
          "id": "rel-ai-worker-iterates-data-request",
          "from": "ai-worker",
          "to": "data-request",
          "phrase": "iterates on",
          "category": "causes",
          "description": "When a Slack thread is recognized as a data request, the AI worker iterates on the request content using LLMs to refine or elaborate it."
        },
        {
          "id": "rel-ai-worker-reviews-data-request",
          "from": "ai-worker",
          "to": "data-request",
          "phrase": "reviews",
          "category": "causes",
          "description": "The AI worker reviews a data request using LLMs, likely checking quality, completeness, or adherence to guidelines before responding."
        },
        {
          "id": "rel-ai-worker-posts-to-slack",
          "from": "ai-worker",
          "to": "slack-thread",
          "phrase": "posts responses to",
          "category": "causes",
          "description": "The AI worker posts generated responses and block messages back into the originating Slack thread."
        },
        {
          "id": "rel-ai-worker-adds-reactions",
          "from": "ai-worker",
          "to": "slack-message",
          "phrase": "adds robot reaction to",
          "category": "causes",
          "description": "The AI worker adds a robot reaction to a Slack message to signal that it is processing the thread."
        },
        {
          "id": "rel-ai-worker-removes-reactions",
          "from": "ai-worker",
          "to": "slack-message",
          "phrase": "removes robot reaction from",
          "category": "causes",
          "description": "The AI worker removes the robot reaction from a Slack message when processing is complete or no longer needed."
        },
        {
          "id": "rel-ai-worker-fetches-thread-messages",
          "from": "ai-worker",
          "to": "slack-thread",
          "phrase": "fetches messages for",
          "category": "uses",
          "description": "The AI worker fetches all messages in a Slack thread to provide full conversational context to the LLM."
        },
        {
          "id": "rel-ai-worker-updates-thread-record",
          "from": "ai-worker",
          "to": "thread-record",
          "phrase": "updates",
          "category": "causes",
          "description": "The AI worker updates a Firestore thread record (e.g., reacted, greeted, updatedAt) when it processes a Slack thread."
        },
        {
          "id": "rel-ai-worker-runs-for-task-payload",
          "from": "ai-worker",
          "to": "task-payload",
          "phrase": "processes",
          "category": "uses",
          "description": "The AI worker processes a task payload that describes which Slack channel, thread, and message to handle."
        },
        {
          "id": "rel-prompt-template-has-variables",
          "from": "prompt-template",
          "to": "template-variable",
          "phrase": "has",
          "category": "part_of",
          "description": "A Prompt Template has a list of variables that can be substituted when rendering the template for an LLM call."
        },
        {
          "id": "rel-prompt-template-uses-ejs",
          "from": "prompt-template",
          "to": "ejs-variable",
          "phrase": "uses",
          "category": "uses",
          "description": "A Prompt Template uses EJS-style variables and tags inside its template string to parameterize the prompt content."
        },
        {
          "id": "rel-prompt-template-stored-in-firestore",
          "from": "prompt-template",
          "to": "firestore-prompt-template-document",
          "phrase": "is stored as",
          "category": "represents",
          "description": "A Prompt Template is represented as a document in the promptTemplates collection with versioned subdocuments in Firestore."
        },
        {
          "id": "rel-prompt-template-has-version",
          "from": "prompt-template",
          "to": "prompt-template-version",
          "phrase": "has",
          "category": "part_of",
          "description": "A Prompt Template has a specific version number and may be related to a parentVersion, representing its evolution over time."
        },
        {
          "id": "rel-prompt-template-has-active-version-flag",
          "from": "prompt-template",
          "to": "prompt-template-active-state",
          "phrase": "has",
          "category": "part_of",
          "description": "A Prompt Template has an isActive flag indicating whether that version is currently active."
        },
        {
          "id": "rel-prompt-template-selected-by-metadata-activeVersion",
          "from": "prompt-template",
          "to": "prompt-template-metadata",
          "phrase": "is selected by",
          "category": "uses",
          "description": "The active version of a Prompt Template is selected using the activeVersion field in its metadata document."
        },
        {
          "id": "rel-prompt-template-used-in-test-execution",
          "from": "prompt-template",
          "to": "test-execution-task",
          "phrase": "is referenced by",
          "category": "uses",
          "description": "A Test Execution Task references a Prompt Template via templateId to run tests against a specific template version."
        },
        {
          "id": "rel-prompt-template-created-by-user",
          "from": "prompt-template",
          "to": "user",
          "phrase": "is created by",
          "category": "other",
          "description": "A Prompt Template records the identifier of the user who created that version in createdBy."
        },
        {
          "id": "rel-prompt-template-targets-model",
          "from": "prompt-template",
          "to": "llm-model",
          "phrase": "targets",
          "category": "uses",
          "description": "A Prompt Template can specify which LLM model (e.g., gemini-2.5-flash or gemini-2.5-pro) it is intended to be used with."
        },
        {
          "id": "rel-evalcheck-has-criteria",
          "from": "evaluation-check",
          "to": "check-criteria",
          "phrase": "has",
          "category": "part_of",
          "description": "An evaluation check has human-authored criteria text that describes what the AI response must satisfy."
        },
        {
          "id": "rel-evalcheck-uses-model",
          "from": "evaluation-check",
          "to": "llm-model",
          "phrase": "uses",
          "category": "uses",
          "description": "An evaluation check specifies which LLM model should be used to perform the evaluation of an AI response."
        },
        {
          "id": "rel-evalcheck-yields-checkresult",
          "from": "evaluation-check",
          "to": "check-result",
          "phrase": "yields",
          "category": "causes",
          "description": "When executed in the context of a test run, an evaluation check yields a CheckResult capturing pass/fail status and reasoning."
        },
        {
          "id": "rel-evalcheck-stored-in-checks-collection",
          "from": "evaluation-check",
          "to": "checks-collection",
          "phrase": "is stored in",
          "category": "part_of",
          "description": "Each evaluation check is persisted as a document in the 'checks' collection in the database."
        },
        {
          "id": "rel-evalcheck-executed-in-test-run",
          "from": "evaluation-check",
          "to": "test-run",
          "phrase": "is executed in",
          "category": "uses",
          "description": "Evaluation checks are executed as part of a test run to assess a specific AI test output against defined criteria."
        },
        {
          "id": "rel-evalcheck-applied-to-test-output",
          "from": "evaluation-check",
          "to": "test-output",
          "phrase": "is applied to",
          "category": "uses",
          "description": "An evaluation check is applied to a test output (an AI response) to determine whether it passes the check's criteria."
        },
        {
          "id": "rel-evalcheck-considers-test-input",
          "from": "evaluation-check",
          "to": "test-input",
          "phrase": "considers",
          "category": "uses",
          "description": "When executed, an evaluation check considers the original test input alongside the test output to judge compliance with its criteria."
        },
        {
          "id": "rel-evalcheck-uses-check-validation-template",
          "from": "evaluation-check",
          "to": "check-validation-prompt-template",
          "phrase": "uses",
          "category": "uses",
          "description": "Execution of an evaluation check uses the active 'check_validation' prompt template to structure the evaluation request to the LLM."
        },
        {
          "id": "rel-evalcheck-created-via-checkform",
          "from": "evaluation-check",
          "to": "check-form",
          "phrase": "is created or edited via",
          "category": "uses",
          "description": "Users create or edit evaluation checks through the CheckForm UI, providing name, criteria, and model."
        },
        {
          "id": "rel-test-case-has-input-variables",
          "from": "test-case",
          "to": "input-variables",
          "phrase": "has",
          "category": "part_of",
          "description": "A test case has inputVariables, a mapping from variable names to concrete values, used to populate a prompt template when the test case is executed."
        },
        {
          "id": "rel-test-case-has-check-ids",
          "from": "test-case",
          "to": "check",
          "phrase": "selects",
          "category": "uses",
          "description": "A test case selects one or more checks to run by storing their identifiers in checkIds; these checks are executed against the test run produced from the test case."
        },
        {
          "id": "rel-test-case-tagged-by-tags",
          "from": "test-case",
          "to": "tag",
          "phrase": "is tagged by",
          "category": "other",
          "description": "A test case is tagged by zero or more tags, which are short labels used in the UI to categorize or filter test cases."
        },
        {
          "id": "rel-test-case-created-by-user",
          "from": "test-case",
          "to": "user",
          "phrase": "is created by",
          "category": "causes",
          "description": "A test case is created by a user, recorded via createdBy along with createdAt and updatedAt timestamps."
        },
        {
          "id": "rel-test-case-produces-test-run",
          "from": "test-case",
          "to": "test-run",
          "phrase": "produces",
          "category": "causes",
          "description": "Executing a test case produces one or more test runs (pass, fail, or error), each linked back to the originating test case via testCaseId."
        },
        {
          "id": "rel-test-case-executes-template",
          "from": "test-case",
          "to": "prompt-template",
          "phrase": "is executed against",
          "category": "uses",
          "description": "A test case is executed against a specific prompt template (identified by templateId and templateVersion in the resulting test run) to evaluate how that template behaves with the test case's inputVariables."
        },
        {
          "id": "rel-test-run-has-check-results",
          "from": "test-run",
          "to": "check-result",
          "phrase": "has",
          "category": "part_of",
          "description": "A test run has zero or more check results, each representing the outcome of running a specific check (referenced by checkId) in the context of that test run."
        },
        {
          "id": "rel-check-result-refers-to-test-case-indirectly",
          "from": "check-result",
          "to": "test-case",
          "phrase": "indirectly refers to",
          "category": "other",
          "description": "A check result indirectly refers to a test case through its testRunId, since each test run is associated with a specific test case via testCaseId."
        },
        {
          "id": "rel-test-case-included-in-test-batch",
          "from": "test-case",
          "to": "test-batch",
          "phrase": "may be included in",
          "category": "part_of",
          "description": "A test case may be included in a test batch (TestBatch) for batch execution, where multiple test cases are run together."
        },
        {
          "id": "rel-test-batch-has-test-executions",
          "from": "test-batch",
          "to": "test-execution-task",
          "phrase": "groups",
          "category": "part_of",
          "description": "A test batch groups one or more test execution tasks. Each TestExecutionTaskPayload includes a batchId indicating the batch it belongs to, and all test executions are now part of batches."
        },
        {
          "id": "rel-test-batch-targets-template",
          "from": "test-batch",
          "to": "prompt-template",
          "phrase": "targets",
          "category": "uses",
          "description": "A test batch is executed against a specific prompt template (and its active version). The executeTest function fetches the active template for the given templateId before creating a batch and enqueuing test execution tasks."
        },
        {
          "id": "rel-test-batch-has-results",
          "from": "test-batch",
          "to": "test-batch-result",
          "phrase": "has",
          "category": "part_of",
          "description": "A test batch has one or more batch-level result records. The BatchDetailModal loads and displays TestBatchResult entries associated with a given batchId, representing the outcomes of the batch's test executions."
        },
        {
          "id": "rel-test-batch-has-test-run-results",
          "from": "test-batch",
          "to": "test-run-result",
          "phrase": "aggregates",
          "category": "part_of",
          "description": "A test batch aggregates individual test run results for its test cases. The BatchDetailModal maintains state for TestRunResult items associated with the selected batch, allowing inspection of per-test outcomes within the batch."
        },
        {
          "id": "rel-test-batch-initiated-by-user",
          "from": "test-batch",
          "to": "user",
          "phrase": "is initiated by",
          "category": "causes",
          "description": "A test batch is initiated by an authenticated user. The executeTest function requires request.auth and uses the authenticated userId when creating a batch and its associated test execution tasks."
        },
        {
          "id": "rel-test-batch-associated-with-test-cases",
          "from": "test-batch",
          "to": "test-case",
          "phrase": "includes executions of",
          "category": "part_of",
          "description": "A test batch includes executions of one or more test cases. Each TestExecutionTaskPayload references a testCaseId along with the batchId, tying specific test cases to the batch."
        },
        {
          "id": "rel-eval-uses-testcase",
          "from": "evaluation-result",
          "to": "test-case",
          "phrase": "evaluates",
          "category": "uses",
          "description": "Each evaluation result is produced by running a specific test case, referenced by testCaseId."
        },
        {
          "id": "rel-eval-uses-template",
          "from": "evaluation-result",
          "to": "prompt-template",
          "phrase": "evaluates responses generated from",
          "category": "uses",
          "description": "Each evaluation result is tied to a specific prompt template and version, referenced by templateId and templateVersion."
        },
        {
          "id": "rel-eval-has-check-results",
          "from": "evaluation-result",
          "to": "check-result",
          "phrase": "aggregates",
          "category": "part_of",
          "description": "An evaluation result may contain multiple check results, each representing the outcome of an individual check applied to the AI response."
        },
        {
          "id": "rel-eval-produced-by-user",
          "from": "evaluation-result",
          "to": "user",
          "phrase": "is executed by",
          "category": "uses",
          "description": "Each evaluation result records the user who initiated the test run via executedBy."
        },
        {
          "id": "rel-eval-refers-to-request",
          "from": "evaluation-result",
          "to": "data-request",
          "phrase": "references",
          "category": "represents",
          "description": "For passing and failing runs, the evaluation result references the underlying test request via requestId and threadId, linking the evaluation back to the Slack-based data request context."
        },
        {
          "id": "rel-eval-in-batch",
          "from": "evaluation-result",
          "to": "test-batch",
          "phrase": "belongs to",
          "category": "part_of",
          "description": "Evaluation results are executed as part of a test batch, which groups multiple test executions for a template."
        },
        {
          "id": "rel-check-result-belongs-to-eval",
          "from": "check-result",
          "to": "evaluation-result",
          "phrase": "belongs to",
          "category": "part_of",
          "description": "Each check result is associated with a specific evaluation result via testRunId."
        },
        {
          "id": "rel-check-result-refers-check",
          "from": "check-result",
          "to": "check",
          "phrase": "is produced by running",
          "category": "uses",
          "description": "Each check result references the check definition that was executed via checkId."
        },
        {
          "id": "rel-admin-authenticates",
          "from": "admin-evaluator",
          "to": "auth-session",
          "phrase": "authenticates as",
          "category": "enables",
          "description": "The admin/evaluator must authenticate (e.g., via Firebase/Google sign-in) to obtain a user session before accessing checks, templates, or data request lists."
        },
        {
          "id": "rel-admin-views-checks",
          "from": "admin-evaluator",
          "to": "check",
          "phrase": "views list of",
          "category": "uses",
          "description": "The admin/evaluator views the list of defined checks in order to understand and manage how AI responses are evaluated."
        },
        {
          "id": "rel-admin-creates-check",
          "from": "admin-evaluator",
          "to": "check",
          "phrase": "creates",
          "category": "causes",
          "description": "The admin/evaluator creates new checks using the CheckForm to define evaluation criteria for AI behavior."
        },
        {
          "id": "rel-admin-updates-check",
          "from": "admin-evaluator",
          "to": "check",
          "phrase": "updates",
          "category": "causes",
          "description": "The admin/evaluator edits existing checks to refine or correct evaluation criteria."
        },
        {
          "id": "rel-admin-deletes-check",
          "from": "admin-evaluator",
          "to": "check",
          "phrase": "deletes",
          "category": "causes",
          "description": "The admin/evaluator can delete checks that are no longer needed."
        },
        {
          "id": "rel-admin-creates-template",
          "from": "admin-evaluator",
          "to": "template",
          "phrase": "creates",
          "category": "causes",
          "description": "The admin/evaluator creates templates that define how the AI should respond to Slack data requests."
        },
        {
          "id": "rel-admin-edits-template-version",
          "from": "admin-evaluator",
          "to": "template-version",
          "phrase": "edits",
          "category": "causes",
          "description": "The admin/evaluator edits specific template versions in the Template Manager to change prompt content or configuration."
        },
        {
          "id": "rel-admin-activates-template-version",
          "from": "admin-evaluator",
          "to": "template-version",
          "phrase": "marks as active",
          "category": "causes",
          "description": "The admin/evaluator explicitly activates a template version to make it the version used in production, after review and testing."
        },
        {
          "id": "rel-admin-runs-test-cases",
          "from": "admin-evaluator",
          "to": "test-case",
          "phrase": "runs",
          "category": "causes",
          "description": "The admin/evaluator runs test cases against templates and checks to validate AI behavior before or after deployment."
        },
        {
          "id": "rel-admin-reviews-test-results",
          "from": "admin-evaluator",
          "to": "test-result",
          "phrase": "reviews",
          "category": "uses",
          "description": "The admin/evaluator inspects test results to assess whether templates and checks are producing acceptable AI behavior."
        },
        {
          "id": "rel-admin-views-data-requests",
          "from": "admin-evaluator",
          "to": "data-request-thread",
          "phrase": "views",
          "category": "uses",
          "description": "The admin/evaluator views Slack data request threads (including status, requester, artifacts, and confidence) in the DataRequestsList page."
        },
        {
          "id": "rel-admin-inspects-artifacts",
          "from": "admin-evaluator",
          "to": "ai-artifact",
          "phrase": "inspects",
          "category": "uses",
          "description": "The admin/evaluator inspects AI-generated artifacts (request interpretation, clarifying questions, step-by-step instructions) attached to data request threads to understand and improve AI behavior."
        },
        {
          "id": "rel-admin-governs-ai-handling",
          "from": "admin-evaluator",
          "to": "ai-handling-of-data-requests",
          "phrase": "governs and improves",
          "category": "causes",
          "description": "By configuring templates, defining checks, and running tests, the admin/evaluator governs and iteratively improves how the AI handles Slack data requests."
        },
        {
          "id": "rel-data-store-uses-firestore",
          "from": "data-store",
          "to": "firestore-service",
          "phrase": "is implemented using",
          "category": "represents",
          "description": "The data store is realized using Google Cloud Firestore as the underlying storage service for persisting system data."
        },
        {
          "id": "rel-data-store-used-by-worker",
          "from": "worker-app",
          "to": "data-store",
          "phrase": "uses",
          "category": "uses",
          "description": "The worker application obtains a Firestore handle via getDb and uses the shared data store to persist and retrieve domain data."
        },
        {
          "id": "rel-data-store-used-by-ingest",
          "from": "ingest-app",
          "to": "data-store",
          "phrase": "uses",
          "category": "uses",
          "description": "The ingest application obtains a Firestore handle via getDb and uses the shared data store to persist and retrieve ingested data."
        },
        {
          "id": "rel-data-store-used-by-evals-ui",
          "from": "evals-app",
          "to": "data-store",
          "phrase": "uses",
          "category": "uses",
          "description": "The evals UI application initializes a Firebase app and obtains a Firestore instance (db) to access the shared data store from the client side."
        },
        {
          "id": "rel-data-store-contains-threads",
          "from": "data-store",
          "to": "thread",
          "phrase": "contains",
          "category": "part_of",
          "description": "The data store contains a collection of threads, each identified by a root timestamp or similar identifier."
        },
        {
          "id": "rel-data-store-contains-thread-debug-events",
          "from": "data-store",
          "to": "debug-event",
          "phrase": "stores as subcollection of thread",
          "category": "part_of",
          "description": "For each thread, the data store can hold a debugEvents subcollection where individual debug events related to that thread are persisted."
        },
        {
          "id": "rel-debug-event-belongs-to-thread",
          "from": "debug-event",
          "to": "thread",
          "phrase": "belongs to",
          "category": "part_of",
          "description": "Each debug event is stored under a specific thread document (threads/{rootTs}/debugEvents/{eventId}), indicating that the event is associated with that thread."
        },
        {
          "id": "rel-record-debug-event-uses-data-store",
          "from": "record-debug-event-operation",
          "to": "data-store",
          "phrase": "writes to",
          "category": "uses",
          "description": "The recordDebugEvent operation uses the data store to persist debug events under the appropriate thread document."
        },
        {
          "id": "rel-record-error-uses-data-store",
          "from": "record-error-operation",
          "to": "data-store",
          "phrase": "writes debug event to",
          "category": "uses",
          "description": "The recordError operation logs an error and then uses the data store to record a corresponding debug event for a given thread."
        }
      ],
      "rules": [
        {
          "id": "rule-slack-user-optional-in-event-envelope",
          "title": "Slack user may be absent in some event envelopes",
          "text": "In an EventEnvelope, the `user` field is optional, meaning some Slack events processed by the system may not be associated with a specific Slack user (for example, system messages or events without a user context).",
          "kind": "assumption",
          "conceptIds": [
            "slack-user"
          ]
        },
        {
          "id": "rule-slack-user-optional-in-task-payload",
          "title": "Slack user may be absent in some task payloads",
          "text": "In a TaskPayload, the `user` field is optional, so not every task derived from Slack activity must be tied to a specific Slack user in the system.",
          "kind": "assumption",
          "conceptIds": [
            "slack-user"
          ]
        },
        {
          "id": "rule-test-execution-task-requires-user-id",
          "title": "Test execution task must have a user ID",
          "text": "A TestExecutionTaskPayload must include a `userId`, ensuring that every test execution task is associated with a specific user identity.",
          "kind": "constraint",
          "conceptIds": [
            "slack-user"
          ]
        },
        {
          "id": "rule-slack-thread-must-have-channel-and-rootTs",
          "title": "Slack thread must be identified by channel and root timestamp",
          "text": "Any operation that posts messages or reactions in the context of a Slack thread must specify both the Slack channel identifier and the root thread timestamp (rootTs/threadTs) to correctly target the conversation.",
          "kind": "invariant",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-slack-thread-rootTs-is-stable-identifier",
          "title": "Slack thread rootTs is the stable identifier for the thread",
          "text": "Within the system, the root message timestamp (rootTs or threadTs) is treated as the stable identifier for a Slack thread and is reused across task payloads, Slack API calls, and debug events to correlate all actions in that thread.",
          "kind": "assumption",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-slack-thread-bot-messages-are-threaded",
          "title": "Bot messages in a Slack thread must be posted as threaded replies",
          "text": "When the system responds in a Slack thread, it must use the root thread timestamp as thread_ts so that all bot messages appear as replies within the same Slack thread rather than as new top-level channel messages.",
          "kind": "policy",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-data-request-must-be-classified",
          "title": "Data request must be identified by classification",
          "text": "A Slack thread or message is treated as a data request only if the LLM-based classification step determines that it is a data request.",
          "kind": "constraint",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-data-request-has-review-artifacts",
          "title": "Data request review artifacts must be produced",
          "text": "For each confirmed data request, the AI assistant produces a structured review result containing a refined request, clarifying questions (possibly empty), step-by-step instructions (possibly empty), and a direct answer (possibly empty).",
          "kind": "invariant",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-clarifying-questions-gate-user-facing-output",
          "title": "Clarifying questions gate what is shown to the user",
          "text": "If a data request has any clarifying questions, only those clarifying questions are shown to the user; the refined request, step-by-step instructions, and direct answer are retained for later iteration but not initially shown.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-no-clarifying-questions-shows-instructions-or-request",
          "title": "When no clarifying questions remain, show instructions or request",
          "text": "When a data request has no remaining clarifying questions, the user is shown the step-by-step self-service instructions if they exist; otherwise, the user is shown the well-documented request produced by the AI assistant.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-direct-answer-only-for-meta-questions",
          "title": "Direct answer only for meta questions",
          "text": "A direct answer is provided only when the data request is a meta question about field meanings, business terminology, or data structures, and must not be used for questions about actual data values, metrics, numbers, counts, or specific data content.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-data-questions-treated-as-data-requests",
          "title": "Questions involving actual data are treated as data requests",
          "text": "If a user question touches on actual data values, metrics, numbers, counts, or specific data content, it must be treated as a data request and handled via the request and step-by-step instructions artifacts rather than as a direct answer.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-ai-worker-requires-thread-identifiers",
          "title": "AI worker requires channel and root thread timestamp",
          "text": "The AI worker only processes a task payload when both a Slack channel identifier and a root thread timestamp are present; otherwise it performs no work.",
          "kind": "constraint",
          "conceptIds": [
            "ai-worker"
          ]
        },
        {
          "id": "rule-ai-worker-one-reaction-per-thread",
          "title": "AI worker adds robot reaction at most once per thread",
          "text": "The AI worker checks the thread record before adding a robot reaction and only adds the reaction if the thread has not already been marked as reacted.",
          "kind": "invariant",
          "conceptIds": [
            "ai-worker"
          ]
        },
        {
          "id": "rule-ai-worker-one-greeting-per-thread",
          "title": "AI worker greets at most once per thread",
          "text": "The AI worker checks the thread record before posting a greeting and only greets if the thread has not already been marked as greeted.",
          "kind": "invariant",
          "conceptIds": [
            "ai-worker"
          ]
        },
        {
          "id": "rule-ai-worker-updates-thread-timestamp",
          "title": "AI worker updates thread last-updated time",
          "text": "Whenever the AI worker processes a thread, it updates the thread record's updatedAt timestamp to the current time.",
          "kind": "invariant",
          "conceptIds": [
            "ai-worker"
          ]
        },
        {
          "id": "rule-prompt-template-must-have-id-name-template",
          "title": "Prompt Template must have core identifiers and content",
          "text": "Each Prompt Template must have an id, a name, and a template string defined.",
          "kind": "invariant",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "rule-prompt-template-version-required",
          "title": "Prompt Template must have a version number",
          "text": "Each Prompt Template instance must specify a numeric version to distinguish it from other versions.",
          "kind": "invariant",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "rule-prompt-template-active-version-must-exist",
          "title": "Active Prompt Template version must exist",
          "text": "When fetching an active Prompt Template, the metadata document must exist and its activeVersion must correspond to an existing version document.",
          "kind": "constraint",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "rule-prompt-template-variables-derived-from-template",
          "title": "Prompt Template variables are derived from template content",
          "text": "The variables list of a Prompt Template is determined by extracting non-keyword identifiers from its EJS template string.",
          "kind": "assumption",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "rule-prompt-template-created-at-and-by-required",
          "title": "Prompt Template records creation metadata",
          "text": "Each Prompt Template version must record when it was created (createdAt) and by whom (createdBy).",
          "kind": "invariant",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "rule-evalcheck-requires-name",
          "title": "Evaluation check must have a name",
          "text": "Every evaluation check must have a non-empty name so that users can identify it.",
          "kind": "constraint",
          "conceptIds": [
            "evaluation-check"
          ]
        },
        {
          "id": "rule-evalcheck-requires-criteria",
          "title": "Evaluation check must define criteria",
          "text": "Every evaluation check must have non-empty criteria text describing how to judge an AI response.",
          "kind": "constraint",
          "conceptIds": [
            "evaluation-check"
          ]
        },
        {
          "id": "rule-evalcheck-has-model",
          "title": "Evaluation check must specify an evaluation model",
          "text": "Every evaluation check must specify which LLM model will be used to perform the evaluation.",
          "kind": "constraint",
          "conceptIds": [
            "evaluation-check"
          ]
        },
        {
          "id": "rule-evalcheck-execution-optional-per-test",
          "title": "Test run may have zero or more evaluation checks",
          "text": "A test run may execute zero or more evaluation checks; if no check IDs are provided, no checks are executed.",
          "kind": "assumption",
          "conceptIds": [
            "evaluation-check"
          ]
        },
        {
          "id": "rule-evalcheck-execution-produces-single-result",
          "title": "Each evaluation check execution produces one result",
          "text": "For a given test run and check, executing the evaluation check produces a single CheckResult with pass or fail status and reasoning.",
          "kind": "assumption",
          "conceptIds": [
            "evaluation-check"
          ]
        },
        {
          "id": "rule-test-case-must-have-name-and-id",
          "title": "Test case must have identifier and name",
          "text": "Every test case must have a unique id and a non-empty name to be created and used in the evals UI.",
          "kind": "invariant",
          "conceptIds": [
            "test-case"
          ]
        },
        {
          "id": "rule-test-case-must-specify-input-variables",
          "title": "Test case must specify input variables",
          "text": "Every test case must define inputVariables, providing concrete values for some or all variables required by the associated prompt template.",
          "kind": "invariant",
          "conceptIds": [
            "test-case"
          ]
        },
        {
          "id": "rule-test-case-may-select-zero-or-more-checks",
          "title": "Test case may select zero or more checks",
          "text": "A test case may specify an empty or non-empty list of checkIds; if checkIds is empty, the test run will not produce check results.",
          "kind": "assumption",
          "conceptIds": [
            "test-case"
          ]
        },
        {
          "id": "rule-test-case-records-authorship-and-timestamps",
          "title": "Test case records authorship and timestamps",
          "text": "Each test case records createdBy, createdAt, and updatedAt to track who created it and when it was created or last modified.",
          "kind": "invariant",
          "conceptIds": [
            "test-case"
          ]
        },
        {
          "id": "rule-test-run-must-reference-test-case",
          "title": "Test run must reference originating test case",
          "text": "Every test run (pass, fail, or error) must reference the originating test case via testCaseId.",
          "kind": "invariant",
          "conceptIds": [
            "test-case"
          ]
        },
        {
          "id": "rule-test-batch-requires-authenticated-user",
          "title": "Test batch creation requires an authenticated user",
          "text": "A test batch can only be created when there is an authenticated user; otherwise, test execution is rejected.",
          "kind": "constraint",
          "conceptIds": [
            "test-batch"
          ]
        },
        {
          "id": "rule-test-batch-requires-template-and-test-case",
          "title": "Test batch requires template and test case identifiers",
          "text": "To create a test batch and enqueue its test execution tasks, a templateId, inputVariables, and testCaseId must be provided; otherwise, the operation is considered invalid.",
          "kind": "constraint",
          "conceptIds": [
            "test-batch"
          ]
        },
        {
          "id": "rule-all-test-executions-belong-to-batch",
          "title": "All test executions must belong to a batch",
          "text": "Every test execution is associated with exactly one test batch, identified by batchId in the TestExecutionTaskPayload. The system enforces that all test executions are part of batches.",
          "kind": "invariant",
          "conceptIds": [
            "test-batch"
          ]
        },
        {
          "id": "rule-test-batch-has-unique-identifier",
          "title": "Test batch has a unique batch identifier",
          "text": "Each test batch is assigned a unique batchId when created, and this identifier is used to associate test execution tasks and results with the batch.",
          "kind": "assumption",
          "conceptIds": [
            "test-batch"
          ]
        },
        {
          "id": "rule-test-batch-can-be-single-test",
          "title": "Test batch may contain a single test case",
          "text": "A test batch may be created for a single test case, allowing even individual test executions to be tracked and analyzed as batches.",
          "kind": "assumption",
          "conceptIds": [
            "test-batch"
          ]
        },
        {
          "id": "rule-eval-pass-has-request-thread-elapsed",
          "title": "Passing evaluation result must include request, thread, and elapsed time",
          "text": "When an evaluation result has status 'pass', it must include requestId, threadId, and elapsedMs.",
          "kind": "invariant",
          "conceptIds": [
            "evaluation-result"
          ]
        },
        {
          "id": "rule-eval-fail-has-request-thread-elapsed-checks",
          "title": "Failing evaluation result must include request, thread, elapsed time, and check results",
          "text": "When an evaluation result has status 'fail', it must include requestId, threadId, elapsedMs, and a non-empty list of checkResults.",
          "kind": "invariant",
          "conceptIds": [
            "evaluation-result"
          ]
        },
        {
          "id": "rule-eval-error-no-request-required",
          "title": "Errored evaluation result may lack template version and request linkage",
          "text": "When an evaluation result has status 'error', templateVersion may be absent and request-related identifiers may not be available, because the template or request may have failed before execution.",
          "kind": "assumption",
          "conceptIds": [
            "evaluation-result"
          ]
        },
        {
          "id": "rule-check-result-status-binary",
          "title": "Check result status is binary",
          "text": "Each check result must have a status of either 'pass' or 'fail'.",
          "kind": "invariant",
          "conceptIds": [
            "evaluation-result"
          ]
        },
        {
          "id": "rule-eval-overall-status-binary",
          "title": "Overall evaluation status is pass or fail for completed executions",
          "text": "For completed test executions represented by TestExecutionResult, overallStatus must be either 'pass' or 'fail'.",
          "kind": "invariant",
          "conceptIds": [
            "evaluation-result"
          ]
        },
        {
          "id": "rule-eval-links-to-testcase-template-user",
          "title": "Evaluation result must link to test case, template, and executor",
          "text": "Every evaluation result must reference the test case (testCaseId), the prompt template (templateId), and the user who executed it (executedBy).",
          "kind": "invariant",
          "conceptIds": [
            "evaluation-result"
          ]
        },
        {
          "id": "rule-check-result-links-to-check-and-eval",
          "title": "Check result must link to check and evaluation result",
          "text": "Every check result must reference the check it executed (checkId) and the evaluation result it belongs to (testRunId).",
          "kind": "invariant",
          "conceptIds": [
            "evaluation-result"
          ]
        },
        {
          "id": "rule-admin-must-be-authenticated",
          "title": "Admin/evaluator must be authenticated to use evaluation tools",
          "text": "An admin/evaluator must be an authenticated user (via Firebase/Google sign-in) before they can access or modify checks, templates, test cases, or view data request threads in the evals UI.",
          "kind": "constraint",
          "conceptIds": [
            "admin-evaluator"
          ]
        },
        {
          "id": "rule-admin-explicit-template-activation",
          "title": "Template changes require explicit activation by admin/evaluator",
          "text": "Saving changes to a template creates a new template version but does not automatically activate it; an admin/evaluator must perform an explicit 'Make Active' action to deploy that version, allowing review and testing before it affects live AI behavior.",
          "kind": "policy",
          "conceptIds": [
            "admin-evaluator"
          ]
        },
        {
          "id": "rule-admin-governs-eval-scope",
          "title": "Admin/evaluator operates only within evaluation and governance scope",
          "text": "The admin/evaluator interacts with checks, templates, test cases, test results, and data request threads for evaluation and governance purposes, and does not originate Slack data requests as part of this role.",
          "kind": "assumption",
          "conceptIds": [
            "admin-evaluator"
          ]
        },
        {
          "id": "rule-data-store-ignore-undefined",
          "title": "Data store ignores undefined properties",
          "text": "When the backend applications create Firestore clients for the data store, they configure them to ignore undefined properties, so undefined fields are not written to stored documents.",
          "kind": "assumption",
          "conceptIds": [
            "data-store"
          ]
        },
        {
          "id": "rule-debug-event-id-format",
          "title": "Debug event identifier format",
          "text": "Each debug event stored in the data store under a thread must have a document ID composed of the event type, an underscore, and the event timestamp (event.type + '_' + event.timestamp).",
          "kind": "invariant",
          "conceptIds": [
            "data-store"
          ]
        },
        {
          "id": "rule-debug-event-location",
          "title": "Debug events stored under thread debugEvents subcollection",
          "text": "Debug events are stored in the data store as documents in a debugEvents subcollection under the corresponding thread document in the threads collection.",
          "kind": "invariant",
          "conceptIds": [
            "data-store"
          ]
        },
        {
          "id": "rule-debug-event-write-non-fatal",
          "title": "Failure to record debug event is non-fatal",
          "text": "If recording a debug event to the data store fails, the system logs the failure but does not propagate the error, allowing the main operation to continue.",
          "kind": "policy",
          "conceptIds": [
            "data-store"
          ]
        },
        {
          "id": "rule-data-store-shared-across-apps",
          "title": "Single shared data store across system components",
          "text": "Worker, ingest, and evals applications are expected to operate against the same logical data store so that threads and their associated debug events are consistently available across components.",
          "kind": "assumption",
          "conceptIds": [
            "data-store"
          ]
        }
      ],
      "lifecycles": [
        {
          "id": "lifecycle-data-request-clarification-and-structuring",
          "subjectConceptId": "data-request",
          "stateConceptIds": [
            "unclassified-request",
            "classified-non-data-request",
            "classified-data-request",
            "awaiting-clarification",
            "ready-for-self-service-or-analyst"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "unclassified-request",
          "terminalStateIds": [
            "classified-non-data-request",
            "ready-for-self-service-or-analyst"
          ]
        },
        {
          "id": "lifecycle-prompt-template-activation",
          "subjectConceptId": "prompt-template",
          "stateConceptIds": [
            "prompt-template-inactive",
            "prompt-template-active"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "prompt-template-inactive",
          "terminalStateIds": [
            "prompt-template-active",
            "prompt-template-inactive"
          ]
        },
        {
          "id": "lifecycle-eval-result",
          "subjectConceptId": "evaluation-result",
          "stateConceptIds": [
            "evaluation-result-pass",
            "evaluation-result-fail",
            "evaluation-result-error"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "evaluation-result-pass",
          "terminalStateIds": [
            "evaluation-result-pass",
            "evaluation-result-fail",
            "evaluation-result-error"
          ]
        }
      ],
      "views": []
    }
  ]
}