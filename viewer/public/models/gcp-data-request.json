{
  "id": "gcp-data-request",
  "name": "Slack-based Data Request and LLM Evaluation System",
  "summary": "A system where Slack conversations become structured data requests that are processed by LLM workflows and evaluated using configurable templates and checks.",
  "description": "This system turns informal Slack threads into formal data requests, routes them through LLM-powered workflows, and evaluates the results using configurable templates and automated checks. Product and ops users manage templates, test cases, and evaluation batches through a web UI, while background workers coordinate Slack interactions, LLM calls, and test execution. Shared runtime libraries provide common abstractions for prompts, templates, checks, debugging, and error handling across ingest, worker, and evaluation apps.",
  "models": [
    {
      "id": "slack-data-request-flow",
      "title": "Slack Data Request Flow",
      "description": "How Slack conversations are interpreted as data requests, enriched with context, and moved through a review and fulfillment workflow using LLMs.",
      "concepts": [
        {
          "id": "slack-user",
          "label": "Slack user",
          "category": "role",
          "description": "A person interacting with the system through Slack, asking questions or making data requests in channels or threads.",
          "aliases": [
            "slack-user",
            "user",
            "userId",
            "createdBy"
          ],
          "notes": "A Slack user is a human (or possibly a Slack identity) interacting with the system via Slack messages, channels, and threads. In this model, the Slack user is primarily identified by a Slack user ID string (e.g., in EventEnvelope.user, TaskPayload.user). The user is the originator of Slack events that trigger data requests or questions, and can also be recorded as the creator of prompt templates or as the user on whose behalf test executions are run."
        },
        {
          "id": "slack-channel",
          "label": "Slack channel",
          "category": "place",
          "description": "A Slack channel or conversation where users post messages that may become data requests.",
          "aliases": [
            "slack-channel",
            "channel",
            "Slack conversation"
          ],
          "notes": "A Slack channel or conversation identified by a Slack channel ID string. It is the location in Slack where users post messages that may become data requests, and where the system posts thread replies and reactions. In the code, `channel` is always treated as an opaque Slack identifier passed to Slack Web API methods and stored in event/task payloads."
        },
        {
          "id": "slack-thread",
          "label": "Slack thread",
          "category": "thing",
          "description": "A threaded Slack conversation that the system tracks as a unit of work, potentially containing a data request and follow-up discussion.",
          "aliases": [
            "slack-thread",
            "thread",
            "root thread",
            "rootTs thread",
            "thread document",
            "thread doc",
            "threads/<root_ts> record"
          ],
          "notes": "A Slack thread is a threaded Slack conversation, identified in this system by its root message timestamp (rootTs). The system treats each Slack thread as a unit of work that may contain a data request and follow-up discussion. For each tracked thread, the system maintains a corresponding record in a 'threads' collection (e.g., threads/<root_ts>) where it stores per-thread flags such as whether the bot has reacted or greeted in that thread. Thread status can be updated (e.g., via updateThreadStatus) to reflect processing progress or state for that unit of work."
        },
        {
          "id": "slack-message-interaction",
          "label": "Slack message interaction",
          "category": "activity",
          "description": "The system’s visible behavior in Slack, such as posting messages, adding or removing reactions, and greeting users in threads.",
          "aliases": [
            "slack-message-interaction",
            "Slack message interaction",
            "outgoing Slack message",
            "Slack thread message",
            "Slack thread greeting",
            "Slack reaction",
            "robot reaction",
            "Slack bot response in thread"
          ],
          "notes": "Slack message interaction is the system’s visible behavior in Slack channels and threads, including posting messages (plain text or block-based) and adding reactions. In this model, interactions are always tied to an existing Slack message thread (identified by rootTs/thread_ts) and a channel. The system may also post a greeting or other automated responses in the thread. Each outgoing Slack message interaction is recorded as a debug event of type 'outgoing_slack_message' for observability."
        },
        {
          "id": "slack-security-verification",
          "label": "Slack request verification",
          "category": "activity",
          "description": "The act of verifying that incoming Slack events are authentic and untampered, using Slack signatures.",
          "aliases": [
            "Slack request verification",
            "Slack signature verification",
            "Slack HMAC verification",
            "Slack event authenticity check",
            "Slack request authenticity verification"
          ],
          "notes": "Slack request verification is the process of confirming that an incoming Slack HTTP request (event, command, or interaction) is authentic and untampered by validating the Slack-provided signature against a locally computed HMAC using the shared signing secret. It also includes rejecting requests whose timestamps are too far from the current time to mitigate replay attacks."
        },
        {
          "id": "data-request",
          "label": "Data request",
          "category": "thing",
          "description": "A structured representation of a user’s request for data or analysis, derived from Slack threads and processed by LLM workflows.",
          "aliases": [
            "data-request",
            "data request",
            "request",
            "Slack data request",
            "thread",
            "data request thread"
          ],
          "notes": "A Data Request is a structured representation of a user’s need for data or analysis, originating from a Slack thread. It is first detected/classified from Slack messages (fullThread + specificMessage) as being a data request, then tracked as a Firestore thread document with status and artifacts. Over time, LLM workflows iterate on the request, refining its text, asking clarifying questions, and optionally generating self-service instructions or a direct answer when the user’s need is purely about data definitions or structures rather than actual data values."
        },
        {
          "id": "data-request-review",
          "label": "Data request review",
          "category": "activity",
          "description": "The process of having an LLM (and potentially humans) review a data request for clarity, feasibility, and compliance before fulfillment.",
          "aliases": [
            "data request review",
            "review data request",
            "LLM review",
            "request review",
            "review result"
          ],
          "notes": "Data request review is the process where an LLM, acting as a Slackbot intermediary between a user and the data team, analyzes an incoming data request to make it clear, well-documented, and unambiguous before fulfillment. The review produces a structured set of artifacts: (1) a refined, well-documented version of the request; (2) clarifying questions for the requester when needed; (3) step-by-step instructions for self-service in Looker when feasible; and (4) a direct answer when the user is asking a meta question about field meanings, business terminology, or data structures rather than actual data values. The review may be iterated based on user responses to clarifying questions, and different artifacts are selectively shown to the user depending on whether clarifying questions exist."
        },
        {
          "id": "thread-deduplication",
          "label": "Thread deduplication",
          "category": "activity",
          "description": "Ensuring that each Slack thread or event is processed only once, preventing duplicate work or repeated responses.",
          "aliases": [
            "thread deduplication",
            "event deduplication",
            "idempotency",
            "idempotent processing",
            "duplicate delivery protection",
            "event seen once",
            "markEventSeenOnce"
          ],
          "notes": "Thread deduplication ensures that each Slack-originated event (e.g., a message or thread event) is processed at most once within a bounded time window. The system records an event identifier in a persistent store with a time-to-live (TTL). If an event with the same identifier is received again while the record exists, it is treated as a duplicate and is not processed again. This provides idempotent behavior for Slack event handling and prevents duplicate work or repeated responses when Slack or the infrastructure delivers the same event multiple times."
        },
        {
          "id": "ingest-work-enqueueing",
          "label": "Ingest work enqueueing",
          "category": "activity",
          "description": "Creating background jobs from Slack events or threads so that downstream workers can process data requests asynchronously.",
          "aliases": [
            "ingest-work-enqueueing",
            "enqueue work",
            "enqueueWork",
            "task enqueueing",
            "background job enqueueing",
            "Cloud Tasks enqueue",
            "LLM task enqueue"
          ],
          "notes": "Ingest work enqueueing is the act of turning a Slack-derived data request (captured as a TaskPayload) into an asynchronous background job by placing it onto a task queue. The enqueueing step prepares a task that will be delivered via HTTP POST to a worker endpoint (/tasks/llm), carrying the serialized TaskPayload. It is part of the ingest flow that reacts to Slack events or threads and hands off processing to downstream workers without blocking the Slack interaction."
        },
        {
          "id": "thread-status",
          "label": "Thread status",
          "category": "state",
          "description": "The current processing state of a Slack thread (e.g., new, classified, under review, completed) as tracked by the system.",
          "aliases": [
            "thread status",
            "status",
            "thread processing state"
          ],
          "notes": "Thread status represents the current processing state of a Slack thread (identified by its root timestamp/rootTs) as tracked by the system. It is updated via operations like updateThreadStatus(rootTs, status) and is expected to be persisted (e.g., in Firestore). Typical values, implied by the description, include states such as new, classified, under review, and completed, but the specific enumeration is not defined in the provided code."
        }
      ],
      "relationships": [
        {
          "id": "rel-slack-user-sends-slack-message",
          "from": "slack-user",
          "to": "slack-message",
          "phrase": "sends",
          "category": "causes",
          "description": "A Slack user sends a Slack message (event text) in a channel or thread, which is represented in the system by EventEnvelope fields such as channel, ts, threadTs, user, and text."
        },
        {
          "id": "rel-slack-user-initiates-task",
          "from": "slack-user",
          "to": "task",
          "phrase": "initiates",
          "category": "causes",
          "description": "A Slack user initiates a task in the system by posting a message that is transformed into a TaskPayload, including the originating user and message context."
        },
        {
          "id": "rel-slack-user-associated-with-taskpayload",
          "from": "slack-user",
          "to": "task-payload",
          "phrase": "is recorded in",
          "category": "represents",
          "description": "A Slack user is recorded in a TaskPayload via the user field, linking the task back to the Slack identity that triggered it."
        },
        {
          "id": "rel-slack-user-associated-with-eventenvelope",
          "from": "slack-user",
          "to": "event-envelope",
          "phrase": "is referenced by",
          "category": "represents",
          "description": "A Slack user is referenced in an EventEnvelope via the user field, representing the Slack identity that generated the incoming Slack event."
        },
        {
          "id": "rel-slack-user-creates-prompt-template",
          "from": "slack-user",
          "to": "prompt-template",
          "phrase": "creates",
          "category": "causes",
          "description": "A Slack user can create a prompt template, and is recorded as the creator via the createdBy field on PromptTemplate."
        },
        {
          "id": "rel-slack-user-owns-test-execution",
          "from": "slack-user",
          "to": "test-execution-task",
          "phrase": "is the subject of",
          "category": "represents",
          "description": "A Slack user is represented as userId in TestExecutionTaskPayload, indicating the user on whose behalf a test execution task is run."
        },
        {
          "id": "rel-slack-user-receives-slack-responses",
          "from": "slack-user",
          "to": "slack-message",
          "phrase": "receives responses as",
          "category": "uses",
          "description": "A Slack user receives system responses as Slack thread messages posted via chat.postMessage in the same channel and thread where the user initiated the interaction."
        },
        {
          "id": "rel-slack-channel-has-events",
          "from": "slack-channel",
          "to": "slack-event-envelope",
          "phrase": "has",
          "category": "part_of",
          "description": "Each Slack event envelope includes a `channel` field indicating the Slack channel or conversation where the event (message, reaction, etc.) occurred."
        },
        {
          "id": "rel-slack-channel-receives-data-requests",
          "from": "slack-channel",
          "to": "data-request-message",
          "phrase": "contains",
          "category": "part_of",
          "description": "A Slack channel contains user messages, some of which are interpreted by the system as data requests within the Slack Data Request Flow."
        },
        {
          "id": "rel-slack-channel-has-threads",
          "from": "slack-channel",
          "to": "slack-thread",
          "phrase": "has",
          "category": "part_of",
          "description": "A Slack channel has message threads, identified by a root message timestamp (`rootTs` or `threadTs`), where the system posts replies related to a particular data request."
        },
        {
          "id": "rel-slack-channel-receives-robot-reaction",
          "from": "slack-channel",
          "to": "robot-reaction",
          "phrase": "receives",
          "category": "other",
          "description": "The system adds a `robot_face` reaction in a specific Slack channel on a root message timestamp to signal automated handling of a message or data request."
        },
        {
          "id": "rel-slack-channel-uses-slack-api",
          "from": "slack-channel",
          "to": "slack-web-api-call",
          "phrase": "is targeted by",
          "category": "uses",
          "description": "Slack Web API calls such as `chat.postMessage` and `reactions.add` target a specific Slack channel, identified by its channel ID."
        },
        {
          "id": "rel-slack-channel-has-outgoing-debug-events",
          "from": "slack-channel",
          "to": "debug-event",
          "phrase": "is recorded in",
          "category": "other",
          "description": "When the system posts a message to a thread in a Slack channel, it records a debug event that includes the `channel` and `threadTs` to trace outgoing Slack interactions."
        },
        {
          "id": "rel-slack-channel-in-task-payload",
          "from": "slack-channel",
          "to": "task-payload",
          "phrase": "is referenced by",
          "category": "uses",
          "description": "Background tasks that process Slack-originated work include the `channel` field in their payloads to know where to post follow-up messages or reactions."
        },
        {
          "id": "rel-thread-has-rootTs",
          "from": "slack-thread",
          "to": "root-timestamp",
          "phrase": "is identified by",
          "category": "represents",
          "description": "Each Slack thread is uniquely identified in the system by the timestamp of its root message (rootTs), which is used as the key for thread-related operations and storage."
        },
        {
          "id": "rel-thread-has-thread-flags",
          "from": "slack-thread",
          "to": "thread-flags",
          "phrase": "has",
          "category": "part_of",
          "description": "Each Slack thread has associated per-thread flags (e.g., reacted, greeted) that describe what automated actions the system has already taken in that thread."
        },
        {
          "id": "rel-thread-stored-in-threads-collection",
          "from": "slack-thread",
          "to": "threads-collection",
          "phrase": "is stored in",
          "category": "part_of",
          "description": "Each Slack thread tracked by the system corresponds to a document in the 'threads' collection (e.g., threads/<root_ts>) where its flags and status are persisted."
        },
        {
          "id": "rel-thread-uses-channel",
          "from": "slack-thread",
          "to": "slack-channel",
          "phrase": "occurs in",
          "category": "uses",
          "description": "A Slack thread occurs within a specific Slack channel, referenced by the channel identifier in events and task payloads."
        },
        {
          "id": "rel-thread-involves-user",
          "from": "slack-thread",
          "to": "slack-user",
          "phrase": "involves",
          "category": "uses",
          "description": "A Slack thread involves one or more Slack users; the system may fetch user info for the user who initiated or participates in the thread."
        },
        {
          "id": "rel-thread-has-messages",
          "from": "slack-thread",
          "to": "slack-message",
          "phrase": "contains",
          "category": "part_of",
          "description": "A Slack thread contains one root message and zero or more reply messages, each identified by its own Slack timestamp (ts)."
        },
        {
          "id": "rel-thread-referenced-by-task-payload",
          "from": "task-payload",
          "to": "slack-thread",
          "phrase": "targets",
          "category": "uses",
          "description": "A TaskPayload references a Slack thread via rootTs and channel, indicating that the task operates on that specific thread as a unit of work."
        },
        {
          "id": "rel-thread-referenced-by-event-envelope",
          "from": "event-envelope",
          "to": "slack-thread",
          "phrase": "may belong to",
          "category": "uses",
          "description": "An EventEnvelope may reference a Slack thread via threadTs, indicating that the Slack event is part of a particular thread."
        },
        {
          "id": "rel-thread-has-status",
          "from": "slack-thread",
          "to": "thread-status",
          "phrase": "has",
          "category": "part_of",
          "description": "A Slack thread has a status value that can be updated (e.g., via updateThreadStatus) to reflect the processing or handling state of that thread in the system."
        },
        {
          "id": "rel-slack-interaction-uses-channel",
          "from": "slack-message-interaction",
          "to": "slack-channel",
          "phrase": "occurs in",
          "category": "uses",
          "description": "Each Slack message interaction occurs in a specific Slack channel identified by its channel ID."
        },
        {
          "id": "rel-slack-interaction-uses-thread",
          "from": "slack-message-interaction",
          "to": "slack-thread",
          "phrase": "targets",
          "category": "uses",
          "description": "Each Slack message interaction targets a specific Slack thread, identified by the root message timestamp (rootTs/thread_ts)."
        },
        {
          "id": "rel-slack-interaction-includes-reaction",
          "from": "slack-message-interaction",
          "to": "slack-reaction",
          "phrase": "may include",
          "category": "part_of",
          "description": "A Slack message interaction may include adding a reaction (such as the 'robot_face' emoji) to the root message of a thread."
        },
        {
          "id": "rel-slack-interaction-includes-text-message",
          "from": "slack-message-interaction",
          "to": "slack-thread-message",
          "phrase": "may post",
          "category": "part_of",
          "description": "A Slack message interaction may post a text message into a Slack thread using chat.postMessage with a text body."
        },
        {
          "id": "rel-slack-interaction-includes-block-message",
          "from": "slack-message-interaction",
          "to": "slack-block-message",
          "phrase": "may post",
          "category": "part_of",
          "description": "A Slack message interaction may post a block-based message into a Slack thread using chat.postMessage with blocks."
        },
        {
          "id": "rel-slack-interaction-includes-greeting",
          "from": "slack-message-interaction",
          "to": "slack-thread-greeting",
          "phrase": "may post",
          "category": "part_of",
          "description": "A Slack message interaction may post a greeting message into a Slack thread to acknowledge or welcome the user."
        },
        {
          "id": "rel-slack-interaction-uses-slack-api",
          "from": "slack-message-interaction",
          "to": "slack-web-api-call",
          "phrase": "is realized by",
          "category": "uses",
          "description": "Each Slack message interaction is realized by one or more Slack Web API calls such as reactions.add or chat.postMessage."
        },
        {
          "id": "rel-slack-interaction-records-debug-event",
          "from": "slack-message-interaction",
          "to": "debug-event",
          "phrase": "records",
          "category": "causes",
          "description": "When the system posts a message to a Slack thread, it records a corresponding debug event of type 'outgoing_slack_message' for that thread."
        },
        {
          "id": "rel-debug-event-refers-to-thread",
          "from": "debug-event",
          "to": "slack-thread",
          "phrase": "refers to",
          "category": "represents",
          "description": "The outgoing_slack_message debug event refers to the Slack thread via the rootTs/threadTs it records."
        },
        {
          "id": "rel-slack-verification-uses-signature",
          "from": "slack-security-verification",
          "to": "slack-request-signature",
          "phrase": "uses",
          "category": "uses",
          "description": "Slack request verification uses the Slack-provided request signature value to compare against a locally computed expected signature."
        },
        {
          "id": "rel-slack-verification-uses-timestamp",
          "from": "slack-security-verification",
          "to": "slack-request-timestamp",
          "phrase": "uses",
          "category": "uses",
          "description": "Slack request verification uses the Slack-provided timestamp to both construct the HMAC base string and to detect stale or replayed requests."
        },
        {
          "id": "rel-slack-verification-uses-raw-body",
          "from": "slack-security-verification",
          "to": "slack-request-raw-body",
          "phrase": "uses",
          "category": "uses",
          "description": "Slack request verification uses the exact raw HTTP request body as part of the HMAC base string to ensure the payload has not been tampered with."
        },
        {
          "id": "rel-slack-verification-uses-signing-secret",
          "from": "slack-security-verification",
          "to": "slack-signing-secret",
          "phrase": "uses",
          "category": "uses",
          "description": "Slack request verification uses the shared Slack signing secret to compute the expected HMAC signature."
        },
        {
          "id": "rel-slack-verification-prevents-replay",
          "from": "slack-security-verification",
          "to": "slack-request-replay-attack",
          "phrase": "prevents",
          "category": "prevents",
          "description": "Slack request verification prevents replay attacks by rejecting requests whose timestamps are outside the allowed time window."
        },
        {
          "id": "rel-slack-verification-enables-processing",
          "from": "slack-security-verification",
          "to": "slack-event-processing",
          "phrase": "enables",
          "category": "enables",
          "description": "Successful Slack request verification enables subsequent processing of the Slack event or command within the Slack Data Request Flow."
        },
        {
          "id": "rel-data-request-originates-from-slack-thread",
          "from": "data-request",
          "to": "slack-thread",
          "phrase": "originates from",
          "category": "represents",
          "description": "A Data Request represents the content and intent of a Slack thread where a user asks for data or analysis. The full Slack thread and a specific message are used as inputs to determine whether the conversation is a data request."
        },
        {
          "id": "rel-data-request-has-requester",
          "from": "data-request",
          "to": "requester",
          "phrase": "has requester",
          "category": "part_of",
          "description": "A Data Request is associated with a requester, identified by user ID, name, and handle, derived from the Slack user who started or owns the thread."
        },
        {
          "id": "rel-data-request-occurs-in-channel",
          "from": "data-request",
          "to": "slack-channel",
          "phrase": "occurs in",
          "category": "part_of",
          "description": "Each Data Request occurs in a specific Slack channel, recorded as the channel and channelName on the thread document."
        },
        {
          "id": "rel-data-request-has-artifacts",
          "from": "data-request",
          "to": "data-request-artifacts",
          "phrase": "has",
          "category": "part_of",
          "description": "A Data Request has associated artifacts that capture the current structured understanding of the request, including the refined request text, clarifying questions, and step-by-step self-service instructions."
        },
        {
          "id": "rel-data-request-artifacts-include-request",
          "from": "data-request-artifacts",
          "to": "structured-request-text",
          "phrase": "include",
          "category": "part_of",
          "description": "The artifacts of a Data Request may include a structured request text that summarizes what data or analysis is being asked for."
        },
        {
          "id": "rel-data-request-artifacts-include-clarifying-questions",
          "from": "data-request-artifacts",
          "to": "clarifying-questions",
          "phrase": "include",
          "category": "part_of",
          "description": "The artifacts of a Data Request may include clarifying questions that need to be answered by the requester to make the request actionable."
        },
        {
          "id": "rel-data-request-artifacts-include-self-service-steps",
          "from": "data-request-artifacts",
          "to": "self-service-instructions",
          "phrase": "include",
          "category": "part_of",
          "description": "The artifacts of a Data Request may include step-by-step self-service instructions (e.g., Looker instructions) that allow the requester to fulfill the request themselves."
        },
        {
          "id": "rel-data-request-may-have-direct-answer",
          "from": "data-request",
          "to": "direct-answer",
          "phrase": "may have",
          "category": "part_of",
          "description": "For meta questions about field meanings, business terminology, or data structures, a Data Request may be satisfied by a direct answer instead of or in addition to data retrieval."
        },
        {
          "id": "rel-data-request-is-classified-by-llm",
          "from": "data-request",
          "to": "llm-classification-workflow",
          "phrase": "is classified by",
          "category": "uses",
          "description": "Whether a Slack thread constitutes a Data Request is determined by an LLM classification workflow that produces a verdict with isDataRequest, reason, and confidence."
        },
        {
          "id": "rel-data-request-is-iterated-by-llm",
          "from": "data-request",
          "to": "llm-iteration-workflow",
          "phrase": "is iterated by",
          "category": "uses",
          "description": "A Data Request is refined over time by an LLM iteration workflow that updates the request text, clarifying questions, self-service instructions, and possibly a direct answer as the Slack thread evolves."
        },
        {
          "id": "rel-data-request-has-status",
          "from": "data-request",
          "to": "data-request-status",
          "phrase": "has",
          "category": "part_of",
          "description": "Each Data Request has a status (processing, accepted, rejected, or unhandled) that reflects how the system has handled the request."
        },
        {
          "id": "rel-data-request-has-confidence",
          "from": "data-request",
          "to": "classification-confidence",
          "phrase": "has",
          "category": "part_of",
          "description": "A Data Request carries a confidence score from the LLM classification indicating how likely the thread is to be a true data request."
        },
        {
          "id": "rel-data-request-may-have-rejection-reason",
          "from": "data-request",
          "to": "rejection-reason",
          "phrase": "may have",
          "category": "part_of",
          "description": "If a Data Request is rejected, a rejection reason is stored explaining why it was not accepted as a valid or actionable data request."
        },
        {
          "id": "rel-data-request-precedes-debug-events",
          "from": "data-request",
          "to": "debug-event",
          "phrase": "generates",
          "category": "precedes",
          "description": "Handling a Data Request generates debug events such as LLM classification events and timing metrics, which are associated with the underlying thread."
        },
        {
          "id": "rel-data-request-review-uses-llm",
          "from": "data-request-review",
          "to": "llm",
          "phrase": "is performed by",
          "category": "uses",
          "description": "Data request review is performed by an LLM acting as a Slackbot AI assistant that intermediates between the requester and the data team."
        },
        {
          "id": "rel-data-request-review-uses-data-request",
          "from": "data-request-review",
          "to": "data-request",
          "phrase": "analyzes",
          "category": "uses",
          "description": "Data request review analyzes an incoming data request message from a Slack user to make it clear and well documented."
        },
        {
          "id": "rel-data-request-review-produces-refined-request",
          "from": "data-request-review",
          "to": "refined-data-request",
          "phrase": "produces",
          "category": "causes",
          "description": "Data request review produces a refined, well-documented version of the original data request intended to be simple for an analyst to fulfill."
        },
        {
          "id": "rel-data-request-review-produces-clarifying-questions",
          "from": "data-request-review",
          "to": "clarifying-questions",
          "phrase": "produces",
          "category": "causes",
          "description": "Data request review produces clarifying questions when the original request is ambiguous or incomplete; these questions are shown to the user."
        },
        {
          "id": "rel-data-request-review-produces-step-instructions",
          "from": "data-request-review",
          "to": "self-service-instructions",
          "phrase": "produces",
          "category": "causes",
          "description": "Data request review produces step-by-step instructions describing which Looker explores to use and how to obtain the answer when self-service is deemed sufficient."
        },
        {
          "id": "rel-data-request-review-produces-direct-answer",
          "from": "data-request-review",
          "to": "direct-answer",
          "phrase": "produces",
          "category": "causes",
          "description": "Data request review produces a direct answer when the user is asking a meta question about field meanings, business terminology, or data structures rather than actual data values."
        },
        {
          "id": "rel-data-request-review-precedes-analyst-fulfillment",
          "from": "data-request-review",
          "to": "analyst-fulfillment",
          "phrase": "precedes",
          "category": "precedes",
          "description": "Data request review occurs before an analyst fulfills the data request, ensuring the request is clear and feasible."
        },
        {
          "id": "rel-data-request-review-enables-self-service",
          "from": "data-request-review",
          "to": "self-service-data-access",
          "phrase": "enables",
          "category": "enables",
          "description": "By generating step-by-step Looker instructions, data request review enables users to self-serve some data needs instead of relying on analysts."
        },
        {
          "id": "rel-data-request-review-uses-template",
          "from": "data-request-review",
          "to": "prompt-template",
          "phrase": "uses",
          "category": "uses",
          "description": "Data request review uses a prompt template that defines the assistant's role, goals, and output structure for reviewing data requests."
        },
        {
          "id": "rel-thread-dedupe-uses-event-id",
          "from": "thread-deduplication",
          "to": "slack-event-id",
          "phrase": "uses",
          "category": "uses",
          "description": "Thread deduplication uses the Slack event identifier as the key for determining whether an event has already been processed."
        },
        {
          "id": "rel-thread-dedupe-uses-event-record",
          "from": "thread-deduplication",
          "to": "event-deduplication-record",
          "phrase": "creates",
          "category": "causes",
          "description": "Thread deduplication creates an event deduplication record when it sees an event for the first time, marking that event as processed within the deduplication window."
        },
        {
          "id": "rel-thread-dedupe-prevents-duplicate-processing",
          "from": "thread-deduplication",
          "to": "event-processing",
          "phrase": "prevents duplicate",
          "category": "prevents",
          "description": "Thread deduplication prevents duplicate event processing by signaling when an incoming event has already been seen within the TTL window."
        },
        {
          "id": "rel-thread-dedupe-enables-idempotent-flow",
          "from": "thread-deduplication",
          "to": "slack-data-request-flow",
          "phrase": "enables idempotent handling in",
          "category": "enables",
          "description": "Thread deduplication enables idempotent handling of Slack events within the Slack Data Request Flow, ensuring that each logical event in the flow is acted on at most once."
        },
        {
          "id": "rel-event-record-has-ttl",
          "from": "event-deduplication-record",
          "to": "deduplication-time-window",
          "phrase": "has",
          "category": "part_of",
          "description": "Each event deduplication record has an associated expiration time defining the deduplication time window during which duplicates are suppressed."
        },
        {
          "id": "rel-ingest-enqueue-uses-taskpayload",
          "from": "ingest-work-enqueueing",
          "to": "task-payload",
          "phrase": "uses",
          "category": "uses",
          "description": "Ingest work enqueueing uses TaskPayload as the structured description of the work derived from Slack events or threads."
        },
        {
          "id": "rel-ingest-enqueue-targets-worker",
          "from": "ingest-work-enqueueing",
          "to": "llm-worker-task-endpoint",
          "phrase": "targets",
          "category": "uses",
          "description": "Ingest work enqueueing targets the LLM worker HTTP endpoint (/tasks/llm) as the consumer of the enqueued background job."
        },
        {
          "id": "rel-ingest-enqueue-part-of-ingest-flow",
          "from": "ingest-work-enqueueing",
          "to": "slack-data-request-ingest-flow",
          "phrase": "is part of",
          "category": "part_of",
          "description": "Ingest work enqueueing is part of the Slack data request ingest flow that reacts to Slack events and processes data requests asynchronously."
        },
        {
          "id": "rel-ingest-enqueue-precedes-worker-processing",
          "from": "ingest-work-enqueueing",
          "to": "background-worker-processing",
          "phrase": "precedes",
          "category": "precedes",
          "description": "Ingest work enqueueing precedes background worker processing of the data request represented by the TaskPayload."
        },
        {
          "id": "rel-ingest-enqueue-uses-task-queue",
          "from": "ingest-work-enqueueing",
          "to": "task-queue",
          "phrase": "uses",
          "category": "uses",
          "description": "Ingest work enqueueing uses a configured task queue (identified by project, region, and queue name) to store and dispatch background jobs."
        },
        {
          "id": "rel-ingest-enqueue-represents-slack-request",
          "from": "ingest-work-enqueueing",
          "to": "slack-data-request",
          "phrase": "represents",
          "category": "represents",
          "description": "Each instance of ingest work enqueueing represents a Slack-based data request or related message thread as a queued background job."
        },
        {
          "id": "rel-thread-status-belongs-to-thread",
          "from": "thread-status",
          "to": "slack-thread",
          "phrase": "belongs to",
          "category": "part_of",
          "description": "Each thread status is associated with a specific Slack thread, identified by its root timestamp (rootTs)."
        },
        {
          "id": "rel-thread-status-updated-by-operation",
          "from": "thread-status",
          "to": "thread-status-update-operation",
          "phrase": "is updated by",
          "category": "uses",
          "description": "Thread status is updated by operations such as updateThreadStatus, which take a root thread timestamp and a status value and persist the new state."
        },
        {
          "id": "rel-thread-status-represents-processing-state",
          "from": "thread-status",
          "to": "thread-processing-state",
          "phrase": "represents",
          "category": "represents",
          "description": "Thread status represents the current processing state of the system's handling of a Slack thread (e.g., whether it is newly received, classified, under review, or completed)."
        }
      ],
      "rules": [
        {
          "id": "rule-slack-user-optional-on-event",
          "title": "Slack user may be absent on some events",
          "text": "For an EventEnvelope, the user field is optional, meaning some Slack events processed by the system may not be associated with a specific Slack user (e.g., system or bot events).",
          "kind": "assumption",
          "conceptIds": [
            "slack-user"
          ]
        },
        {
          "id": "rule-slack-user-optional-on-taskpayload",
          "title": "Slack user may be absent on some tasks",
          "text": "For a TaskPayload, the user field is optional, so certain tasks may not be directly attributable to a specific Slack user, even though they are associated with a Slack channel and message timestamps.",
          "kind": "assumption",
          "conceptIds": [
            "slack-user"
          ]
        },
        {
          "id": "rule-slack-user-required-on-testexecutiontask",
          "title": "Slack user is required for test execution tasks",
          "text": "For a TestExecutionTaskPayload, userId is required, indicating that every test execution task must be associated with a specific user identity.",
          "kind": "constraint",
          "conceptIds": [
            "slack-user"
          ]
        },
        {
          "id": "rule-slack-user-identified-by-slack-id-string",
          "title": "Slack user is identified by a Slack user ID string",
          "text": "Within the system, a Slack user is represented by a string identifier (e.g., EventEnvelope.user, TaskPayload.user, TestExecutionTaskPayload.userId, PromptTemplate.createdBy) that corresponds to the Slack user or internal user identity.",
          "kind": "assumption",
          "conceptIds": [
            "slack-user"
          ]
        },
        {
          "id": "rule-slack-channel-id-required-for-api",
          "title": "Slack channel identifier is required for Slack API operations",
          "text": "Any operation that posts a message or adds a reaction in Slack must include a valid `channel` identifier so that Slack can route the action to the correct channel or conversation.",
          "kind": "constraint",
          "conceptIds": [
            "slack-channel"
          ]
        },
        {
          "id": "rule-slack-channel-id-persists-in-events-and-tasks",
          "title": "Slack channel identifier is preserved across events and tasks",
          "text": "When a Slack event is received and transformed into internal task payloads or debug events, the `channel` identifier from the original event must be preserved so that subsequent automated responses occur in the same Slack channel.",
          "kind": "invariant",
          "conceptIds": [
            "slack-channel"
          ]
        },
        {
          "id": "rule-thread-identified-by-rootTs",
          "title": "Slack thread must be identified by rootTs",
          "text": "Every Slack thread tracked by the system must have a root message timestamp (rootTs) that is used as its unique identifier for storage and processing.",
          "kind": "constraint",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-thread-flags-set-once",
          "title": "Per-thread flags are only set once per flag",
          "text": "Per-thread flags such as 'reacted' and 'greeted' are managed so that each flag is only set once for a given Slack thread, preventing repeated bot reactions or greetings in the same thread.",
          "kind": "policy",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-thread-flags-stored-in-threads-collection",
          "title": "Thread flags are stored in threads collection",
          "text": "For each Slack thread that the system tracks, its per-thread flags and related metadata must be stored in a document under the 'threads' collection, keyed by the thread's rootTs.",
          "kind": "invariant",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-thread-status-updatable",
          "title": "Slack thread status can be updated",
          "text": "The system must support updating the status of a Slack thread, allowing downstream workers to record progress or state changes for that thread as a unit of work.",
          "kind": "assumption",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-slack-interaction-requires-bot-token",
          "title": "Slack interactions require a bot token",
          "text": "A Slack message interaction that calls the Slack Web API must have a valid Slack bot token configured; otherwise the interaction cannot proceed.",
          "kind": "constraint",
          "conceptIds": [
            "slack-message-interaction"
          ]
        },
        {
          "id": "rule-slack-interaction-identifies-thread",
          "title": "Slack interactions are tied to a thread",
          "text": "Each Slack message interaction that posts a message or adds a reaction must specify the root message timestamp (rootTs/thread_ts) to identify the Slack thread it belongs to.",
          "kind": "invariant",
          "conceptIds": [
            "slack-message-interaction"
          ]
        },
        {
          "id": "rule-slack-reaction-robot-face",
          "title": "Standard robot reaction",
          "text": "When the system adds a reaction as part of a Slack message interaction, it uses the 'robot_face' emoji to mark the root message.",
          "kind": "policy",
          "conceptIds": [
            "slack-message-interaction"
          ]
        },
        {
          "id": "rule-slack-interaction-records-outgoing-message",
          "title": "Outgoing Slack messages are logged as debug events",
          "text": "Whenever the system posts a text message to a Slack thread, it should attempt to record a debug event of type 'outgoing_slack_message' containing the channel, threadTs, text, and messageType.",
          "kind": "policy",
          "conceptIds": [
            "slack-message-interaction"
          ]
        },
        {
          "id": "rule-slack-interaction-ignores-already-reacted-error",
          "title": "Already-reacted errors do not invalidate the interaction",
          "text": "If a Slack message interaction that adds a reaction receives an 'already_reacted' error from Slack, the interaction is still considered successful and should not be treated as a failure.",
          "kind": "assumption",
          "conceptIds": [
            "slack-message-interaction"
          ]
        },
        {
          "id": "rule-slack-verification-requires-inputs",
          "title": "Slack verification requires all security inputs",
          "text": "Slack request verification must have a non-empty signature, timestamp, raw body, and signing secret; otherwise the verification fails.",
          "kind": "constraint",
          "conceptIds": [
            "slack-security-verification"
          ]
        },
        {
          "id": "rule-slack-verification-timestamp-finite",
          "title": "Slack verification requires a valid numeric timestamp",
          "text": "Slack request verification must treat the provided timestamp as a finite numeric value; if the timestamp cannot be parsed as a finite number, verification fails.",
          "kind": "constraint",
          "conceptIds": [
            "slack-security-verification"
          ]
        },
        {
          "id": "rule-slack-verification-time-window",
          "title": "Slack verification enforces a 5-minute time window",
          "text": "Slack request verification must reject requests whose timestamp differs from the current server time by more than five minutes, in order to mitigate replay attacks.",
          "kind": "policy",
          "conceptIds": [
            "slack-security-verification"
          ]
        },
        {
          "id": "rule-slack-verification-hmac-match",
          "title": "Slack verification requires HMAC signature match",
          "text": "Slack request verification must compute an HMAC-SHA256 signature over the base string 'v0:{timestamp}:{rawBody}' using the Slack signing secret and require that the resulting 'v0={hmac}' value exactly matches the provided Slack signature; otherwise the verification fails.",
          "kind": "invariant",
          "conceptIds": [
            "slack-security-verification"
          ]
        },
        {
          "id": "rule-slack-verification-constant-time-compare",
          "title": "Slack verification uses constant-time comparison",
          "text": "Slack request verification must compare the provided signature and the expected signature using a constant-time comparison to avoid leaking timing information that could aid attackers.",
          "kind": "policy",
          "conceptIds": [
            "slack-security-verification"
          ]
        },
        {
          "id": "rule-data-request-must-originate-from-thread",
          "title": "Data Request must originate from a Slack thread",
          "text": "A Data Request is only created or recognized in the system when there is an associated Slack thread, including the full thread content and at least one specific message.",
          "kind": "assumption",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-data-request-classification-required",
          "title": "Data Request requires LLM classification",
          "text": "Whether a Slack thread is treated as a Data Request is determined by an LLM classification verdict that includes isDataRequest, reason, and confidence.",
          "kind": "invariant",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-data-request-has-single-status",
          "title": "Data Request has a single status at any time",
          "text": "At any point in time, a Data Request has at most one status value from the set {processing, accepted, rejected, unhandled}.",
          "kind": "constraint",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-clarifying-questions-removed-when-answered",
          "title": "Clarifying questions are removed when fully answered",
          "text": "During iteration on a Data Request, if clarifying questions are fully answered in the Slack thread, they are removed from the artifacts.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-direct-answer-only-for-meta-questions",
          "title": "Direct answers only for meta questions",
          "text": "A Data Request may include a direct answer only when the user’s question is about field meanings, business terminology, or data structures, and not about actual data values, metrics, or counts. If the question touches on actual data, it must be treated as a data request with request and/or self-service instructions instead of a direct answer.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-self-service-when-possible",
          "title": "Provide self-service instructions when possible",
          "text": "If a Data Request can be fulfilled by the requester via self-service tools (such as Looker), the artifacts should include step-by-step self-service instructions instead of or in addition to other fulfillment paths.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-data-request-review-must-produce-structured-output",
          "title": "Review must produce all structured artifacts",
          "text": "Each data request review must produce a structured result containing a refined request, clarifying questions, step-by-step instructions, and a direct answer field, even if some of these are empty or not shown to the user immediately.",
          "kind": "invariant",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-data-request-review-clarifying-questions-priority",
          "title": "Clarifying questions take display priority",
          "text": "If a data request review produces any clarifying questions, only those clarifying questions are shown to the user at that stage; other artifacts from the review are withheld for later use.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-data-request-review-no-clarifying-questions-display-instructions-or-request",
          "title": "When no clarifying questions, show instructions or refined request",
          "text": "If a data request review produces no clarifying questions, the system shows the user the step-by-step self-service instructions when available; if no such instructions are provided, the system shows the refined, well-documented request instead.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-data-request-review-direct-answer-scope",
          "title": "Direct answers limited to meta questions",
          "text": "Direct answers produced by a data request review must only address meta questions about field meanings, business terminology, or data structures, and must not provide actual data values, metrics, or numbers.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-data-request-review-assumptions-must-be-explicit",
          "title": "Assumptions must be called out explicitly",
          "text": "When a data request review makes assumptions to clarify an ambiguous request, those assumptions must be explicitly called out so they can be corrected if incorrect.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-thread-dedupe-unique-event-id",
          "title": "Event ID Uniqueness Within Deduplication Window",
          "text": "Within the deduplication time window, a given event identifier may be recorded only once; any subsequent attempt to record the same event identifier is treated as a duplicate and must not trigger re-processing.",
          "kind": "invariant",
          "conceptIds": [
            "thread-deduplication"
          ]
        },
        {
          "id": "rule-thread-dedupe-bounded-by-ttl",
          "title": "Deduplication Is Bounded by TTL",
          "text": "Thread deduplication only guarantees at-most-once processing for an event while its deduplication record remains unexpired; after the TTL elapses and the record expires, the same event identifier may be treated as new again.",
          "kind": "assumption",
          "conceptIds": [
            "thread-deduplication"
          ]
        },
        {
          "id": "rule-thread-dedupe-first-writer-wins",
          "title": "First Writer Wins for Event Processing",
          "text": "When multiple deliveries of the same event occur concurrently, only the first successful creation of the deduplication record is allowed to proceed with processing; later attempts must be treated as duplicates and must not re-trigger processing.",
          "kind": "constraint",
          "conceptIds": [
            "thread-deduplication"
          ]
        },
        {
          "id": "rule-ingest-enqueue-requires-config",
          "title": "Enqueueing requires complete task configuration",
          "text": "Ingest work enqueueing must not proceed unless the worker URL, project ID, region, and task queue name are all configured; otherwise the enqueue operation fails.",
          "kind": "constraint",
          "conceptIds": [
            "ingest-work-enqueueing"
          ]
        },
        {
          "id": "rule-ingest-enqueue-payload-required",
          "title": "Enqueueing requires a TaskPayload",
          "text": "Ingest work enqueueing requires a valid TaskPayload describing the Slack-derived work to be processed.",
          "kind": "constraint",
          "conceptIds": [
            "ingest-work-enqueueing"
          ]
        },
        {
          "id": "rule-ingest-enqueue-async-processing",
          "title": "Enqueueing implies asynchronous processing",
          "text": "Ingest work enqueueing creates a background job so that processing of Slack-derived data requests occurs asynchronously and is decoupled from the original Slack event handling.",
          "kind": "assumption",
          "conceptIds": [
            "ingest-work-enqueueing"
          ]
        },
        {
          "id": "rule-thread-status-requires-thread-id",
          "title": "Thread status must be associated with a root thread timestamp",
          "text": "Any update to a thread status must specify the root thread timestamp (rootTs) of the Slack thread whose status is being changed.",
          "kind": "constraint",
          "conceptIds": [
            "thread-status"
          ]
        },
        {
          "id": "rule-thread-status-string-value",
          "title": "Thread status is represented as a string value",
          "text": "Thread status values are represented as strings when updated (e.g., via updateThreadStatus), implying that valid statuses are drawn from a defined but externally managed set of string labels.",
          "kind": "assumption",
          "conceptIds": [
            "thread-status"
          ]
        }
      ],
      "lifecycles": [
        {
          "id": "lifecycle-slack-verification",
          "subjectConceptId": "slack-security-verification",
          "stateConceptIds": [
            "slack-verification-not-performed",
            "slack-verification-succeeded",
            "slack-verification-failed"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "slack-verification-not-performed",
          "terminalStateIds": [
            "slack-verification-succeeded",
            "slack-verification-failed"
          ]
        },
        {
          "id": "lifecycle-data-request-status",
          "subjectConceptId": "data-request",
          "stateConceptIds": [
            "data-request-status-processing",
            "data-request-status-accepted",
            "data-request-status-rejected",
            "data-request-status-unhandled"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "data-request-status-processing",
          "terminalStateIds": [
            "data-request-status-accepted",
            "data-request-status-rejected",
            "data-request-status-unhandled"
          ]
        },
        {
          "id": "lifecycle-data-request-review-basic",
          "subjectConceptId": "data-request-review",
          "stateConceptIds": [
            "review-pending",
            "review-with-clarifying-questions",
            "review-ready-for-fulfillment-or-self-service"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "review-pending",
          "terminalStateIds": [
            "review-with-clarifying-questions",
            "review-ready-for-fulfillment-or-self-service"
          ]
        },
        {
          "id": "lifecycle-thread-dedupe-window",
          "subjectConceptId": "thread-deduplication",
          "stateConceptIds": [
            "event-not-seen",
            "event-seen-within-window",
            "event-window-expired"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "event-not-seen",
          "terminalStateIds": [
            "event-window-expired"
          ]
        },
        {
          "id": "lifecycle-ingest-enqueue-attempt",
          "subjectConceptId": "ingest-work-enqueueing",
          "stateConceptIds": [
            "enqueueing-not-started",
            "enqueueing-in-progress",
            "enqueueing-succeeded",
            "enqueueing-failed"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "enqueueing-not-started",
          "terminalStateIds": [
            "enqueueing-succeeded",
            "enqueueing-failed"
          ]
        },
        {
          "id": "lifecycle-thread-status-generic",
          "subjectConceptId": "thread-status",
          "stateConceptIds": [
            "thread-status-new",
            "thread-status-classified",
            "thread-status-under-review",
            "thread-status-completed"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "thread-status-new",
          "terminalStateIds": [
            "thread-status-completed"
          ]
        }
      ],
      "views": [
        {
          "id": "slack-conversation-context",
          "name": "Slack conversation as unit of work",
          "kind": "overview",
          "description": "Shows how a Slack user, channel, and messages form a thread that becomes the unit of work for downstream processing.",
          "conceptIds": [
            "slack-user",
            "slack-channel",
            "slack-thread",
            "slack-message",
            "slack-thread-message",
            "slack-message-interaction",
            "thread-status"
          ],
          "relationshipIds": [
            "rel-slack-user-sends-slack-message",
            "rel-slack-user-receives-slack-responses",
            "rel-slack-channel-has-threads",
            "rel-slack-channel-receives-data-requests",
            "rel-thread-uses-channel",
            "rel-thread-involves-user",
            "rel-thread-has-messages",
            "rel-slack-interaction-uses-channel",
            "rel-slack-interaction-uses-thread",
            "rel-thread-has-status"
          ]
        },
        {
          "id": "secure-event-ingest",
          "name": "Secure Slack event ingest and deduplication",
          "kind": "implementation",
          "description": "Shows how incoming Slack events are verified, deduplicated, and prepared for downstream processing.",
          "conceptIds": [
            "slack-security-verification",
            "slack-request-signature",
            "slack-request-timestamp",
            "slack-request-raw-body",
            "slack-signing-secret",
            "slack-request-replay-attack",
            "thread-deduplication",
            "slack-event-id"
          ],
          "relationshipIds": [
            "rel-slack-verification-uses-signature",
            "rel-slack-verification-uses-timestamp",
            "rel-slack-verification-uses-raw-body",
            "rel-slack-verification-uses-signing-secret",
            "rel-slack-verification-prevents-replay",
            "rel-slack-verification-enables-processing",
            "rel-thread-dedupe-uses-event-id",
            "rel-thread-dedupe-prevents-duplicate-processing"
          ]
        },
        {
          "id": "ingest-to-worker-pipeline",
          "name": "Ingest enqueueing and background worker pipeline",
          "kind": "implementation",
          "description": "Shows how verified Slack events are turned into queued work for background LLM workers.",
          "conceptIds": [
            "ingest-work-enqueueing",
            "task-payload",
            "task-queue",
            "llm-worker-task-endpoint",
            "slack-data-request-ingest-flow",
            "background-worker-processing",
            "slack-data-request"
          ],
          "relationshipIds": [
            "rel-ingest-enqueue-uses-taskpayload",
            "rel-ingest-enqueue-uses-task-queue",
            "rel-ingest-enqueue-targets-worker",
            "rel-ingest-enqueue-part-of-ingest-flow",
            "rel-ingest-enqueue-precedes-worker-processing",
            "rel-ingest-enqueue-represents-slack-request",
            "rel-thread-referenced-by-task-payload"
          ]
        },
        {
          "id": "data-request-lifecycle",
          "name": "Data request lifecycle from Slack thread",
          "kind": "lifecycle",
          "description": "Follows how a Slack thread becomes a structured data request, is classified and iterated by LLM workflows, and tracked via status and confidence.",
          "conceptIds": [
            "slack-thread",
            "data-request",
            "slack-channel",
            "llm-classification-workflow",
            "llm-iteration-workflow",
            "data-request-status",
            "classification-confidence",
            "rejection-reason"
          ],
          "relationshipIds": [
            "rel-data-request-originates-from-slack-thread",
            "rel-data-request-occurs-in-channel",
            "rel-data-request-is-classified-by-llm",
            "rel-data-request-is-iterated-by-llm",
            "rel-data-request-has-status",
            "rel-data-request-has-confidence",
            "rel-data-request-may-have-rejection-reason",
            "rel-thread-has-status"
          ]
        },
        {
          "id": "data-request-artifacts-structure",
          "name": "Data request artifacts and outcomes",
          "kind": "structure",
          "description": "Details the internal structure of a data request and the artifacts and outcomes produced around it.",
          "conceptIds": [
            "data-request",
            "data-request-artifacts",
            "structured-request-text",
            "clarifying-questions",
            "self-service-instructions",
            "direct-answer",
            "requester"
          ],
          "relationshipIds": [
            "rel-data-request-has-requester",
            "rel-data-request-has-artifacts",
            "rel-data-request-artifacts-include-request",
            "rel-data-request-artifacts-include-clarifying-questions",
            "rel-data-request-artifacts-include-self-service-steps",
            "rel-data-request-may-have-direct-answer"
          ]
        },
        {
          "id": "llm-review-and-fulfillment",
          "name": "LLM review and fulfillment enablement",
          "kind": "lifecycle",
          "description": "Shows how LLM-based data request review operates on a data request and produces refined requests, clarifications, answers, and self-service paths that feed into fulfillment.",
          "conceptIds": [
            "data-request-review",
            "llm",
            "data-request",
            "refined-data-request",
            "clarifying-questions",
            "self-service-instructions",
            "direct-answer",
            "analyst-fulfillment",
            "self-service-data-access",
            "prompt-template"
          ],
          "relationshipIds": [
            "rel-data-request-review-uses-llm",
            "rel-data-request-review-uses-data-request",
            "rel-data-request-review-uses-template",
            "rel-data-request-review-produces-refined-request",
            "rel-data-request-review-produces-clarifying-questions",
            "rel-data-request-review-produces-step-instructions",
            "rel-data-request-review-produces-direct-answer",
            "rel-data-request-review-precedes-analyst-fulfillment",
            "rel-data-request-review-enables-self-service"
          ]
        },
        {
          "id": "thread-status-and-dedup-state",
          "name": "Thread status and deduplication state",
          "kind": "datastore",
          "description": "Shows how thread status and deduplication records represent and constrain processing of Slack threads over time.",
          "conceptIds": [
            "slack-thread",
            "thread-status",
            "thread-processing-state",
            "thread-status-update-operation",
            "thread-deduplication",
            "event-deduplication-record",
            "deduplication-time-window",
            "slack-data-request-flow"
          ],
          "relationshipIds": [
            "rel-thread-has-status",
            "rel-thread-status-belongs-to-thread",
            "rel-thread-status-updated-by-operation",
            "rel-thread-status-represents-processing-state",
            "rel-thread-dedupe-uses-event-record",
            "rel-event-record-has-ttl",
            "rel-thread-dedupe-prevents-duplicate-processing",
            "rel-thread-dedupe-enables-idempotent-flow"
          ]
        }
      ],
      "storyViews": [
        {
          "id": "basic-slack-data-request-from-thread-to-reviewed-request",
          "name": "Basic Slack Data Request: From Thread to Reviewed Request",
          "kind": "user_flow",
          "description": "A Slack user posts a question in a channel, which becomes a data request that is reviewed and refined by an LLM.",
          "tags": [
            "happy-path",
            "data-request",
            "review"
          ],
          "focusConceptId": "data-request",
          "steps": [
            {
              "id": "user-posts-question-in-channel",
              "index": 0,
              "title": "User posts a question in a Slack channel",
              "narrative": "A Slack user asks a data-related question in a Slack channel, starting a new thread. The system will later interpret this conversation as a potential data request.",
              "conceptIds": [
                "slack-user",
                "slack-channel",
                "slack-thread"
              ],
              "relationshipIds": [
                "rel-slack-channel-has-threads",
                "rel-thread-uses-channel",
                "rel-thread-involves-user"
              ],
              "primaryConceptIds": [
                "slack-user",
                "slack-thread"
              ],
              "primaryRelationshipIds": [
                "rel-thread-involves-user"
              ]
            },
            {
              "id": "thread-is-captured-and-status-initialized",
              "index": 1,
              "title": "Thread is captured and its status is initialized",
              "narrative": "The system records the new Slack thread as a unit of work and assigns it an initial thread status, marking it as a candidate for data request processing.",
              "conceptIds": [
                "slack-thread",
                "thread-status",
                "slack-channel"
              ],
              "relationshipIds": [
                "rel-thread-has-status",
                "rel-thread-status-belongs-to-thread",
                "rel-thread-uses-channel"
              ],
              "primaryConceptIds": [
                "slack-thread",
                "thread-status"
              ],
              "primaryRelationshipIds": [
                "rel-thread-has-status"
              ]
            },
            {
              "id": "thread-becomes-structured-data-request",
              "index": 2,
              "title": "Thread is interpreted as a structured data request",
              "narrative": "The system interprets the Slack thread as a data request, associating it with the originating channel and requester, and preparing artifacts such as structured request text.",
              "conceptIds": [
                "data-request",
                "slack-thread",
                "slack-channel",
                "data-request-artifacts"
              ],
              "relationshipIds": [
                "rel-data-request-originates-from-slack-thread",
                "rel-data-request-occurs-in-channel",
                "rel-data-request-has-artifacts"
              ],
              "primaryConceptIds": [
                "data-request"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-originates-from-slack-thread"
              ]
            },
            {
              "id": "llm-classifies-and-iterates-on-request",
              "index": 3,
              "title": "LLM classifies and iterates on the data request",
              "narrative": "The data request is passed through LLM workflows that classify its type and iterate on its wording, updating its status and confidence as the system better understands the request.",
              "conceptIds": [
                "data-request",
                "data-request-status",
                "classification-confidence"
              ],
              "relationshipIds": [
                "rel-data-request-is-classified-by-llm",
                "rel-data-request-is-iterated-by-llm",
                "rel-data-request-has-status",
                "rel-data-request-has-confidence"
              ],
              "primaryConceptIds": [
                "data-request"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-is-classified-by-llm"
              ]
            },
            {
              "id": "llm-review-refines-request-and-produces-artifacts",
              "index": 4,
              "title": "LLM review refines the request and produces artifacts",
              "narrative": "An LLM-based data request review analyzes the request, producing a refined data request plus clarifying questions and self-service instructions that are stored as artifacts.",
              "conceptIds": [
                "data-request-review",
                "data-request",
                "data-request-artifacts"
              ],
              "relationshipIds": [
                "rel-data-request-review-uses-data-request",
                "rel-data-request-review-produces-refined-request",
                "rel-data-request-review-produces-clarifying-questions",
                "rel-data-request-review-produces-step-instructions",
                "rel-data-request-artifacts-include-clarifying-questions"
              ],
              "primaryConceptIds": [
                "data-request-review"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-review-uses-data-request"
              ]
            },
            {
              "id": "review-enables-fulfillment-or-self-service",
              "index": 5,
              "title": "Reviewed request enables fulfillment or self-service",
              "narrative": "With a refined request and supporting artifacts, the system can either route the work to an analyst for fulfillment or enable the requester to self-serve using the provided instructions.",
              "conceptIds": [
                "data-request-review",
                "data-request"
              ],
              "relationshipIds": [
                "rel-data-request-review-precedes-analyst-fulfillment",
                "rel-data-request-review-enables-self-service"
              ],
              "primaryConceptIds": [
                "data-request-review"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-review-precedes-analyst-fulfillment"
              ]
            }
          ]
        },
        {
          "id": "slack-event-ingest-with-security-and-deduplication",
          "name": "Slack Event Ingest with Security and Deduplication",
          "kind": "system_flow",
          "description": "Incoming Slack events are verified, deduplicated, and enqueued for background processing of data requests.",
          "tags": [
            "security",
            "deduplication",
            "ingest"
          ],
          "focusConceptId": "ingest-work-enqueueing",
          "steps": [
            {
              "id": "slack-event-arrives-for-processing",
              "index": 0,
              "title": "Slack event arrives for processing",
              "narrative": "A Slack event associated with a channel and thread reaches the system, representing a new or updated message that may be part of a data request.",
              "conceptIds": [
                "slack-channel",
                "slack-thread"
              ],
              "relationshipIds": [
                "rel-slack-channel-has-threads",
                "rel-thread-uses-channel"
              ],
              "primaryConceptIds": [
                "slack-channel"
              ],
              "primaryRelationshipIds": [
                "rel-slack-channel-has-threads"
              ]
            },
            {
              "id": "security-verification-validates-event",
              "index": 1,
              "title": "Security verification validates the Slack event",
              "narrative": "Slack request verification checks the event’s signature, timestamp, and raw body using the signing secret, preventing replay attacks and enabling further processing.",
              "conceptIds": [
                "slack-security-verification"
              ],
              "relationshipIds": [
                "rel-slack-verification-uses-signature",
                "rel-slack-verification-uses-timestamp",
                "rel-slack-verification-uses-raw-body",
                "rel-slack-verification-uses-signing-secret",
                "rel-slack-verification-prevents-replay",
                "rel-slack-verification-enables-processing"
              ],
              "primaryConceptIds": [
                "slack-security-verification"
              ],
              "primaryRelationshipIds": [
                "rel-slack-verification-enables-processing"
              ]
            },
            {
              "id": "thread-deduplication-checks-event-id",
              "index": 2,
              "title": "Thread deduplication checks the event ID",
              "narrative": "Thread deduplication uses the Slack event ID to see if this event has already been processed, creating or updating a deduplication record with a time-to-live window.",
              "conceptIds": [
                "thread-deduplication"
              ],
              "relationshipIds": [
                "rel-thread-dedupe-uses-event-id",
                "rel-thread-dedupe-uses-event-record",
                "rel-event-record-has-ttl",
                "rel-thread-dedupe-prevents-duplicate-processing"
              ],
              "primaryConceptIds": [
                "thread-deduplication"
              ],
              "primaryRelationshipIds": [
                "rel-thread-dedupe-prevents-duplicate-processing"
              ]
            },
            {
              "id": "deduplication-enables-idempotent-flow",
              "index": 3,
              "title": "Deduplication enables idempotent Slack data request flow",
              "narrative": "By filtering out duplicates, thread deduplication ensures the Slack data request flow remains idempotent, so each logical event is processed only once.",
              "conceptIds": [
                "thread-deduplication"
              ],
              "relationshipIds": [
                "rel-thread-dedupe-enables-idempotent-flow"
              ],
              "primaryConceptIds": [
                "thread-deduplication"
              ],
              "primaryRelationshipIds": [
                "rel-thread-dedupe-enables-idempotent-flow"
              ]
            },
            {
              "id": "ingest-enqueues-background-work",
              "index": 4,
              "title": "Ingest work enqueueing creates a background job",
              "narrative": "For a non-duplicate event, ingest work enqueueing builds a task payload that references the Slack thread and channel, then pushes it onto a task queue targeting an LLM worker endpoint.",
              "conceptIds": [
                "ingest-work-enqueueing",
                "slack-thread",
                "slack-channel"
              ],
              "relationshipIds": [
                "rel-thread-referenced-by-task-payload",
                "rel-slack-channel-in-task-payload",
                "rel-ingest-enqueue-uses-taskpayload",
                "rel-ingest-enqueue-uses-task-queue",
                "rel-ingest-enqueue-targets-worker"
              ],
              "primaryConceptIds": [
                "ingest-work-enqueueing"
              ],
              "primaryRelationshipIds": [
                "rel-ingest-enqueue-uses-taskpayload"
              ]
            },
            {
              "id": "background-worker-begins-processing",
              "index": 5,
              "title": "Background worker begins processing the data request",
              "narrative": "The enqueued work, representing a Slack data request, is picked up by background worker processing, which will run LLM workflows to interpret and review the request.",
              "conceptIds": [
                "ingest-work-enqueueing"
              ],
              "relationshipIds": [
                "rel-ingest-enqueue-precedes-worker-processing",
                "rel-ingest-enqueue-represents-slack-request"
              ],
              "primaryConceptIds": [
                "ingest-work-enqueueing"
              ],
              "primaryRelationshipIds": [
                "rel-ingest-enqueue-precedes-worker-processing"
              ]
            }
          ]
        },
        {
          "id": "slack-thread-status-evolution-during-request-lifecycle",
          "name": "Slack Thread Status Evolution During Request Lifecycle",
          "kind": "system_flow",
          "description": "A Slack thread’s status is updated as it moves from initial capture through classification and completion.",
          "tags": [
            "status",
            "lifecycle",
            "thread"
          ],
          "focusConceptId": "thread-status",
          "steps": [
            {
              "id": "thread-created-with-initial-status",
              "index": 0,
              "title": "Thread is created with an initial processing status",
              "narrative": "When a new Slack thread is detected in a channel, the system records it and assigns an initial thread status representing that it is newly observed.",
              "conceptIds": [
                "slack-thread",
                "thread-status",
                "slack-channel"
              ],
              "relationshipIds": [
                "rel-thread-has-status",
                "rel-thread-status-belongs-to-thread",
                "rel-thread-uses-channel"
              ],
              "primaryConceptIds": [
                "slack-thread",
                "thread-status"
              ],
              "primaryRelationshipIds": [
                "rel-thread-has-status"
              ]
            },
            {
              "id": "status-updated-as-candidate-data-request",
              "index": 1,
              "title": "Thread status updated to candidate data request",
              "narrative": "As ingest processing recognizes that the thread likely contains a data request, a thread status update operation changes its processing state to indicate it is under classification.",
              "conceptIds": [
                "slack-thread",
                "thread-status"
              ],
              "relationshipIds": [
                "rel-thread-status-updated-by-operation",
                "rel-thread-status-represents-processing-state"
              ],
              "primaryConceptIds": [
                "thread-status"
              ],
              "primaryRelationshipIds": [
                "rel-thread-status-updated-by-operation"
              ]
            },
            {
              "id": "data-request-linked-and-status-reflects-classification",
              "index": 2,
              "title": "Data request is linked and status reflects classification progress",
              "narrative": "Once a data request object is created from the thread, its own status and classification confidence are tracked while the thread status reflects that LLM classification is in progress.",
              "conceptIds": [
                "slack-thread",
                "thread-status",
                "data-request",
                "data-request-status",
                "classification-confidence"
              ],
              "relationshipIds": [
                "rel-data-request-originates-from-slack-thread",
                "rel-data-request-has-status",
                "rel-data-request-has-confidence",
                "rel-thread-has-status"
              ],
              "primaryConceptIds": [
                "data-request",
                "thread-status"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-originates-from-slack-thread"
              ]
            },
            {
              "id": "status-moves-to-under-review",
              "index": 3,
              "title": "Thread status moves to under review",
              "narrative": "As the data request enters LLM-based review, the thread status is updated again to indicate that the request is being refined and checked for clarity and feasibility.",
              "conceptIds": [
                "slack-thread",
                "thread-status",
                "data-request-review"
              ],
              "relationshipIds": [
                "rel-thread-status-updated-by-operation",
                "rel-data-request-review-uses-data-request"
              ],
              "primaryConceptIds": [
                "thread-status"
              ],
              "primaryRelationshipIds": [
                "rel-thread-status-updated-by-operation"
              ]
            },
            {
              "id": "status-reflects-completion-after-fulfillment",
              "index": 4,
              "title": "Thread status reflects completion after fulfillment or self-service",
              "narrative": "After the reviewed request is either fulfilled by an analyst or resolved via self-service, the thread status is updated to a completed state, signaling that no further automated processing is needed.",
              "conceptIds": [
                "slack-thread",
                "thread-status",
                "data-request-review"
              ],
              "relationshipIds": [
                "rel-thread-status-updated-by-operation",
                "rel-data-request-review-precedes-analyst-fulfillment",
                "rel-data-request-review-enables-self-service"
              ],
              "primaryConceptIds": [
                "thread-status"
              ],
              "primaryRelationshipIds": [
                "rel-thread-status-updated-by-operation"
              ]
            }
          ]
        },
        {
          "id": "llm-review-produces-direct-answer-and-self-service",
          "name": "LLM Review Produces Direct Answer and Self-Service Guidance",
          "kind": "user_flow",
          "description": "A user’s Slack question is turned into a data request that the LLM can answer directly while also providing self-service instructions.",
          "tags": [
            "llm",
            "direct-answer",
            "self-service"
          ],
          "focusConceptId": "data-request-review",
          "steps": [
            {
              "id": "user-asks-answerable-question",
              "index": 0,
              "title": "User asks a question that can be directly answered",
              "narrative": "A Slack user posts a clear, fact-based question in a channel thread, which the system recognizes as a data request that might be answerable automatically.",
              "conceptIds": [
                "slack-user",
                "slack-channel",
                "slack-thread"
              ],
              "relationshipIds": [
                "rel-thread-uses-channel",
                "rel-thread-involves-user",
                "rel-slack-channel-has-threads"
              ],
              "primaryConceptIds": [
                "slack-thread"
              ],
              "primaryRelationshipIds": [
                "rel-thread-involves-user"
              ]
            },
            {
              "id": "data-request-created-with-artifacts-shell",
              "index": 1,
              "title": "Data request is created with an artifacts shell",
              "narrative": "The system creates a data request from the thread and initializes its artifacts container, ready to hold structured request text, clarifying questions, and instructions.",
              "conceptIds": [
                "data-request",
                "slack-thread",
                "data-request-artifacts"
              ],
              "relationshipIds": [
                "rel-data-request-originates-from-slack-thread",
                "rel-data-request-has-artifacts"
              ],
              "primaryConceptIds": [
                "data-request"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-has-artifacts"
              ]
            },
            {
              "id": "llm-review-analyzes-and-answers",
              "index": 2,
              "title": "LLM review analyzes the request and generates a direct answer",
              "narrative": "Data request review uses an LLM and a prompt template to analyze the request, producing a refined version and a direct answer that can be returned to the user.",
              "conceptIds": [
                "data-request-review",
                "data-request"
              ],
              "relationshipIds": [
                "rel-data-request-review-uses-llm",
                "rel-data-request-review-uses-data-request",
                "rel-data-request-review-uses-template",
                "rel-data-request-review-produces-refined-request",
                "rel-data-request-review-produces-direct-answer"
              ],
              "primaryConceptIds": [
                "data-request-review"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-review-produces-direct-answer"
              ]
            },
            {
              "id": "review-produces-clarifications-and-instructions",
              "index": 3,
              "title": "Review also produces clarifying questions and self-service instructions",
              "narrative": "Alongside the direct answer, the review step generates clarifying questions and self-service instructions, which are stored as part of the data request artifacts.",
              "conceptIds": [
                "data-request-review",
                "data-request-artifacts"
              ],
              "relationshipIds": [
                "rel-data-request-review-produces-clarifying-questions",
                "rel-data-request-review-produces-step-instructions",
                "rel-data-request-artifacts-include-clarifying-questions",
                "rel-data-request-artifacts-include-self-service-steps"
              ],
              "primaryConceptIds": [
                "data-request-review"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-review-produces-step-instructions"
              ]
            },
            {
              "id": "user-receives-answer-and-guidance-in-thread",
              "index": 4,
              "title": "User receives the direct answer and guidance in the Slack thread",
              "narrative": "Through Slack message interactions in the original thread, the user receives the LLM’s direct answer plus optional clarifying questions and self-service steps, enabling them to proceed immediately.",
              "conceptIds": [
                "slack-user",
                "slack-thread",
                "slack-message-interaction"
              ],
              "relationshipIds": [
                "rel-slack-interaction-uses-thread",
                "rel-slack-interaction-uses-channel",
                "rel-slack-user-receives-slack-responses"
              ],
              "primaryConceptIds": [
                "slack-message-interaction"
              ],
              "primaryRelationshipIds": [
                "rel-slack-interaction-uses-thread"
              ]
            }
          ]
        }
      ]
    }
  ]
}