{
  "id": "gcp-data-request-project",
  "name": "Slack-based Data Request and LLM Evaluation System",
  "summary": "A system where Slack conversations become structured data requests that are processed by LLMs, reviewed, and evaluated using configurable templates and checks.",
  "description": "This system turns informal Slack threads into formal data requests, routes them through LLM-powered workflows, and evaluates the results using configurable templates and automated checks. Product and data teams configure prompt templates, test cases, and evaluation rules via a web UI, while background workers and cloud functions execute LLM jobs, track test batches, and record debug events. The system integrates with Slack, Firestore, and Vertex AI to support both live request handling and offline evaluation of prompt quality.",
  "models": [
    {
      "id": "slack-data-request-flow",
      "title": "Slack Data Request Flow",
      "description": "How Slack conversations are detected, classified, and managed as structured data requests, including user interactions and thread lifecycle.",
      "concepts": [
        {
          "id": "slack-user",
          "label": "Slack user",
          "category": "role",
          "description": "A person participating in Slack who can start or contribute to a thread that becomes a data request.",
          "aliases": [
            "slack-user",
            "user",
            "userId",
            "createdBy"
          ],
          "notes": "A Slack user is a human (or possibly bot) identity in Slack that participates in channels and threads. In this system, a Slack user can start or contribute to a Slack thread that becomes a data request. The user is referenced primarily by their Slack user ID string (e.g., in EventEnvelope.user, TaskPayload.user) and may also be recorded as the creator of other artifacts (e.g., PromptTemplate.createdBy, TestExecutionTaskPayload.userId)."
        },
        {
          "id": "slack-channel",
          "label": "Slack channel",
          "category": "place",
          "description": "A Slack channel where conversations occur and where data request threads are created and updated.",
          "aliases": [
            "slack-channel",
            "channel",
            "Slack channel"
          ],
          "notes": "A Slack channel is the Slack conversation space (identified by a Slack channel ID string) where data-request-related conversations occur. In this system, it is the container in which data request threads are created, updated, and where the bot posts messages, reactions, and debugged interactions. The channel identifier is carried through events and task payloads so that background workers know where to respond within Slack."
        },
        {
          "id": "slack-thread",
          "label": "Slack thread",
          "category": "thing",
          "description": "A conversation thread in Slack that may be recognized and tracked as a data request.",
          "aliases": [
            "slack-thread",
            "thread",
            "root thread",
            "thread doc",
            "thread record"
          ],
          "notes": "A Slack thread is a conversation in a Slack channel, identified in this system by its root message timestamp (rootTs). The system may recognize a Slack thread as a data request and then track per-thread state (such as whether the bot has reacted or greeted) in a persistent threads collection (e.g., Firestore document threads/<root_ts>). Thread-related operations often use both the Slack channel ID and the rootTs to uniquely identify and manage the thread."
        },
        {
          "id": "slack-message",
          "label": "Slack message",
          "category": "thing",
          "description": "An individual message in a Slack thread that provides context, instructions, or clarifications for a data request.",
          "aliases": [
            "slack-message",
            "Slack message",
            "thread message",
            "outgoing_slack_message",
            "thread greeting",
            "thread reply",
            "thread text message",
            "thread blocks message"
          ],
          "notes": "A Slack message is an individual post within a Slack thread that provides context, instructions, clarifications, or automated responses related to a data request. In this system, messages are posted by a bot into an existing thread (identified by rootTs/thread_ts) in a specific channel. Messages can be plain text or block-based, and some are specifically used as greetings or automated replies. Outgoing messages are recorded as debug events for observability."
        },
        {
          "id": "slack-bot-interaction",
          "label": "Slack bot interaction",
          "category": "activity",
          "description": "The automated responses, reactions, and messages posted by the system’s bot to guide users through the data request process.",
          "aliases": [
            "slack-bot-interaction",
            "bot reaction",
            "robot reaction",
            "addRobotReaction",
            "postThreadGreeting",
            "postThreadMessage",
            "postThreadBlocks",
            "outgoing Slack message",
            "Slack bot message",
            "thread message",
            "thread greeting"
          ],
          "notes": "Slack bot interaction is the set of automated reactions and messages that the system’s Slack bot posts into a channel or thread to guide and accompany a data request conversation. In this model, interactions include adding a robot_face reaction to a root message, posting greeting or guidance messages into the corresponding thread, and posting structured block-based messages. Each interaction is tied to a specific Slack channel and a root thread timestamp (rootTs), and is recorded as an outgoing_slack_message debug event when it is a text message."
        },
        {
          "id": "data-request",
          "label": "Data request",
          "category": "thing",
          "description": "A structured representation of what a Slack user is asking for, including intent, constraints, and required data or analysis.",
          "aliases": [
            "data-request",
            "data request",
            "request",
            "Slack data request",
            "thread",
            "data-request thread",
            "well documented request"
          ],
          "notes": "A Data Request is the structured representation of what a Slack user is asking the data team for. It is derived from a Slack thread and refined by LLM prompts. It includes the user's intent, constraints, and the required data or analysis, plus supporting artifacts: clarifying questions, self-service instructions, and sometimes a direct (non-data) answer. In the evals UI, a Data Request is represented by a Firestore thread document with status and artifacts."
        },
        {
          "id": "data-request-review",
          "label": "Data request review",
          "category": "activity",
          "description": "The process of assessing a data request for clarity, feasibility, and compliance before or after LLM processing.",
          "aliases": [
            "data request review",
            "review data request",
            "review_result",
            "ReviewResult",
            "LLM review of data request",
            "Slackbot data request review"
          ],
          "notes": "Data request review is the LLM-mediated process where the Slackbot AI assistant interprets a user's Slack data request and produces structured artifacts to make the request clear, unambiguous, and actionable for the data team or for self-service in Looker. The review focuses on documenting the request, surfacing clarifying questions, outlining step-by-step instructions for self-service where possible, and providing direct answers for meta questions about data semantics (not actual metrics or values). The review is performed in the context of the current date and time and assumes the assistant acts as an intermediary between the requester and the data team."
        },
        {
          "id": "slack-ingest-event",
          "label": "Slack ingest event",
          "category": "event",
          "description": "An incoming Slack webhook or event that triggers ingestion, classification, or updates to a data request thread.",
          "aliases": [
            "Slack ingest event",
            "incoming Slack webhook",
            "incoming Slack event",
            "Slack request",
            "Slack payload"
          ],
          "notes": "A Slack ingest event is an incoming HTTP request from Slack (webhook or Events API) that enters the ingest service and may trigger downstream processing such as ingestion, classification, or updates to a data request thread. Before it is treated as valid, its Slack signature and timestamp must be verified. Once accepted, it is transformed into a task payload and enqueued for asynchronous processing by a worker."
        },
        {
          "id": "thread-status",
          "label": "Thread status",
          "category": "state",
          "description": "The current state of a Slack thread within the system, such as new, in progress, awaiting clarification, or completed.",
          "aliases": [
            "thread-status",
            "thread status",
            "status",
            "thread doc status"
          ],
          "notes": "Thread status represents the current processing state of a Slack thread (identified by its root timestamp/rootTs) within the Slack-based data request and LLM evaluation flow. The placeholder function updateThreadStatus(rootTs, status) indicates that status is persisted (e.g., in Firestore) as part of a thread document. Typical domain-level values, suggested by the description, include: new, in progress, awaiting clarification, and completed. The status is used to track where a given Slack data request conversation is in the overall handling workflow."
        }
      ],
      "relationships": [
        {
          "id": "rel-slack-user-participates-in-slack-thread",
          "from": "slack-user",
          "to": "slack-thread",
          "phrase": "participates in",
          "category": "uses",
          "description": "A Slack user participates in a Slack thread by posting messages or replies that may become or contribute to a data request."
        },
        {
          "id": "rel-slack-user-sends-slack-message",
          "from": "slack-user",
          "to": "slack-message",
          "phrase": "sends",
          "category": "causes",
          "description": "A Slack user sends Slack messages whose events are captured as EventEnvelopes, including the user identifier."
        },
        {
          "id": "rel-slack-user-initiates-data-request-thread",
          "from": "slack-user",
          "to": "data-request-thread",
          "phrase": "initiates",
          "category": "causes",
          "description": "A Slack user can start a Slack thread that the system interprets as a data request thread."
        },
        {
          "id": "rel-slack-user-contributes-to-data-request-thread",
          "from": "slack-user",
          "to": "data-request-thread",
          "phrase": "contributes to",
          "category": "uses",
          "description": "A Slack user can post additional messages in an existing data request thread, providing more context or follow-up questions."
        },
        {
          "id": "rel-slack-user-identified-in-event-envelope",
          "from": "slack-user",
          "to": "event-envelope",
          "phrase": "is identified in",
          "category": "represents",
          "description": "A Slack user is represented in an EventEnvelope by the optional user field, linking Slack events to the originating user."
        },
        {
          "id": "rel-slack-user-identified-in-task-payload",
          "from": "slack-user",
          "to": "task-payload",
          "phrase": "is referenced by",
          "category": "represents",
          "description": "A Slack user may be referenced in a TaskPayload via the user field, associating background processing tasks with the originating user."
        },
        {
          "id": "rel-slack-user-creates-prompt-template",
          "from": "slack-user",
          "to": "prompt-template",
          "phrase": "creates",
          "category": "causes",
          "description": "A Slack user is recorded as the creator of a prompt template via the createdBy field, indicating authorship and responsibility."
        },
        {
          "id": "rel-slack-user-owns-test-execution",
          "from": "slack-user",
          "to": "test-execution-task",
          "phrase": "is associated with",
          "category": "uses",
          "description": "A Slack user is associated with a test execution task via userId in TestExecutionTaskPayload, indicating who initiated or owns the test execution."
        },
        {
          "id": "rel-slack-channel-contains-threads",
          "from": "slack-channel",
          "to": "slack-thread",
          "phrase": "contains",
          "category": "part_of",
          "description": "A Slack channel contains one or more Slack threads (data request threads) where individual data requests are discussed and updated."
        },
        {
          "id": "rel-slack-channel-receives-events",
          "from": "slack-channel",
          "to": "slack-event",
          "phrase": "receives",
          "category": "uses",
          "description": "A Slack channel is the context in which Slack events (messages, reactions) occur; each EventEnvelope includes the channel where the event happened."
        },
        {
          "id": "rel-slack-channel-context-for-task",
          "from": "slack-channel",
          "to": "slack-task",
          "phrase": "is context for",
          "category": "uses",
          "description": "A Slack channel is the context for background tasks that respond to Slack activity; each TaskPayload includes the channel so workers know where to post replies."
        },
        {
          "id": "rel-slack-channel-receives-bot-messages",
          "from": "slack-channel",
          "to": "bot-slack-message",
          "phrase": "receives",
          "category": "uses",
          "description": "A Slack channel receives bot-authored messages posted into specific threads via chat.postMessage."
        },
        {
          "id": "rel-slack-channel-receives-bot-reactions",
          "from": "slack-channel",
          "to": "bot-slack-reaction",
          "phrase": "receives",
          "category": "uses",
          "description": "A Slack channel receives bot reactions (such as the robot_face reaction) that are added to messages within that channel."
        },
        {
          "id": "rel-slack-channel-logged-in-debug-events",
          "from": "slack-channel",
          "to": "debug-event",
          "phrase": "is recorded in",
          "category": "represents",
          "description": "A Slack channel identifier is recorded as part of debug events for outgoing Slack messages, allowing the system to trace which channel a debugged interaction occurred in."
        },
        {
          "id": "rel-thread-identified-by-rootTs",
          "from": "slack-thread",
          "to": "root-timestamp",
          "phrase": "is identified by",
          "category": "represents",
          "description": "Each Slack thread is uniquely identified in the system by the timestamp of its root message (rootTs), which is used as the key for thread records and operations."
        },
        {
          "id": "rel-thread-occurs-in-channel",
          "from": "slack-thread",
          "to": "slack-channel",
          "phrase": "occurs in",
          "category": "part_of",
          "description": "A Slack thread occurs within a specific Slack channel; operations on a thread typically require the channel ID along with the rootTs."
        },
        {
          "id": "rel-thread-has-flags",
          "from": "slack-thread",
          "to": "thread-flags",
          "phrase": "has",
          "category": "part_of",
          "description": "A Slack thread has associated per-thread flags (such as reacted and greeted) that capture whether the system has already performed certain actions in that thread."
        },
        {
          "id": "rel-thread-uses-slack-api",
          "from": "slack-thread",
          "to": "slack-api",
          "phrase": "is synchronized via",
          "category": "uses",
          "description": "The system uses the Slack Web API to interact with Slack threads, including fetching user and channel information and applying reactions or greetings."
        },
        {
          "id": "rel-thread-represented-by-thread-doc",
          "from": "slack-thread",
          "to": "thread-document",
          "phrase": "is represented by",
          "category": "represents",
          "description": "Each Slack thread that the system tracks is represented by a persistent thread document (e.g., in the threads collection), keyed by the thread's rootTs."
        },
        {
          "id": "rel-thread-receives-events",
          "from": "slack-thread",
          "to": "slack-event",
          "phrase": "receives",
          "category": "part_of",
          "description": "A Slack thread receives Slack events (messages and reactions) that include timestamps and optional threadTs, which the system uses to associate events with the correct thread."
        },
        {
          "id": "rel-thread-associated-with-task-payload",
          "from": "slack-thread",
          "to": "task-payload",
          "phrase": "is referenced by",
          "category": "uses",
          "description": "Background tasks reference a Slack thread via the rootTs field in TaskPayload, allowing workers to perform operations related to that thread."
        },
        {
          "id": "rel-slack-message-part-of-thread",
          "from": "slack-message",
          "to": "slack-thread",
          "phrase": "is posted in",
          "category": "part_of",
          "description": "Each Slack message in this flow is posted into a specific Slack thread, identified by the root thread timestamp (rootTs/thread_ts)."
        },
        {
          "id": "rel-slack-message-in-channel",
          "from": "slack-message",
          "to": "slack-channel",
          "phrase": "appears in",
          "category": "part_of",
          "description": "Each Slack message appears in a specific Slack channel, referenced by its channel ID."
        },
        {
          "id": "rel-slack-message-represents-debug-event",
          "from": "slack-message",
          "to": "debug-event",
          "phrase": "is recorded as",
          "category": "represents",
          "description": "When the system posts a Slack message, it records a corresponding debug event of type 'outgoing_slack_message' that captures the channel, thread timestamp, text, and message type."
        },
        {
          "id": "rel-slack-message-uses-slack-api",
          "from": "slack-message",
          "to": "slack-web-api-call",
          "phrase": "is created via",
          "category": "uses",
          "description": "A Slack message is created in Slack by issuing a 'chat.postMessage' call to the Slack Web API with the channel, thread_ts, and content."
        },
        {
          "id": "rel-slack-message-has-content",
          "from": "slack-message",
          "to": "message-content",
          "phrase": "has",
          "category": "part_of",
          "description": "A Slack message has content, which may be plain text or structured blocks, used to convey context, instructions, or clarifications for a data request."
        },
        {
          "id": "rel-slack-message-associated-with-data-request",
          "from": "slack-message",
          "to": "data-request-thread",
          "phrase": "provides context for",
          "category": "enables",
          "description": "Slack messages in the system provide context, instructions, or clarifications within a Slack thread that represents a data request."
        },
        {
          "id": "rel-slack-message-has-type",
          "from": "slack-message",
          "to": "slack-message-type",
          "phrase": "has",
          "category": "is_a",
          "description": "Each recorded outgoing Slack message is associated with a message type (e.g., 'text'), indicating how the content is structured."
        },
        {
          "id": "rel-slack-bot-interaction-uses-slack-channel",
          "from": "slack-bot-interaction",
          "to": "slack-channel",
          "phrase": "occurs in",
          "category": "uses",
          "description": "Each Slack bot interaction occurs in a specific Slack channel identified by its channel ID."
        },
        {
          "id": "rel-slack-bot-interaction-uses-thread",
          "from": "slack-bot-interaction",
          "to": "slack-thread",
          "phrase": "is posted in",
          "category": "uses",
          "description": "Each Slack bot interaction is posted in a specific Slack thread, identified by the root message timestamp (rootTs) used as thread_ts or timestamp for reactions."
        },
        {
          "id": "rel-slack-bot-interaction-represents-outgoing-message",
          "from": "slack-bot-interaction",
          "to": "outgoing-slack-message",
          "phrase": "represents",
          "category": "represents",
          "description": "A Slack bot interaction represents an outgoing Slack message when the bot posts text or block content into a thread."
        },
        {
          "id": "rel-slack-bot-interaction-generates-debug-event",
          "from": "slack-bot-interaction",
          "to": "debug-event",
          "phrase": "generates",
          "category": "causes",
          "description": "When the bot posts a thread text message, the interaction generates a debug event of type outgoing_slack_message that records channel, threadTs, text, and messageType."
        },
        {
          "id": "rel-slack-bot-interaction-uses-slack-web-api",
          "from": "slack-bot-interaction",
          "to": "slack-web-api-call",
          "phrase": "uses",
          "category": "uses",
          "description": "Each Slack bot interaction uses a Slack Web API call (reactions.add or chat.postMessage) to add reactions or post messages."
        },
        {
          "id": "rel-slack-bot-interaction-annotates-root-message",
          "from": "slack-bot-interaction",
          "to": "data-request-root-message",
          "phrase": "annotates",
          "category": "part_of",
          "description": "The robot_face reaction added by the bot annotates the root message that starts the data request thread, marking it as being handled by the system."
        },
        {
          "id": "rel-slack-bot-interaction-greets-data-request-thread",
          "from": "slack-bot-interaction",
          "to": "data-request-thread",
          "phrase": "greets",
          "category": "enables",
          "description": "The bot’s thread greeting or initial thread message greets and initializes the data request thread, guiding the user at the start of the interaction."
        },
        {
          "id": "rel-data-request-from-slack-thread",
          "from": "data-request",
          "to": "slack-thread",
          "phrase": "is derived from",
          "category": "represents",
          "description": "A Data Request represents the interpreted intent of a Slack conversation thread, using the full thread and a specific message as input."
        },
        {
          "id": "rel-data-request-has-requester",
          "from": "data-request",
          "to": "slack-user",
          "phrase": "has requester",
          "category": "part_of",
          "description": "Each Data Request has a requester, the Slack user who initiated the thread or request."
        },
        {
          "id": "rel-data-request-has-artifacts",
          "from": "data-request",
          "to": "data-request-artifacts",
          "phrase": "has",
          "category": "part_of",
          "description": "A Data Request has associated artifacts including a refined request description, clarifying questions, step-by-step self-service instructions, and optionally a direct answer."
        },
        {
          "id": "rel-artifacts-include-clarifying-questions",
          "from": "data-request-artifacts",
          "to": "clarifying-questions",
          "phrase": "include",
          "category": "part_of",
          "description": "Data Request artifacts may include clarifying questions that must be answered by the requester before the request is considered clear."
        },
        {
          "id": "rel-artifacts-include-step-by-step-instructions",
          "from": "data-request-artifacts",
          "to": "self-service-instructions",
          "phrase": "include",
          "category": "part_of",
          "description": "Data Request artifacts may include step-by-step instructions for obtaining the answer via Looker when self-service is sufficient."
        },
        {
          "id": "rel-artifacts-include-direct-answer",
          "from": "data-request-artifacts",
          "to": "direct-answer",
          "phrase": "may include",
          "category": "part_of",
          "description": "Data Request artifacts may include a direct answer when the user is asking a meta question about field meanings, business terminology, or data structures rather than actual data values."
        },
        {
          "id": "rel-data-request-reviewed-by-llm",
          "from": "data-request",
          "to": "llm-review-process",
          "phrase": "is reviewed by",
          "category": "uses",
          "description": "A Data Request is reviewed and refined by an LLM-based review process that produces or updates the request, clarifying questions, self-service instructions, and direct answer."
        },
        {
          "id": "rel-data-request-iterated-by-llm",
          "from": "data-request",
          "to": "llm-iteration-process",
          "phrase": "is iterated by",
          "category": "uses",
          "description": "A Data Request is iteratively updated by an LLM process as new Slack messages arrive in the thread, updating artifacts to reflect the newest information."
        },
        {
          "id": "rel-data-request-classified-by-llm",
          "from": "slack-thread",
          "to": "data-request",
          "phrase": "is classified as",
          "category": "causes",
          "description": "A Slack thread is classified by an LLM as being a Data Request or not; only threads classified as data requests become Data Request records."
        },
        {
          "id": "rel-data-request-has-status",
          "from": "data-request",
          "to": "data-request-status",
          "phrase": "has",
          "category": "part_of",
          "description": "Each Data Request has a status such as processing, accepted, rejected, or unhandled, reflecting how the system or data team is handling it."
        },
        {
          "id": "rel-data-request-review-uses-llm",
          "from": "data-request-review",
          "to": "llm-processing",
          "phrase": "uses",
          "category": "uses",
          "description": "Data request review uses LLM processing (via a generative model and prompt execution) to generate structured review artifacts from the original Slack data request."
        },
        {
          "id": "rel-data-request-review-intermediary-between-user-and-data-team",
          "from": "data-request-review",
          "to": "slack-data-request",
          "phrase": "interprets",
          "category": "uses",
          "description": "Data request review interprets a Slack data request made by a user, acting as an intermediary between the user and the data team."
        },
        {
          "id": "rel-data-request-review-produces-review-result",
          "from": "data-request-review",
          "to": "review-result",
          "phrase": "produces",
          "category": "causes",
          "description": "Data request review produces a ReviewResult object containing a clarified request, clarifying questions, step-by-step instructions, and a direct answer when applicable."
        },
        {
          "id": "rel-data-request-review-produces-clarifying-questions",
          "from": "data-request-review",
          "to": "clarifying-questions",
          "phrase": "produces",
          "category": "causes",
          "description": "Data request review produces clarifying questions when the original data request is ambiguous or incomplete; these questions are shown to the user before other artifacts."
        },
        {
          "id": "rel-data-request-review-produces-step-by-step-instructions",
          "from": "data-request-review",
          "to": "self-service-instructions",
          "phrase": "produces",
          "category": "causes",
          "description": "Data request review produces step-by-step instructions for using Looker explores when the request can be satisfied via self-service."
        },
        {
          "id": "rel-data-request-review-produces-direct-answer",
          "from": "data-request-review",
          "to": "direct-answer",
          "phrase": "produces",
          "category": "causes",
          "description": "Data request review produces a direct answer when the user asks a meta question about field meanings, business terminology, or data structures, not about actual data values or metrics."
        },
        {
          "id": "rel-data-request-review-documents-request-for-analyst",
          "from": "data-request-review",
          "to": "well-documented-data-request",
          "phrase": "produces",
          "category": "causes",
          "description": "Data request review produces a well-documented, unambiguous version of the user's data request that is easy for an analyst to execute when self-service is not sufficient."
        },
        {
          "id": "rel-data-request-review-refers-to-looker-explores",
          "from": "data-request-review",
          "to": "looker-explore",
          "phrase": "refers to",
          "category": "uses",
          "description": "Data request review refers to specific Looker explores and describes how they can be used to obtain the requested data when self-service is appropriate."
        },
        {
          "id": "rel-data-request-review-considers-current-date-time",
          "from": "data-request-review",
          "to": "current-datetime-context",
          "phrase": "uses",
          "category": "uses",
          "description": "Data request review uses the current date and time context when interpreting and documenting the data request."
        },
        {
          "id": "rel-slack-event-uses-signature",
          "from": "slack-ingest-event",
          "to": "slack-signature",
          "phrase": "is authenticated by",
          "category": "uses",
          "description": "A Slack ingest event is authenticated by a Slack HMAC v0 signature and timestamp included with the request."
        },
        {
          "id": "rel-slack-event-uses-raw-body",
          "from": "slack-ingest-event",
          "to": "slack-raw-body",
          "phrase": "includes",
          "category": "part_of",
          "description": "A Slack ingest event includes the raw HTTP request body, which is used to compute and verify the Slack signature."
        },
        {
          "id": "rel-slack-event-causes-task-payload",
          "from": "slack-ingest-event",
          "to": "task-payload",
          "phrase": "is transformed into",
          "category": "causes",
          "description": "A valid Slack ingest event is transformed into a TaskPayload that represents the work to be done by the worker."
        },
        {
          "id": "rel-slack-event-enqueues-work",
          "from": "slack-ingest-event",
          "to": "llm-worker-task",
          "phrase": "triggers enqueueing of",
          "category": "causes",
          "description": "A valid Slack ingest event causes a Cloud Tasks job to be enqueued for the LLM worker endpoint."
        },
        {
          "id": "rel-task-payload-sent-to-worker",
          "from": "task-payload",
          "to": "llm-worker-endpoint",
          "phrase": "is sent to",
          "category": "precedes",
          "description": "The TaskPayload derived from a Slack ingest event is sent via HTTP POST to the LLM worker endpoint for processing."
        },
        {
          "id": "rel-thread-status-belongs-to-thread",
          "from": "thread-status",
          "to": "slack-thread",
          "phrase": "belongs to",
          "category": "part_of",
          "description": "Each thread status is associated with a specific Slack thread, identified by its root timestamp (rootTs). The status describes the processing state of that thread within the data request flow."
        },
        {
          "id": "rel-thread-status-updated-by-operation",
          "from": "thread-status",
          "to": "thread-status-update-operation",
          "phrase": "is updated by",
          "category": "uses",
          "description": "Thread status is updated by an operation represented in code by updateThreadStatus(rootTs, status), which records the new status for the corresponding Slack thread."
        },
        {
          "id": "rel-thread-status-represents-processing-state",
          "from": "thread-status",
          "to": "data-request-processing-state",
          "phrase": "represents",
          "category": "represents",
          "description": "Thread status represents the current processing state of a Slack-based data request conversation, such as new, in progress, awaiting clarification, or completed."
        }
      ],
      "rules": [
        {
          "id": "rule-slack-user-identified-by-id-string",
          "title": "Slack user is identified by a user ID string",
          "text": "Within the system, a Slack user is represented by a string identifier (e.g., EventEnvelope.user, TaskPayload.user, TestExecutionTaskPayload.userId, PromptTemplate.createdBy) that corresponds to the Slack user ID or an equivalent user identifier.",
          "kind": "assumption",
          "conceptIds": [
            "slack-user"
          ]
        },
        {
          "id": "rule-slack-user-may-be-absent-in-some-events",
          "title": "Slack user may be missing from some event envelopes",
          "text": "The user field in an EventEnvelope is optional, so some Slack-related events may not be associated with a specific Slack user (for example, system-generated or bot-only events).",
          "kind": "assumption",
          "conceptIds": [
            "slack-user"
          ]
        },
        {
          "id": "rule-slack-channel-id-required-for-slack-ops",
          "title": "Slack channel identifier is required for Slack operations",
          "text": "Any operation that posts messages or reactions related to data requests must include a valid Slack channel identifier so that Slack can route the action to the correct conversation space.",
          "kind": "constraint",
          "conceptIds": [
            "slack-channel"
          ]
        },
        {
          "id": "rule-slack-channel-persists-across-events-and-tasks",
          "title": "Slack channel identifier is preserved across events and tasks",
          "text": "The Slack channel identifier associated with an incoming event must be propagated into any derived task payloads and debug events so that all processing and logging remain tied to the correct Slack conversation.",
          "kind": "assumption",
          "conceptIds": [
            "slack-channel"
          ]
        },
        {
          "id": "rule-thread-must-have-rootTs",
          "title": "Tracked Slack thread must have a root timestamp",
          "text": "Any Slack thread that the system tracks or updates must be identified by a non-empty rootTs value, which is used as the key for its thread document and for task payloads.",
          "kind": "constraint",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-thread-flags-once",
          "title": "Per-thread flags are set at most once",
          "text": "Per-thread flags such as reacted and greeted are managed so that each flag is only set once for a given Slack thread, preventing duplicate reactions or greetings.",
          "kind": "policy",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-thread-requires-channel-for-operations",
          "title": "Thread operations require channel context",
          "text": "Operations that act on a Slack thread in Slack (such as posting messages or reactions) must include the Slack channel identifier along with the thread's rootTs.",
          "kind": "assumption",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-slack-message-requires-channel-and-thread",
          "title": "Slack message must specify channel and thread",
          "text": "When the system posts a Slack message in this flow, it must include both a channel identifier and a root thread timestamp (thread_ts) to ensure the message is correctly attached to the intended Slack thread.",
          "kind": "constraint",
          "conceptIds": [
            "slack-message"
          ]
        },
        {
          "id": "rule-slack-message-requires-content",
          "title": "Slack message must include content",
          "text": "A Slack message posted by the system must include content, either as plain text or as structured blocks, so that it can convey context, instructions, or clarifications.",
          "kind": "constraint",
          "conceptIds": [
            "slack-message"
          ]
        },
        {
          "id": "rule-slack-message-debug-event-recording",
          "title": "Outgoing Slack messages should be recorded as debug events",
          "text": "When the system posts an outgoing Slack message, it should record a corresponding debug event of type 'outgoing_slack_message' with the channel, thread timestamp, text, and messageType, to support observability and troubleshooting.",
          "kind": "policy",
          "conceptIds": [
            "slack-message"
          ]
        },
        {
          "id": "rule-slack-message-bot-authentication",
          "title": "Slack messages are posted using a bot token",
          "text": "Slack messages created by the system are posted via the Slack Web API using a bot token (SLACK_BOT_TOKEN), and posting must fail if the bot token is not configured.",
          "kind": "constraint",
          "conceptIds": [
            "slack-message"
          ]
        },
        {
          "id": "rule-slack-bot-interaction-requires-bot-token",
          "title": "Slack bot interaction requires a configured bot token",
          "text": "A Slack bot interaction can only occur if a valid SLACK_BOT_TOKEN is configured; otherwise, Slack Web API calls for reactions or messages must not proceed.",
          "kind": "constraint",
          "conceptIds": [
            "slack-bot-interaction"
          ]
        },
        {
          "id": "rule-slack-bot-interaction-tied-to-channel-and-rootTs",
          "title": "Slack bot interaction is scoped to a channel and root thread timestamp",
          "text": "Each Slack bot interaction must specify both a Slack channel identifier and a root message timestamp (rootTs) so that reactions and messages are correctly associated with the intended thread.",
          "kind": "invariant",
          "conceptIds": [
            "slack-bot-interaction"
          ]
        },
        {
          "id": "rule-slack-bot-interaction-ignores-duplicate-reaction-error",
          "title": "Slack bot interaction tolerates already_reacted errors",
          "text": "When adding a robot_face reaction, if Slack reports an already_reacted error, the interaction is still considered successful and should not be treated as a failure.",
          "kind": "policy",
          "conceptIds": [
            "slack-bot-interaction"
          ]
        },
        {
          "id": "rule-slack-bot-interaction-records-outgoing-text-messages",
          "title": "Outgoing text Slack bot messages are recorded as debug events",
          "text": "Whenever the bot posts a text message into a thread, the system should record a debug event of type outgoing_slack_message that includes the channel, threadTs, text, and messageType.",
          "kind": "policy",
          "conceptIds": [
            "slack-bot-interaction"
          ]
        },
        {
          "id": "rule-data-request-must-be-classified",
          "title": "Slack thread must be classified as a data request",
          "text": "A Slack thread is treated as a Data Request only if the LLM classification verdict indicates it is a data request with an associated confidence score.",
          "kind": "constraint",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-data-request-artifacts-structure",
          "title": "Data Request artifacts structure",
          "text": "A Data Request's artifacts consist of up to four fields: request, clarifyingQuestions, stepByStepInstructions, and directAnswer. Each field is optional but must follow its intended purpose when present.",
          "kind": "invariant",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-direct-answer-meta-only",
          "title": "Direct answer only for meta questions",
          "text": "The directAnswer artifact may only be used for meta questions about field meanings, business terminology, or data structures, and must not be used for questions about actual data values, metrics, numbers, counts, or specific data content.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-clarifying-questions-gate-display",
          "title": "Clarifying questions gate user-facing artifacts",
          "text": "When a Data Request has clarifying questions, only those questions are shown to the user; the other artifacts are retained for later iteration but are not yet presented.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-no-clarifying-questions-show-solution",
          "title": "Show solution when no clarifying questions remain",
          "text": "When a Data Request has no clarifying questions, the user is shown step-by-step self-service instructions if available; otherwise, the well-documented request is shown.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-data-request-review-must-produce-structured-artifacts",
          "title": "Review must produce structured artifacts",
          "text": "A data request review must produce a structured result containing: a clarified request, clarifying questions (possibly empty), step-by-step instructions for self-service if applicable, and a direct answer when the question is about field meanings, business terminology, or data structures.",
          "kind": "invariant",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-data-request-review-prioritizes-clarifying-questions",
          "title": "Clarifying questions are prioritized in user-facing output",
          "text": "If a data request review produces any clarifying questions, only those questions are initially shown to the user; other artifacts from the review are held back for later iteration based on the user's responses.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-data-request-review-shows-instructions-or-request",
          "title": "Instructions preferred over documented request when no clarifications",
          "text": "When a data request review produces no clarifying questions, the system shows the user the step-by-step self-service instructions if they are available; otherwise, it shows the well-documented request produced by the review.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-data-request-review-direct-answer-scope",
          "title": "Direct answers limited to meta questions",
          "text": "A data request review may provide a direct answer only for meta questions about field meanings, business terminology, or data structures, and must not provide direct answers about actual data values, metrics, or numbers.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-data-request-review-must-call-out-assumptions",
          "title": "Assumptions must be explicit",
          "text": "During a data request review, the assistant should make reasonable assumptions to clarify the request but must explicitly call out those assumptions so they can be corrected if wrong.",
          "kind": "assumption",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-data-request-review-aims-for-unambiguous-request",
          "title": "Review aims for unambiguous, analyst-friendly request",
          "text": "A data request review must aim to transform the original user request into a clear, well-documented, and unambiguous request that refers to existing data in a way that makes it simple for an analyst to extract the required data.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "rule-slack-event-must-have-signature-and-timestamp",
          "title": "Slack ingest event must include signature, timestamp, raw body, and signing secret",
          "text": "For a Slack ingest event to be considered valid, it must provide a non-empty Slack signature, timestamp, raw body, and the system must have a configured signing secret; otherwise the event is rejected.",
          "kind": "constraint",
          "conceptIds": [
            "slack-ingest-event"
          ]
        },
        {
          "id": "rule-slack-event-timestamp-window",
          "title": "Slack ingest event timestamp must be within 5 minutes",
          "text": "A Slack ingest event is rejected if its timestamp differs from the current server time by more than 5 minutes, to prevent replay or stale requests.",
          "kind": "policy",
          "conceptIds": [
            "slack-ingest-event"
          ]
        },
        {
          "id": "rule-slack-event-signature-match",
          "title": "Slack ingest event signature must match computed HMAC",
          "text": "A Slack ingest event is accepted only if the provided Slack signature matches the expected HMAC v0 signature computed from the timestamp and raw body using the configured signing secret.",
          "kind": "constraint",
          "conceptIds": [
            "slack-ingest-event"
          ]
        },
        {
          "id": "rule-slack-event-requires-tasks-config",
          "title": "Slack ingest event processing requires Cloud Tasks configuration",
          "text": "For a Slack ingest event to result in downstream work, the system must have a worker URL, project ID, region, and task queue configured; otherwise enqueueing work for the event fails.",
          "kind": "assumption",
          "conceptIds": [
            "slack-ingest-event"
          ]
        },
        {
          "id": "rule-thread-status-requires-thread",
          "title": "Thread status must be associated with a root thread timestamp",
          "text": "A thread status is always tied to a specific Slack thread, identified by its root timestamp (rootTs); updating or storing a thread status without a valid rootTs is not meaningful in the domain.",
          "kind": "constraint",
          "conceptIds": [
            "thread-status"
          ]
        },
        {
          "id": "rule-thread-status-single-current",
          "title": "A thread has a single current status",
          "text": "At any given time, a Slack thread has exactly one current thread status value that reflects its latest known processing state in the data request flow.",
          "kind": "assumption",
          "conceptIds": [
            "thread-status"
          ]
        }
      ],
      "lifecycles": [
        {
          "id": "lifecycle-data-request-status",
          "subjectConceptId": "data-request",
          "stateConceptIds": [
            "data-request-status-processing",
            "data-request-status-accepted",
            "data-request-status-rejected",
            "data-request-status-unhandled"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "data-request-status-processing",
          "terminalStateIds": [
            "data-request-status-accepted",
            "data-request-status-rejected",
            "data-request-status-unhandled"
          ]
        },
        {
          "id": "lc-slack-ingest-event-basic",
          "subjectConceptId": "slack-ingest-event",
          "stateConceptIds": [
            "slack-event-received",
            "slack-event-rejected",
            "slack-event-verified",
            "slack-event-enqueued"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "slack-event-received",
          "terminalStateIds": [
            "slack-event-rejected",
            "slack-event-enqueued"
          ]
        },
        {
          "id": "lifecycle-thread-status-basic",
          "subjectConceptId": "thread-status",
          "stateConceptIds": [
            "thread-status-new",
            "thread-status-in-progress",
            "thread-status-awaiting-clarification",
            "thread-status-completed"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "thread-status-new",
          "terminalStateIds": [
            "thread-status-completed"
          ]
        }
      ],
      "views": [
        {
          "id": "slack-conversation-overview",
          "name": "Slack conversation context",
          "kind": "overview",
          "description": "Shows how Slack users, channels, threads, and messages relate, forming the conversational context that later becomes a data request.",
          "conceptIds": [
            "slack-user",
            "slack-channel",
            "slack-thread",
            "slack-message",
            "slack-bot-interaction",
            "thread-status"
          ],
          "relationshipIds": [
            "rel-slack-user-participates-in-slack-thread",
            "rel-slack-user-sends-slack-message",
            "rel-slack-channel-contains-threads",
            "rel-thread-occurs-in-channel",
            "rel-slack-message-part-of-thread",
            "rel-slack-message-in-channel",
            "rel-slack-bot-interaction-uses-slack-channel",
            "rel-slack-bot-interaction-uses-thread",
            "rel-thread-status-belongs-to-thread"
          ],
          "layout": {
            "groups": [
              {
                "id": "people",
                "title": "People",
                "x": 40,
                "y": 80,
                "width": 220,
                "height": 260,
                "conceptIds": [
                  "slack-user"
                ]
              },
              {
                "id": "slack-space",
                "title": "Slack space",
                "x": 300,
                "y": 80,
                "width": 260,
                "height": 260,
                "conceptIds": [
                  "slack-channel",
                  "slack-thread",
                  "slack-message"
                ]
              },
              {
                "id": "automation",
                "title": "Bot automation",
                "x": 600,
                "y": 80,
                "width": 260,
                "height": 260,
                "conceptIds": [
                  "slack-bot-interaction",
                  "thread-status"
                ]
              }
            ]
          }
        },
        {
          "id": "data-request-derivation",
          "name": "From Slack thread to data request",
          "kind": "lifecycle",
          "description": "Shows how a Slack thread initiated by a user is classified into a structured data request with a requester and status.",
          "conceptIds": [
            "slack-user",
            "slack-thread",
            "slack-message",
            "data-request",
            "thread-status",
            "data-request-status"
          ],
          "relationshipIds": [
            "rel-slack-user-participates-in-slack-thread",
            "rel-slack-user-sends-slack-message",
            "rel-slack-message-part-of-thread",
            "rel-data-request-from-slack-thread",
            "rel-data-request-has-requester",
            "rel-data-request-classified-by-llm",
            "rel-data-request-has-status",
            "rel-thread-status-belongs-to-thread",
            "rel-thread-status-represents-processing-state"
          ],
          "layout": {
            "groups": [
              {
                "id": "slack-origin",
                "title": "Slack origin",
                "x": 40,
                "y": 80,
                "width": 260,
                "height": 260,
                "conceptIds": [
                  "slack-user",
                  "slack-thread",
                  "slack-message"
                ]
              },
              {
                "id": "classification",
                "title": "Classification",
                "x": 340,
                "y": 80,
                "width": 260,
                "height": 260,
                "conceptIds": [
                  "thread-status"
                ]
              },
              {
                "id": "structured-request",
                "title": "Structured data request",
                "x": 640,
                "y": 80,
                "width": 260,
                "height": 260,
                "conceptIds": [
                  "data-request",
                  "data-request-status"
                ]
              }
            ]
          }
        },
        {
          "id": "data-request-artifacts-structure",
          "name": "Data request artifacts",
          "kind": "structure",
          "description": "Shows the internal structure of a data request and the artifacts it may contain, such as clarifying questions, instructions, and direct answers.",
          "conceptIds": [
            "data-request",
            "data-request-artifacts",
            "clarifying-questions",
            "self-service-instructions",
            "direct-answer",
            "data-request-status"
          ],
          "relationshipIds": [
            "rel-data-request-has-artifacts",
            "rel-artifacts-include-clarifying-questions",
            "rel-artifacts-include-step-by-step-instructions",
            "rel-artifacts-include-direct-answer",
            "rel-data-request-has-status"
          ],
          "layout": {
            "groups": [
              {
                "id": "request-core",
                "title": "Data request core",
                "x": 60,
                "y": 80,
                "width": 220,
                "height": 260,
                "conceptIds": [
                  "data-request",
                  "data-request-status"
                ]
              },
              {
                "id": "artifact-container",
                "title": "Artifacts bundle",
                "x": 320,
                "y": 80,
                "width": 260,
                "height": 260,
                "conceptIds": [
                  "data-request-artifacts"
                ]
              },
              {
                "id": "artifact-kinds",
                "title": "Artifact types",
                "x": 620,
                "y": 80,
                "width": 320,
                "height": 260,
                "conceptIds": [
                  "clarifying-questions",
                  "self-service-instructions",
                  "direct-answer"
                ]
              }
            ]
          }
        },
        {
          "id": "llm-processing-pipeline",
          "name": "LLM processing of data requests",
          "kind": "implementation",
          "description": "Shows how a data request is processed by LLM review and iteration processes, using an LLM processing component.",
          "conceptIds": [
            "data-request",
            "data-request-review",
            "llm-review-process",
            "llm-iteration-process",
            "llm-processing",
            "review-result"
          ],
          "relationshipIds": [
            "rel-data-request-reviewed-by-llm",
            "rel-data-request-iterated-by-llm",
            "rel-data-request-review-uses-llm",
            "rel-data-request-review-produces-review-result"
          ],
          "layout": {
            "groups": [
              {
                "id": "input-request",
                "title": "Input",
                "x": 40,
                "y": 80,
                "width": 220,
                "height": 260,
                "conceptIds": [
                  "data-request"
                ]
              },
              {
                "id": "review-stage",
                "title": "Review stage",
                "x": 300,
                "y": 80,
                "width": 260,
                "height": 260,
                "conceptIds": [
                  "data-request-review",
                  "review-result"
                ]
              },
              {
                "id": "llm-engines",
                "title": "LLM engines",
                "x": 600,
                "y": 60,
                "width": 320,
                "height": 140,
                "conceptIds": [
                  "llm-review-process",
                  "llm-iteration-process",
                  "llm-processing"
                ]
              }
            ]
          }
        },
        {
          "id": "slack-ingest-and-worker",
          "name": "Slack ingest to LLM worker",
          "kind": "implementation",
          "description": "Shows how Slack ingest events are authenticated, transformed into task payloads, and sent to an LLM worker endpoint.",
          "conceptIds": [
            "slack-ingest-event",
            "slack-signature",
            "slack-raw-body",
            "task-payload",
            "llm-worker-task",
            "llm-worker-endpoint"
          ],
          "relationshipIds": [
            "rel-slack-event-uses-signature",
            "rel-slack-event-uses-raw-body",
            "rel-slack-event-causes-task-payload",
            "rel-slack-event-enqueues-work",
            "rel-task-payload-sent-to-worker"
          ],
          "layout": {
            "groups": [
              {
                "id": "slack-webhook",
                "title": "Slack ingest",
                "x": 40,
                "y": 80,
                "width": 260,
                "height": 260,
                "conceptIds": [
                  "slack-ingest-event",
                  "slack-signature",
                  "slack-raw-body"
                ]
              },
              {
                "id": "queueing",
                "title": "Task creation & queue",
                "x": 340,
                "y": 80,
                "width": 260,
                "height": 260,
                "conceptIds": [
                  "task-payload",
                  "llm-worker-task"
                ]
              },
              {
                "id": "worker",
                "title": "LLM worker",
                "x": 640,
                "y": 80,
                "width": 260,
                "height": 260,
                "conceptIds": [
                  "llm-worker-endpoint"
                ]
              }
            ]
          }
        },
        {
          "id": "review-to-artifacts",
          "name": "Review outputs and artifacts",
          "kind": "lifecycle",
          "description": "Shows how the data request review activity produces user-facing artifacts and a well-documented request for analysts.",
          "conceptIds": [
            "data-request-review",
            "clarifying-questions",
            "self-service-instructions",
            "direct-answer",
            "well-documented-data-request",
            "review-result"
          ],
          "relationshipIds": [
            "rel-data-request-review-produces-review-result",
            "rel-data-request-review-produces-clarifying-questions",
            "rel-data-request-review-produces-step-by-step-instructions",
            "rel-data-request-review-produces-direct-answer",
            "rel-data-request-review-documents-request-for-analyst"
          ],
          "layout": {
            "groups": [
              {
                "id": "review-activity",
                "title": "Review activity",
                "x": 40,
                "y": 80,
                "width": 240,
                "height": 260,
                "conceptIds": [
                  "data-request-review"
                ]
              },
              {
                "id": "review-outcome",
                "title": "Review outcome",
                "x": 320,
                "y": 80,
                "width": 220,
                "height": 260,
                "conceptIds": [
                  "review-result",
                  "well-documented-data-request"
                ]
              },
              {
                "id": "user-facing-artifacts",
                "title": "User-facing artifacts",
                "x": 580,
                "y": 80,
                "width": 320,
                "height": 260,
                "conceptIds": [
                  "clarifying-questions",
                  "self-service-instructions",
                  "direct-answer"
                ]
              }
            ]
          }
        }
      ]
    }
  ]
}