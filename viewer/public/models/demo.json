{
  "id": "gcp-data-request",
  "name": "Slack-based Data Request and LLM Evaluation System",
  "summary": "A system where Slack conversations become structured data requests that are reviewed, processed by LLMs using configurable templates, and evaluated with automated checks.",
  "description": "The system turns informal Slack threads into formal data requests, guides requesters through an LLM-driven workflow, and records the resulting work in Firestore. Admins configure prompt templates, test cases, and automated checks via a web UI, and a worker processes queued jobs to classify, iterate on, and review requests. Supporting services handle debugging, error tracking, and integration with Google Cloud and Slack.",
  "models": [
    {
      "id": "slack-data-request-flow",
      "title": "Slack Data Request Flow",
      "description": "How Slack conversations are turned into structured data requests, processed by LLMs, and communicated back to Slack users.",
      "concepts": [
        {
          "id": "slack-user",
          "label": "Slack user",
          "category": "role",
          "description": "A person interacting with the system through Slack, asking for data or responding to the bot.",
          "aliases": [
            "Slack user",
            "user",
            "userId",
            "createdBy"
          ],
          "notes": "A Slack user is a human (or possibly another bot) identified by a Slack user ID who interacts with the system via Slack. In this model, the user is primarily referenced indirectly through IDs in event envelopes (user) and task payloads (user, userId, createdBy). The system treats the Slack user as the originator of data requests and as the audience for bot responses and error messages."
        },
        {
          "id": "slack-channel",
          "label": "Slack channel",
          "category": "place",
          "description": "A Slack channel or conversation where data requests and bot interactions occur.",
          "aliases": [
            "Slack channel",
            "channel",
            "conversation",
            "SlackChannel"
          ],
          "notes": "A Slack channel (or conversation) identified by a channel ID, used as the container for Slack threads and messages where data requests and bot interactions occur. The system primarily uses the channel identifier to route messages, add reactions, and record debug events, and may optionally look up the human-readable channel name via the Slack Web API (conversations.info)."
        },
        {
          "id": "slack-thread",
          "label": "Slack thread",
          "category": "thing",
          "description": "A threaded Slack conversation that the system treats as a single data request context.",
          "aliases": [
            "Slack thread",
            "thread",
            "root thread",
            "rootTs",
            "thread root",
            "threads collection",
            "thread doc"
          ],
          "notes": "A Slack thread is treated as the primary unit of context for a data request. It is identified by the root message timestamp (rootTs) and may contain many Slack messages. The system stores per-thread state (flags, status) in a threads collection (e.g., Firestore document keyed by rootTs). Event envelopes and task payloads reference the thread via threadTs/rootTs to associate messages and background tasks with the same conversational context."
        },
        {
          "id": "slack-message",
          "label": "Slack message",
          "category": "thing",
          "description": "An individual message in Slack that may contain a data request or follow-up information.",
          "aliases": [
            "Slack message",
            "message",
            "thread message",
            "outgoing Slack message",
            "chat.postMessage payload",
            "thread_ts message"
          ],
          "notes": "A Slack message is an individual post in a Slack channel or thread. In this system, messages can be user-authored or bot-authored. The worker posts messages into existing threads using Slack's chat.postMessage API, identified by channel and thread_ts (rootTs). Outgoing bot messages are recorded as debug events with type 'outgoing_slack_message', including channel, threadTs, text, and a messageType such as 'text'. Messages may be plain text or block-based; both are treated as Slack messages in the domain."
        },
        {
          "id": "slack-bot-interaction",
          "label": "Slack bot interaction",
          "category": "activity",
          "description": "The back-and-forth between the bot and Slack users, including greetings, reactions, and guidance.",
          "aliases": [
            "Slack bot interaction",
            "bot interaction",
            "bot response",
            "outgoing Slack message",
            "thread greeting",
            "robot reaction"
          ],
          "notes": "Slack bot interaction represents the visible behavior of the bot in Slack threads and channels, including adding reactions (e.g., a robot_face reaction on the root message) and posting greeting or follow-up messages in a thread. These interactions are tied to a specific Slack channel and root thread timestamp, and are recorded as debug events when messages are posted."
        },
        {
          "id": "slack-security",
          "label": "Slack request verification",
          "category": "activity",
          "description": "The act of verifying that incoming Slack events are authentic and untampered.",
          "aliases": [
            "Slack request verification",
            "Slack signature verification",
            "Slack HMAC verification",
            "verifySlackSignature",
            "Slack security check"
          ],
          "notes": "Slack request verification is the security step that checks whether an incoming Slack HTTP request (event, command, or interaction) is authentic and untampered. It does this by validating Slack's HMAC-based signature (v0) over the raw HTTP body using the shared signing secret, and by enforcing a strict timestamp freshness window to prevent replay attacks."
        },
        {
          "id": "data-request",
          "label": "Data request",
          "category": "thing",
          "description": "A structured representation of a user's request for data or analysis, originating from a Slack thread.",
          "aliases": [
            "Data request",
            "data-request",
            "thread",
            "thread document",
            "request thread",
            "data request thread",
            "data request artifacts",
            "reviewed data request",
            "iterated data request"
          ],
          "notes": "A Data request is the systemâ€™s internal representation of a Slack-based request for data or analysis. It is anchored to a Slack thread (identified by rootTs) and stored as a Firestore document (often called a thread or thread doc). The system first classifies whether a Slack thread is a data request, then, if accepted, generates and iteratively refines structured artifacts: a clear request description, clarifying questions, self-service step-by-step instructions, and sometimes a direct answer for meta (non-data-value) questions."
        },
        {
          "id": "data-request-review",
          "label": "Data request review",
          "category": "activity",
          "description": "The process of assessing and refining a data request, often using an LLM to suggest improvements or clarifications.",
          "aliases": [
            "data request review",
            "review_data_request",
            "review result",
            "LLM review of data request",
            "request review artifacts"
          ],
          "notes": "Data request review is the LLM-mediated process that takes an initial, often ambiguous, data request from a Slack thread and produces structured artifacts to make the request actionable for analysts and clearer for the requester. The worker code calls an LLM with a prompt that instructs it to act as an intermediary between the Slack user and the data team, and to return a JSON object (ReviewResult) containing: (1) a refined, well-documented version of the request, (2) clarifying questions for the user, (3) step-by-step instructions for self-service in Looker when possible, and (4) a direct answer for meta questions about fields, tables, or business terminology. These artifacts are later reused in subsequent iterations of the data request."
        },
        {
          "id": "data-request-iteration",
          "label": "Data request iteration",
          "category": "activity",
          "description": "The stepwise refinement of a data request, where the system and user iterate toward a clear, actionable request.",
          "aliases": [
            "data request iteration",
            "iterate data request",
            "in-thread iteration on a data request",
            "iteration artifacts update",
            "artifacts iteration"
          ],
          "notes": "Data request iteration is the ongoing, in-thread refinement loop on a Slack-originated data request. At each iteration, the system (via an LLM) reviews the full Slack thread, the latest user reply, and previously generated artifacts (structured request, clarifying questions, step-by-step self-service instructions, and any direct answer). It then updates these artifacts to reflect new information, removing clarifying questions that have been answered, refining the request when it becomes clear, and adding or updating self-service instructions or a direct answer for meta/definition questions. The iteration is explicitly Slack-thread-centric and is designed to converge on a clear, actionable data request or a direct explanatory answer."
        },
        {
          "id": "thread-status",
          "label": "Thread status",
          "category": "state",
          "description": "The current state of a Slack thread within the system, such as new, in review, in progress, or completed.",
          "aliases": [
            "Thread status",
            "thread-status",
            "status",
            "updateThreadStatus"
          ],
          "notes": "Thread status represents the current processing state of a Slack thread (identified by its root timestamp) within the Slack-based data request system. It is persisted in a threads collection (e.g., Firestore document threads/<root_ts>) and updated as the system progresses through handling a data request. The code shows a placeholder updateThreadStatus(rootTs, status) function, indicating that status is stored as a string field on the thread document."
        }
      ],
      "relationships": [
        {
          "id": "slack-user-sends-slack-message",
          "from": "slack-user",
          "to": "slack-message",
          "phrase": "sends",
          "category": "causes",
          "description": "A Slack user sends Slack messages that may contain data requests or follow-up information."
        },
        {
          "id": "slack-user-participates-in-slack-thread",
          "from": "slack-user",
          "to": "slack-thread",
          "phrase": "participates in",
          "category": "other",
          "description": "A Slack user participates in Slack threads where data requests are discussed and refined."
        },
        {
          "id": "slack-user-interacts-with-slack-bot",
          "from": "slack-user",
          "to": "slack-bot-interaction",
          "phrase": "engages in",
          "category": "other",
          "description": "A Slack user engages in Slack bot interactions, including asking for data, responding to clarifications, and receiving results."
        },
        {
          "id": "slack-user-initiates-data-request",
          "from": "slack-user",
          "to": "data-request",
          "phrase": "initiates",
          "category": "causes",
          "description": "A Slack user initiates a data request by posting a qualifying message in a Slack thread."
        },
        {
          "id": "slack-user-participates-in-data-request-iteration",
          "from": "slack-user",
          "to": "data-request-iteration",
          "phrase": "participates in",
          "category": "other",
          "description": "A Slack user participates in data request iterations by providing clarifications or adjustments in the Slack thread."
        },
        {
          "id": "slack-user-receives-slack-bot-messages",
          "from": "slack-user",
          "to": "slack-message",
          "phrase": "receives bot responses as",
          "category": "uses",
          "description": "A Slack user receives bot responses as Slack messages posted into the relevant thread."
        },
        {
          "id": "slack-user-associated-with-event-envelope",
          "from": "slack-user",
          "to": "slack-message",
          "phrase": "is referenced by user field in",
          "category": "represents",
          "description": "A Slack user is represented in incoming Slack events and messages via the user field in the event envelope."
        },
        {
          "id": "slack-channel-has-slack-thread",
          "from": "slack-channel",
          "to": "slack-thread",
          "phrase": "contains",
          "category": "part_of",
          "description": "A Slack channel contains one or more Slack threads where data requests and bot interactions take place, referenced by root thread timestamps (rootTs)."
        },
        {
          "id": "slack-channel-has-slack-message",
          "from": "slack-channel",
          "to": "slack-message",
          "phrase": "contains",
          "category": "part_of",
          "description": "A Slack channel contains Slack messages, including both user messages and bot responses, addressed by channel ID and message timestamp."
        },
        {
          "id": "slack-channel-hosts-slack-bot-interaction",
          "from": "slack-channel",
          "to": "slack-bot-interaction",
          "phrase": "hosts",
          "category": "other",
          "description": "A Slack channel hosts Slack bot interactions, where the bot posts messages, reacts with emojis, and guides users within threads."
        },
        {
          "id": "slack-channel-contextualizes-data-request",
          "from": "slack-channel",
          "to": "data-request",
          "phrase": "contextualizes",
          "category": "other",
          "description": "A Slack channel provides the workspace context for data requests that originate from threads within that channel."
        },
        {
          "id": "slack-channel-used-by-slack-user",
          "from": "slack-channel",
          "to": "slack-user",
          "phrase": "is used by",
          "category": "uses",
          "description": "Slack users operate within Slack channels to send messages that may become data requests or follow-ups."
        },
        {
          "id": "slack-channel-identified-in-event-envelope",
          "from": "slack-channel",
          "to": "slack-message",
          "phrase": "is referenced by channel field in",
          "category": "represents",
          "description": "The channel field in event envelopes and task payloads represents the Slack channel where the corresponding Slack message or event occurred."
        },
        {
          "id": "slack-thread-identified-by-rootTs",
          "from": "slack-thread",
          "to": "slack-message",
          "phrase": "is identified by the timestamp of its root message",
          "category": "represents",
          "description": "Each Slack thread is keyed by the root message timestamp (rootTs), which corresponds to the ts of the first Slack message in the thread."
        },
        {
          "id": "slack-thread-contains-messages",
          "from": "slack-thread",
          "to": "slack-message",
          "phrase": "groups",
          "category": "part_of",
          "description": "A Slack thread groups multiple Slack messages that share the same rootTs/threadTs, representing a single conversational context."
        },
        {
          "id": "slack-thread-occurs-in-channel",
          "from": "slack-thread",
          "to": "slack-channel",
          "phrase": "occurs in",
          "category": "part_of",
          "description": "Each Slack thread exists within a specific Slack channel, referenced by the channel field in events and task payloads."
        },
        {
          "id": "slack-thread-participated-in-by-users",
          "from": "slack-thread",
          "to": "slack-user",
          "phrase": "is participated in by",
          "category": "other",
          "description": "Slack users post messages and replies within a Slack thread, forming the conversation that defines the thread context."
        },
        {
          "id": "slack-thread-hosts-bot-interaction",
          "from": "slack-thread",
          "to": "slack-bot-interaction",
          "phrase": "hosts",
          "category": "other",
          "description": "Slack bot interactions, such as greetings and reactions, occur within a Slack thread and are tracked as part of that thread's state."
        },
        {
          "id": "slack-thread-originates-data-request",
          "from": "slack-thread",
          "to": "data-request",
          "phrase": "originates",
          "category": "causes",
          "description": "A Slack thread provides the conversational context from which a structured data request is derived."
        },
        {
          "id": "slack-thread-has-thread-status",
          "from": "slack-thread",
          "to": "thread-status",
          "phrase": "has",
          "category": "other",
          "description": "Each Slack thread is associated with a thread status that can be updated over time (e.g., via updateThreadStatus) to reflect its processing state."
        },
        {
          "id": "slack-message-in-channel",
          "from": "slack-message",
          "to": "slack-channel",
          "phrase": "is posted in",
          "category": "part_of",
          "description": "Each Slack message is posted in a specific Slack channel, referenced by the channel field when calling chat.postMessage."
        },
        {
          "id": "slack-message-in-thread",
          "from": "slack-message",
          "to": "slack-thread",
          "phrase": "is posted in",
          "category": "part_of",
          "description": "A Slack message can belong to a Slack thread, indicated by the thread_ts (rootTs) used when posting the message."
        },
        {
          "id": "slack-message-participates-in-bot-interaction",
          "from": "slack-message",
          "to": "slack-bot-interaction",
          "phrase": "participates in",
          "category": "other",
          "description": "Bot-authored Slack messages are part of the overall Slack bot interaction with users, providing responses, guidance, or follow-ups."
        },
        {
          "id": "slack-message-represents-bot-response",
          "from": "slack-message",
          "to": "data-request-iteration",
          "phrase": "communicates results or clarifications for",
          "category": "represents",
          "description": "Bot-authored Slack messages in a thread can represent clarifications, feedback, or results for a specific data request iteration."
        },
        {
          "id": "slack-message-logged-as-debug-event",
          "from": "slack-message",
          "to": "debug-event",
          "phrase": "is recorded as",
          "category": "represents",
          "description": "Each outgoing Slack message from the bot is recorded as a debug event of type 'outgoing_slack_message', capturing its content and context."
        },
        {
          "id": "slack-message-uses-thread-identifier",
          "from": "slack-message",
          "to": "slack-thread",
          "phrase": "uses root message timestamp of",
          "category": "uses",
          "description": "When posted as a threaded reply, a Slack message uses the root message timestamp (thread_ts/rootTs) to associate itself with the correct Slack thread."
        },
        {
          "id": "slack-bot-interaction-uses-slack-channel",
          "from": "slack-bot-interaction",
          "to": "slack-channel",
          "phrase": "occurs in",
          "category": "part_of",
          "description": "Each Slack bot interaction is performed within a specific Slack channel, identified by the channel ID passed to Slack API calls."
        },
        {
          "id": "slack-bot-interaction-uses-slack-thread",
          "from": "slack-bot-interaction",
          "to": "slack-thread",
          "phrase": "targets",
          "category": "uses",
          "description": "Slack bot interactions are directed at a specific Slack thread, identified by the root message timestamp used as thread_ts or reaction timestamp."
        },
        {
          "id": "slack-bot-interaction-produces-slack-message",
          "from": "slack-bot-interaction",
          "to": "slack-message",
          "phrase": "produces",
          "category": "causes",
          "description": "When the bot posts greetings or thread messages, it creates Slack messages in the corresponding thread."
        },
        {
          "id": "slack-bot-interaction-adds-reaction-to-slack-message",
          "from": "slack-bot-interaction",
          "to": "slack-message",
          "phrase": "adds reaction to",
          "category": "other",
          "description": "The bot interaction may add a robot_face reaction to the root Slack message of a thread to signal that the bot has engaged with the request."
        },
        {
          "id": "slack-bot-interaction-involves-slack-user",
          "from": "slack-bot-interaction",
          "to": "slack-user",
          "phrase": "guides",
          "category": "other",
          "description": "Slack bot interactions provide guidance and responses to Slack users participating in the thread."
        },
        {
          "id": "slack-bot-interaction-recorded-as-debug-event",
          "from": "slack-bot-interaction",
          "to": "debug-event",
          "phrase": "is recorded as",
          "category": "represents",
          "description": "Outgoing Slack bot messages are recorded as debug events with metadata such as channel, thread timestamp, text, and message type."
        },
        {
          "id": "slack-bot-interaction-uses-slack-request-verification",
          "from": "slack-bot-interaction",
          "to": "slack-security",
          "phrase": "relies on",
          "category": "uses",
          "description": "Slack bot interactions implicitly rely on verified Slack requests to ensure that only authentic events trigger bot behavior, although verification is handled elsewhere."
        },
        {
          "id": "slack-security-uses-slack-message",
          "from": "slack-security",
          "to": "slack-message",
          "phrase": "protects integrity of",
          "category": "prevents",
          "description": "Slack request verification protects the integrity of slack-message content by ensuring that only messages whose HTTP requests have valid Slack signatures and fresh timestamps are accepted and processed."
        },
        {
          "id": "slack-security-precedes-slack-bot-interaction",
          "from": "slack-security",
          "to": "slack-bot-interaction",
          "phrase": "gates",
          "category": "precedes",
          "description": "Slack request verification gates slack-bot-interaction, ensuring that the bot only responds after the incoming Slack request has been authenticated and checked for tampering and replay."
        },
        {
          "id": "slack-security-protects-slack-user",
          "from": "slack-security",
          "to": "slack-user",
          "phrase": "protects",
          "category": "prevents",
          "description": "Slack request verification protects slack-user interactions by preventing forged or replayed requests from impersonating users or altering their requests."
        },
        {
          "id": "slack-security-protects-slack-channel",
          "from": "slack-security",
          "to": "slack-channel",
          "phrase": "protects activity in",
          "category": "prevents",
          "description": "Slack request verification protects activity in a slack-channel by ensuring that only authentic Slack-originated events can trigger actions or messages in that channel."
        },
        {
          "id": "slack-security-protects-slack-thread",
          "from": "slack-security",
          "to": "slack-thread",
          "phrase": "protects context of",
          "category": "prevents",
          "description": "Slack request verification protects the context of a slack-thread by ensuring that only valid, authenticated events can modify or extend the thread's conversation and associated data requests."
        },
        {
          "id": "slack-security-enables-data-request",
          "from": "slack-security",
          "to": "data-request",
          "phrase": "enables trustworthy creation of",
          "category": "enables",
          "description": "Slack request verification enables trustworthy creation of a data-request by ensuring that the originating Slack messages are authentic and not tampered with in transit."
        },
        {
          "id": "data-request-originates-from-thread",
          "from": "data-request",
          "to": "slack-thread",
          "phrase": "is originated from",
          "category": "causes",
          "description": "A Data request is created when the system identifies a Slack thread as containing a data or analysis request."
        },
        {
          "id": "data-request-contextualized-by-channel",
          "from": "data-request",
          "to": "slack-channel",
          "phrase": "is contextualized by",
          "category": "other",
          "description": "Each Data request is associated with the Slack channel where its originating thread lives, providing organizational and access context."
        },
        {
          "id": "data-request-initiated-by-user",
          "from": "data-request",
          "to": "slack-user",
          "phrase": "is initiated by",
          "category": "causes",
          "description": "A Slack user starts a Data request by posting a message that begins a Slack thread interpreted as a data or analysis request."
        },
        {
          "id": "data-request-represented-by-thread-messages",
          "from": "data-request",
          "to": "slack-message",
          "phrase": "is represented by",
          "category": "represents",
          "description": "The content and evolution of a Data request are represented by the sequence of Slack messages in its originating thread."
        },
        {
          "id": "data-request-evaluated-by-bot-interaction",
          "from": "data-request",
          "to": "slack-bot-interaction",
          "phrase": "is evaluated and guided by",
          "category": "other",
          "description": "Slack bot interactions classify whether a thread is a Data request and guide the user through clarifications and next steps."
        },
        {
          "id": "data-request-undergoes-review",
          "from": "data-request",
          "to": "data-request-review",
          "phrase": "undergoes",
          "category": "other",
          "description": "A Data request is passed through an LLM-based review process that produces a structured request, clarifying questions, self-service instructions, and possibly a direct answer."
        },
        {
          "id": "data-request-undergoes-iteration",
          "from": "data-request",
          "to": "data-request-iteration",
          "phrase": "undergoes",
          "category": "other",
          "description": "As the Slack thread continues, the Data request is iteratively updated to reflect new user replies and resolved clarifications."
        },
        {
          "id": "data-request-has-artifacts",
          "from": "data-request",
          "to": "data-request-review",
          "phrase": "has artifacts from",
          "category": "represents",
          "description": "A Data request stores artifacts produced by the review process: a refined request, clarifying questions, step-by-step instructions, and sometimes a direct answer."
        },
        {
          "id": "data-request-has-thread-status",
          "from": "data-request",
          "to": "thread-status",
          "phrase": "has",
          "category": "other",
          "description": "Each Data request has a status such as processing, accepted, rejected, or unhandled, reflecting how the system has classified and handled the thread."
        },
        {
          "id": "data-request-uses-slack-security",
          "from": "data-request",
          "to": "slack-security",
          "phrase": "relies on",
          "category": "uses",
          "description": "Creation and updates of a Data request rely on verified Slack events to ensure the request content and origin are trustworthy."
        },
        {
          "id": "data-request-review-refines-data-request",
          "from": "data-request-review",
          "to": "data-request",
          "phrase": "refines",
          "category": "other",
          "description": "Data request review refines and restructures a data request into a clearer, well-documented form."
        },
        {
          "id": "data-request-review-produces-artifacts-for-data-request",
          "from": "data-request-review",
          "to": "data-request",
          "phrase": "produces artifacts for",
          "category": "represents",
          "description": "Data request review produces structured artifacts (refined request text, clarifying questions, step-by-step instructions, and direct answers) that are stored with or associated to the data request."
        },
        {
          "id": "data-request-review-occurs-within-slack-thread",
          "from": "data-request-review",
          "to": "slack-thread",
          "phrase": "occurs within",
          "category": "part_of",
          "description": "Data request review occurs within the context of a specific Slack thread that originated the data request."
        },
        {
          "id": "data-request-review-communicates-via-slack-message",
          "from": "data-request-review",
          "to": "slack-message",
          "phrase": "communicates via",
          "category": "uses",
          "description": "Data request review results are communicated back to the Slack user through Slack messages, such as clarifying questions or instructions."
        },
        {
          "id": "data-request-review-involves-slack-user",
          "from": "data-request-review",
          "to": "slack-user",
          "phrase": "involves",
          "category": "other",
          "description": "Data request review involves the Slack user who originally requested the data, especially when clarifying questions are asked."
        },
        {
          "id": "data-request-review-is-mediated-by-slack-bot-interaction",
          "from": "data-request-review",
          "to": "slack-bot-interaction",
          "phrase": "is mediated by",
          "category": "uses",
          "description": "Data request review is mediated by Slack bot interactions that send prompts to the LLM and present review outputs to the user."
        },
        {
          "id": "data-request-review-enables-data-request-iteration",
          "from": "data-request-review",
          "to": "data-request-iteration",
          "phrase": "enables",
          "category": "enables",
          "description": "Data request review enables subsequent data request iterations by generating clarifying questions and refined request text that the user can respond to."
        },
        {
          "id": "data-request-review-depends-on-slack-security",
          "from": "data-request-review",
          "to": "slack-security",
          "phrase": "depends on",
          "category": "uses",
          "description": "Data request review depends on Slack request verification to ensure that the reviewed content originates from authentic Slack events."
        },
        {
          "id": "data-request-iteration-uses-slack-thread",
          "from": "data-request-iteration",
          "to": "slack-thread",
          "phrase": "uses full context from",
          "category": "uses",
          "description": "Data request iteration uses the full Slack thread so far as conversational context to refine the request and related artifacts."
        },
        {
          "id": "data-request-iteration-uses-latest-slack-message",
          "from": "data-request-iteration",
          "to": "slack-message",
          "phrase": "responds to latest",
          "category": "uses",
          "description": "Each data request iteration specifically responds to the latest user Slack message in the thread when updating artifacts."
        },
        {
          "id": "data-request-iteration-involves-slack-user",
          "from": "data-request-iteration",
          "to": "slack-user",
          "phrase": "involves",
          "category": "other",
          "description": "Data request iteration involves a Slack user who provides new replies and clarifications that drive the refinement process."
        },
        {
          "id": "data-request-iteration-occurs-via-slack-bot-interaction",
          "from": "data-request-iteration",
          "to": "slack-bot-interaction",
          "phrase": "is mediated by",
          "category": "uses",
          "description": "Data request iteration is mediated by Slack bot interactions, which present updated artifacts and questions back to the user."
        },
        {
          "id": "data-request-iteration-updates-data-request",
          "from": "data-request-iteration",
          "to": "data-request",
          "phrase": "updates artifacts for",
          "category": "other",
          "description": "Data request iteration updates the structured representation of the data request, including its refined wording and associated guidance."
        },
        {
          "id": "data-request-iteration-follows-data-request-review",
          "from": "data-request-iteration",
          "to": "data-request-review",
          "phrase": "follows and builds on",
          "category": "precedes",
          "description": "Data request iteration follows and builds on data request review, using previously produced artifacts as a starting point for further refinement."
        },
        {
          "id": "data-request-iteration-produces-slack-message",
          "from": "data-request-iteration",
          "to": "slack-message",
          "phrase": "produces updated artifacts as",
          "category": "causes",
          "description": "Each data request iteration results in one or more Slack messages that communicate updated requests, clarifying questions, self-service steps, or direct answers."
        },
        {
          "id": "data-request-iteration-relies-on-slack-security",
          "from": "data-request-iteration",
          "to": "slack-security",
          "phrase": "relies on",
          "category": "uses",
          "description": "Data request iteration relies on Slack request verification to ensure that the Slack thread and messages it uses as context are authentic."
        },
        {
          "id": "rel-thread-status-belongs-to-thread",
          "from": "thread-status",
          "to": "slack-thread",
          "phrase": "belongs to",
          "category": "part_of",
          "description": "Thread status is stored and tracked per Slack thread, keyed by the root message timestamp of that thread."
        },
        {
          "id": "rel-thread-status-updated-by-worker",
          "from": "thread-status",
          "to": "slack-bot-interaction",
          "phrase": "is updated during",
          "category": "other",
          "description": "Thread status is updated as a result of bot-driven processing steps that occur within the Slack thread, such as reacting, greeting, or handling a data request."
        },
        {
          "id": "rel-thread-status-associated-with-data-request",
          "from": "thread-status",
          "to": "data-request",
          "phrase": "tracks progress of",
          "category": "other",
          "description": "Thread status reflects the progress of the data request that originates from the Slack thread, such as moving from new to in review, in progress, or completed."
        }
      ],
      "rules": [
        {
          "id": "slack-user-must-be-identifiable-in-events",
          "title": "Slack user must be identifiable in relevant Slack events",
          "text": "For Slack events that represent user-originated actions (such as sending a message that may become a data request), the event should include a user identifier so the system can associate the action with a Slack user.",
          "kind": "assumption",
          "conceptIds": [
            "slack-user"
          ]
        },
        {
          "id": "slack-user-is-target-of-user-facing-errors",
          "title": "Slack user is the target of user-facing error messages",
          "text": "When an operation related to a Slack-originated request fails with medium or higher severity, the system assumes there is a Slack user who should be informed via Slack bot interaction.",
          "kind": "assumption",
          "conceptIds": [
            "slack-user"
          ]
        },
        {
          "id": "rule-slack-channel-id-required-for-bot-actions",
          "title": "Slack channel identifier is required for bot actions",
          "text": "Any bot action that posts messages, posts blocks, or adds reactions must specify a valid Slack channel identifier so that Slack can route the operation to the correct conversation.",
          "kind": "constraint",
          "conceptIds": [
            "slack-channel"
          ]
        },
        {
          "id": "rule-slack-channel-name-optional",
          "title": "Slack channel name is optional metadata",
          "text": "The system may look up and store a Slack channel's human-readable name, but this name is not required for processing events or sending messages; the channel ID is the primary identifier.",
          "kind": "assumption",
          "conceptIds": [
            "slack-channel"
          ]
        },
        {
          "id": "rule-slack-thread-has-rootTs",
          "title": "Slack thread must have a root timestamp identifier",
          "text": "Every Slack thread is uniquely identified in the system by a rootTs value corresponding to the timestamp of the root Slack message.",
          "kind": "constraint",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-slack-thread-flags-once",
          "title": "Per-thread flags are set at most once",
          "text": "Per-thread flags such as reacted and greeted are managed transactionally and are intended to be set only once per Slack thread, preventing duplicate bot reactions or greetings.",
          "kind": "policy",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-slack-thread-channel-binding",
          "title": "Slack thread is bound to a single channel",
          "text": "A Slack thread is associated with exactly one Slack channel; all events and tasks for that thread reference the same channel identifier.",
          "kind": "assumption",
          "conceptIds": [
            "slack-thread"
          ]
        },
        {
          "id": "rule-slack-message-requires-channel-and-thread",
          "title": "Bot Slack message must specify channel and thread",
          "text": "When the bot posts a Slack message as part of a data request flow, it must include a valid channel identifier and a root thread timestamp (thread_ts/rootTs) so the message appears in the correct thread context.",
          "kind": "constraint",
          "conceptIds": [
            "slack-message"
          ]
        },
        {
          "id": "rule-slack-message-debug-logging",
          "title": "Outgoing bot Slack messages should be logged as debug events",
          "text": "Each outgoing Slack message sent by the bot should be recorded as a debug event with type 'outgoing_slack_message', including at minimum the channel, threadTs, text, messageType, and a timestamp.",
          "kind": "policy",
          "conceptIds": [
            "slack-message"
          ]
        },
        {
          "id": "rule-slack-message-text-or-blocks",
          "title": "Bot Slack message content is text or blocks",
          "text": "A bot-authored Slack message in this system is sent either as plain text or as a set of structured blocks, but in both cases is treated as a single Slack message in the domain.",
          "kind": "assumption",
          "conceptIds": [
            "slack-message"
          ]
        },
        {
          "id": "rule-slack-bot-interaction-requires-channel-and-rootTs",
          "title": "Slack bot interaction must specify channel and root thread timestamp",
          "text": "Every Slack bot interaction that posts a message or adds a reaction must include a valid Slack channel identifier and the root thread timestamp to correctly target the Slack thread.",
          "kind": "constraint",
          "conceptIds": [
            "slack-bot-interaction"
          ]
        },
        {
          "id": "rule-slack-bot-interaction-ignores-duplicate-reaction",
          "title": "Slack bot interaction tolerates duplicate robot reactions",
          "text": "When adding a robot_face reaction to a Slack message, the interaction treats the 'already_reacted' Slack API error as non-fatal, effectively allowing idempotent reaction behavior.",
          "kind": "invariant",
          "conceptIds": [
            "slack-bot-interaction"
          ]
        },
        {
          "id": "rule-slack-bot-interaction-records-outgoing-messages",
          "title": "Slack bot interaction should record outgoing messages as debug events",
          "text": "Whenever the bot posts a text message in a Slack thread, the interaction should record a corresponding outgoing_slack_message debug event with timestamp, channel, threadTs, text, and messageType metadata.",
          "kind": "policy",
          "conceptIds": [
            "slack-bot-interaction"
          ]
        },
        {
          "id": "rule-slack-bot-interaction-requires-bot-token",
          "title": "Slack bot interaction requires a configured bot token",
          "text": "Slack bot interactions that call the Slack Web API require a valid Slack bot token to be configured; otherwise, the interaction cannot proceed.",
          "kind": "constraint",
          "conceptIds": [
            "slack-bot-interaction"
          ]
        },
        {
          "id": "slack-security-requires-all-inputs",
          "title": "Slack verification requires signature, timestamp, raw body, and signing secret",
          "text": "Slack request verification must only succeed when a Slack-provided signature, a timestamp, the exact raw HTTP request body, and the configured Slack signing secret are all present and non-empty.",
          "kind": "constraint",
          "conceptIds": [
            "slack-security"
          ]
        },
        {
          "id": "slack-security-valid-timestamp",
          "title": "Slack verification requires a valid numeric timestamp",
          "text": "Slack request verification must treat the Slack timestamp as invalid if it cannot be parsed as a finite number, and in that case the verification must fail.",
          "kind": "constraint",
          "conceptIds": [
            "slack-security"
          ]
        },
        {
          "id": "slack-security-timestamp-window",
          "title": "Slack verification enforces a 5-minute timestamp window",
          "text": "Slack request verification must reject any request whose Slack timestamp differs from the current server time by more than five minutes, in order to limit replay attacks.",
          "kind": "policy",
          "conceptIds": [
            "slack-security"
          ]
        },
        {
          "id": "slack-security-hmac-v0",
          "title": "Slack verification uses HMAC-SHA256 v0 scheme",
          "text": "Slack request verification must compute an HMAC-SHA256 over the base string 'v0:{timestamp}:{rawBody}' using the Slack signing secret, and compare it against the provided 'v0=' signature format.",
          "kind": "invariant",
          "conceptIds": [
            "slack-security"
          ]
        },
        {
          "id": "slack-security-constant-time-compare",
          "title": "Slack verification uses constant-time comparison",
          "text": "Slack request verification must compare the expected signature and the provided signature using a constant-time comparison method and must fail verification if their lengths differ.",
          "kind": "policy",
          "conceptIds": [
            "slack-security"
          ]
        },
        {
          "id": "rule-data-request-must-be-classified",
          "title": "Data request must be classified as a data request thread",
          "text": "A Slack thread is only treated as a Data request if the LLM-based classification (isDataRequest) determines that the thread contains a data or analysis request with sufficient confidence; otherwise the thread may be marked as rejected or unhandled.",
          "kind": "constraint",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-data-request-has-single-origin-thread",
          "title": "Data request is anchored to a single Slack thread",
          "text": "Each Data request is anchored to exactly one originating Slack thread, identified by the root message timestamp (rootTs) and stored as a single thread document in Firestore.",
          "kind": "invariant",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-data-request-artifacts-optional",
          "title": "Data request artifacts are optional and may be partially populated",
          "text": "A Data request may have zero or more of the following artifacts populated at any time: request, clarifyingQuestions, stepByStepInstructions, directAnswer. These fields are progressively filled and refined by the review and iteration processes.",
          "kind": "assumption",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-data-request-direct-answer-meta-only",
          "title": "Direct answers are only for meta questions",
          "text": "The directAnswer artifact of a Data request is only used for meta questions about field meanings, business terminology, or data structures, and must not be used for questions about actual data values, metrics, counts, or specific data content.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "rule-data-request-clarifying-questions-gate-output",
          "title": "Clarifying questions gate exposure of other artifacts",
          "text": "When a Data request still has outstanding clarifyingQuestions, only those questions are shown to the user; the refined request and self-service instructions are withheld until clarifications are resolved.",
          "kind": "policy",
          "conceptIds": [
            "data-request"
          ]
        },
        {
          "id": "data-request-review-must-produce-structured-json",
          "title": "Review must return structured JSON with all review artifacts",
          "text": "A data request review must return a JSON object with the fields `request`, `clarifyingQuestions`, `stepByStepInstructions`, and `directAnswer`, even if some fields are empty, so that downstream processing can rely on a consistent structure.",
          "kind": "constraint",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "data-request-review-shows-only-clarifying-questions-to-user",
          "title": "Clarifying questions gate exposure of other artifacts",
          "text": "If a data request review produces any clarifying questions, only those questions are initially shown to the Slack user; the refined request, step-by-step instructions, and direct answer are held back for later use after the user responds.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "data-request-review-shows-instructions-or-refined-request-when-no-questions",
          "title": "Instructions or refined request are shown when no clarifications are needed",
          "text": "When a data request review produces no clarifying questions, the system shows the Slack user the step-by-step instructions for self-service if they are available; otherwise, it shows the well-documented refined request.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "data-request-review-direct-answer-scope",
          "title": "Direct answers are limited to meta questions",
          "text": "A data request review may provide a direct answer only for meta questions about field meanings, business terminology, or data structures, and must not directly answer questions about actual data values, metrics, or numbers.",
          "kind": "policy",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "data-request-review-makes-explicit-assumptions",
          "title": "Assumptions must be explicit",
          "text": "During data request review, the LLM should make reasonable assumptions to clarify the request but must call out these assumptions explicitly so that analysts and users can correct them if needed.",
          "kind": "assumption",
          "conceptIds": [
            "data-request-review"
          ]
        },
        {
          "id": "data-request-iteration-removes-answered-questions",
          "title": "Remove clarifying questions once fully answered",
          "text": "During data request iteration, if clarifying questions have been fully answered by the user in the Slack thread, those questions must be removed from the current artifacts.",
          "kind": "invariant",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "data-request-iteration-refines-clear-request",
          "title": "Refine the request when it becomes clear",
          "text": "When the user's intent is clear based on the latest Slack thread context, data request iteration must refine the data request text to be precise and actionable.",
          "kind": "invariant",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "data-request-iteration-provides-self-service-steps-when-possible",
          "title": "Provide self-service instructions when feasible",
          "text": "If the data request can reasonably be fulfilled by the user via self-service tools (e.g., Looker), data request iteration should produce or update step-by-step self-service instructions instead of or in addition to a backend fulfillment request.",
          "kind": "policy",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "data-request-iteration-direct-answer-meta-only",
          "title": "Use direct answers only for meta/definition questions",
          "text": "Data request iteration may produce a direct answer artifact only for questions about field meanings, business terminology, data structures, or how data is organized. Questions involving actual data values, metrics, counts, or specific data content must be treated as data requests and not answered via the direct answer artifact.",
          "kind": "constraint",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "data-request-iteration-updates-all-artifacts",
          "title": "Update all artifacts consistently",
          "text": "At each iteration, the system must consider and, if needed, update all relevant artifacts (request, clarifying questions, self-service instructions, direct answer) so they remain consistent with the latest Slack thread and user reply.",
          "kind": "invariant",
          "conceptIds": [
            "data-request-iteration"
          ]
        },
        {
          "id": "rule-thread-status-per-thread",
          "title": "Thread status is defined per root Slack thread",
          "text": "Each Slack thread, identified by its root message timestamp, has at most one current thread status value stored in the threads collection.",
          "kind": "invariant",
          "conceptIds": [
            "thread-status"
          ]
        },
        {
          "id": "rule-thread-status-string",
          "title": "Thread status is represented as a string value",
          "text": "Thread status is stored and updated as a string field (e.g., 'new', 'in_review', 'in_progress', 'completed') associated with the thread document.",
          "kind": "assumption",
          "conceptIds": [
            "thread-status"
          ]
        }
      ],
      "lifecycles": [
        {
          "id": "lifecycle-slack-thread-status",
          "subjectConceptId": "slack-thread",
          "stateConceptIds": [
            "thread-status"
          ],
          "transitionRelationshipIds": [
            "slack-thread-has-thread-status"
          ],
          "initialStateId": "thread-status",
          "terminalStateIds": [
            "thread-status"
          ]
        },
        {
          "id": "lifecycle-data-request-status",
          "subjectConceptId": "data-request",
          "stateConceptIds": [
            "thread-status"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "thread-status",
          "terminalStateIds": [
            "thread-status"
          ]
        },
        {
          "id": "lifecycle-thread-status-basic",
          "subjectConceptId": "thread-status",
          "stateConceptIds": [
            "thread-status-new",
            "thread-status-in-review",
            "thread-status-in-progress",
            "thread-status-completed"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "thread-status-new",
          "terminalStateIds": [
            "thread-status-completed"
          ]
        }
      ],
      "views": [
        {
          "id": "slack-conversation-context",
          "name": "Slack conversation context",
          "kind": "overview",
          "description": "Shows how Slack users, channels, threads, and messages relate to form the conversational context that the system operates on.",
          "conceptIds": [
            "slack-user",
            "slack-channel",
            "slack-thread",
            "slack-message",
            "slack-bot-interaction",
            "thread-status"
          ],
          "relationshipIds": [
            "slack-user-sends-slack-message",
            "slack-user-participates-in-slack-thread",
            "slack-channel-has-slack-thread",
            "slack-channel-has-slack-message",
            "slack-thread-contains-messages",
            "slack-thread-occurs-in-channel",
            "slack-thread-participated-in-by-users",
            "slack-thread-hosts-bot-interaction",
            "slack-bot-interaction-produces-slack-message",
            "slack-thread-has-thread-status"
          ]
        },
        {
          "id": "data-request-lifecycle",
          "name": "Data request lifecycle from Slack thread",
          "kind": "lifecycle",
          "description": "Follows how a Slack thread becomes a structured data request, is reviewed, iterated, and tracked via thread status.",
          "conceptIds": [
            "slack-thread",
            "slack-message",
            "slack-user",
            "data-request",
            "data-request-review",
            "data-request-iteration",
            "thread-status"
          ],
          "relationshipIds": [
            "slack-thread-originates-data-request",
            "data-request-originates-from-thread",
            "data-request-represented-by-thread-messages",
            "slack-user-initiates-data-request",
            "data-request-initiated-by-user",
            "data-request-undergoes-review",
            "data-request-review-refines-data-request",
            "data-request-review-enables-data-request-iteration",
            "data-request-undergoes-iteration",
            "data-request-iteration-updates-data-request"
          ]
        },
        {
          "id": "review-and-iteration-interaction",
          "name": "Review and iteration via Slack bot",
          "kind": "lifecycle",
          "description": "Zooms into how the bot mediates review and iteration of a data request through Slack messages with the user.",
          "conceptIds": [
            "slack-user",
            "slack-thread",
            "slack-message",
            "slack-bot-interaction",
            "data-request-review",
            "data-request-iteration"
          ],
          "relationshipIds": [
            "slack-user-interacts-with-slack-bot",
            "slack-thread-hosts-bot-interaction",
            "slack-message-participates-in-bot-interaction",
            "slack-bot-interaction-produces-slack-message",
            "data-request-review-occurs-within-slack-thread",
            "data-request-review-communicates-via-slack-message",
            "data-request-review-is-mediated-by-slack-bot-interaction",
            "data-request-iteration-uses-slack-thread",
            "data-request-iteration-uses-latest-slack-message",
            "data-request-iteration-occurs-via-slack-bot-interaction"
          ]
        },
        {
          "id": "security-gating-flow",
          "name": "Security gating of Slack interactions and data requests",
          "kind": "implementation",
          "description": "Shows how Slack request verification protects users, channels, threads, and messages, and gates bot interactions and data requests.",
          "conceptIds": [
            "slack-security",
            "slack-message",
            "slack-user",
            "slack-channel",
            "slack-thread",
            "slack-bot-interaction",
            "data-request"
          ],
          "relationshipIds": [
            "slack-security-uses-slack-message",
            "slack-security-precedes-slack-bot-interaction",
            "slack-bot-interaction-uses-slack-request-verification",
            "slack-security-protects-slack-user",
            "slack-security-protects-slack-channel",
            "slack-security-protects-slack-thread",
            "slack-security-enables-data-request",
            "data-request-uses-slack-security"
          ]
        },
        {
          "id": "thread-status-tracking",
          "name": "Thread status tracking for data requests",
          "kind": "structure",
          "description": "Explains how thread status is attached to threads and data requests and updated during bot interactions.",
          "conceptIds": [
            "slack-thread",
            "data-request",
            "slack-bot-interaction",
            "thread-status"
          ],
          "relationshipIds": [
            "slack-thread-has-thread-status",
            "data-request-has-thread-status",
            "rel-thread-status-belongs-to-thread",
            "rel-thread-status-updated-by-worker",
            "rel-thread-status-associated-with-data-request"
          ]
        }
      ],
      "storyViews": [
        {
          "id": "happy-path-new-data-request",
          "name": "Happy Path: New Data Request from Slack Thread",
          "kind": "user_flow",
          "description": "A Slack user starts a new thread with a data question, the system turns it into a structured data request, iterates with the user, and marks the thread as completed.",
          "tags": [
            "happy-path",
            "new-request",
            "thread-status"
          ],
          "focusConceptId": "data-request",
          "steps": [
            {
              "id": "happy-path-step-0-user-asks-question",
              "index": 0,
              "title": "User asks a data question in Slack",
              "narrative": "A Slack user posts a new message in a channel asking for specific data, starting a new thread that will become a data request context.",
              "conceptIds": [
                "slack-user",
                "slack-message",
                "slack-channel",
                "slack-thread"
              ],
              "relationshipIds": [
                "slack-user-sends-slack-message",
                "slack-message-in-channel",
                "slack-channel-has-slack-message",
                "slack-channel-has-slack-thread",
                "slack-thread-identified-by-rootTs"
              ],
              "primaryConceptIds": [
                "slack-user",
                "slack-message"
              ],
              "primaryRelationshipIds": [
                "slack-user-sends-slack-message"
              ]
            },
            {
              "id": "happy-path-step-1-security-gates-event",
              "index": 1,
              "title": "Slack event is verified before bot reacts",
              "narrative": "The incoming Slack message event is checked by the Slack request verification layer to ensure it is authentic before any bot interaction begins.",
              "conceptIds": [
                "slack-security",
                "slack-message",
                "slack-thread",
                "slack-channel",
                "slack-user"
              ],
              "relationshipIds": [
                "slack-security-uses-slack-message",
                "slack-security-precedes-slack-bot-interaction",
                "slack-security-protects-slack-user",
                "slack-security-protects-slack-channel",
                "slack-security-protects-slack-thread"
              ],
              "primaryConceptIds": [
                "slack-security"
              ],
              "primaryRelationshipIds": [
                "slack-security-precedes-slack-bot-interaction"
              ]
            },
            {
              "id": "happy-path-step-2-thread-becomes-data-request",
              "index": 2,
              "title": "Thread is recognized as a new data request",
              "narrative": "The system recognizes that the new thread contains a data question, creates a structured data request object, and associates it with the originating thread, channel, and user.",
              "conceptIds": [
                "data-request",
                "slack-thread",
                "slack-channel",
                "slack-user",
                "thread-status"
              ],
              "relationshipIds": [
                "slack-thread-originates-data-request",
                "data-request-originates-from-thread",
                "data-request-contextualized-by-channel",
                "data-request-initiated-by-user",
                "data-request-has-thread-status"
              ],
              "primaryConceptIds": [
                "data-request",
                "slack-thread"
              ],
              "primaryRelationshipIds": [
                "slack-thread-originates-data-request"
              ]
            },
            {
              "id": "happy-path-step-3-bot-engages-and-reviews-request",
              "index": 3,
              "title": "Bot engages in the thread to review the request",
              "narrative": "The Slack bot joins the thread, asks clarifying questions, and begins a data request review process with the user, updating the thread status to indicate the request is in review.",
              "conceptIds": [
                "slack-bot-interaction",
                "slack-thread",
                "slack-user",
                "data-request",
                "data-request-review",
                "thread-status"
              ],
              "relationshipIds": [
                "slack-thread-hosts-bot-interaction",
                "slack-bot-interaction-involves-slack-user",
                "data-request-evaluated-by-bot-interaction",
                "data-request-undergoes-review",
                "rel-thread-status-updated-by-worker"
              ],
              "primaryConceptIds": [
                "slack-bot-interaction",
                "data-request-review"
              ],
              "primaryRelationshipIds": [
                "data-request-undergoes-review"
              ]
            },
            {
              "id": "happy-path-step-4-iterative-clarification",
              "index": 4,
              "title": "Iterative clarification refines the data request",
              "narrative": "Through back-and-forth messages in the thread, the bot and user iterate on the wording and scope of the data request until it is clear and actionable.",
              "conceptIds": [
                "data-request-iteration",
                "slack-message",
                "slack-thread",
                "slack-user",
                "slack-bot-interaction",
                "data-request"
              ],
              "relationshipIds": [
                "data-request-undergoes-iteration",
                "data-request-iteration-uses-slack-thread",
                "data-request-iteration-uses-latest-slack-message",
                "data-request-iteration-occurs-via-slack-bot-interaction",
                "data-request-iteration-updates-data-request"
              ],
              "primaryConceptIds": [
                "data-request-iteration"
              ],
              "primaryRelationshipIds": [
                "data-request-undergoes-iteration"
              ]
            },
            {
              "id": "happy-path-step-5-bot-confirms-and-updates-status",
              "index": 5,
              "title": "Bot confirms final request and marks thread as ready",
              "narrative": "Once the request is well-defined, the bot posts a summary message in the thread, representing the finalized data request and updating the thread status to indicate it is ready for downstream processing.",
              "conceptIds": [
                "slack-message",
                "data-request",
                "data-request-iteration",
                "thread-status",
                "slack-thread"
              ],
              "relationshipIds": [
                "slack-message-represents-bot-response",
                "data-request-represented-by-thread-messages",
                "data-request-iteration-produces-slack-message",
                "slack-thread-has-thread-status",
                "rel-thread-status-associated-with-data-request"
              ],
              "primaryConceptIds": [
                "thread-status",
                "data-request"
              ],
              "primaryRelationshipIds": [
                "rel-thread-status-associated-with-data-request"
              ]
            }
          ]
        },
        {
          "id": "ongoing-iteration-on-existing-thread",
          "name": "Ongoing Iteration on an Existing Data Request Thread",
          "kind": "user_flow",
          "description": "A user returns to an existing Slack thread to adjust a prior data request, and the system uses the full thread context to iterate and update the request.",
          "tags": [
            "iteration",
            "follow-up",
            "existing-thread"
          ],
          "focusConceptId": "data-request-iteration",
          "steps": [
            {
              "id": "ongoing-iteration-step-0-user-returns-to-thread",
              "index": 0,
              "title": "User returns to an existing thread with a follow-up",
              "narrative": "A Slack user posts a new message in an existing thread, asking to tweak filters or add new dimensions to a previous data request.",
              "conceptIds": [
                "slack-user",
                "slack-message",
                "slack-thread",
                "slack-channel"
              ],
              "relationshipIds": [
                "slack-user-sends-slack-message",
                "slack-message-in-thread",
                "slack-message-uses-thread-identifier",
                "slack-thread-occurs-in-channel"
              ],
              "primaryConceptIds": [
                "slack-thread",
                "slack-message"
              ],
              "primaryRelationshipIds": [
                "slack-message-in-thread"
              ]
            },
            {
              "id": "ongoing-iteration-step-1-security-checks-followup",
              "index": 1,
              "title": "Security verifies the follow-up event",
              "narrative": "The Slack request verification layer validates the follow-up message event before allowing the bot to treat it as a modification to the existing data request.",
              "conceptIds": [
                "slack-security",
                "slack-message",
                "slack-thread"
              ],
              "relationshipIds": [
                "slack-security-uses-slack-message",
                "slack-security-precedes-slack-bot-interaction",
                "slack-security-protects-slack-thread"
              ],
              "primaryConceptIds": [
                "slack-security"
              ],
              "primaryRelationshipIds": [
                "slack-security-precedes-slack-bot-interaction"
              ]
            },
            {
              "id": "ongoing-iteration-step-2-bot-recognizes-existing-request",
              "index": 2,
              "title": "Bot recognizes and loads the existing data request",
              "narrative": "The system maps the thread to its existing data request, loads its current artifacts and status, and prepares to treat the new message as a potential iteration.",
              "conceptIds": [
                "data-request",
                "slack-thread",
                "thread-status"
              ],
              "relationshipIds": [
                "data-request-originates-from-thread",
                "slack-thread-has-thread-status",
                "rel-thread-status-associated-with-data-request"
              ],
              "primaryConceptIds": [
                "data-request"
              ],
              "primaryRelationshipIds": [
                "data-request-originates-from-thread"
              ]
            },
            {
              "id": "ongoing-iteration-step-3-bot-initiates-iteration-dialogue",
              "index": 3,
              "title": "Bot initiates an iteration dialogue",
              "narrative": "The Slack bot responds in the thread, confirming the userâ€™s intent to modify the existing request and asking targeted questions to understand the changes.",
              "conceptIds": [
                "slack-bot-interaction",
                "slack-message",
                "slack-thread",
                "slack-user",
                "data-request-iteration"
              ],
              "relationshipIds": [
                "slack-thread-hosts-bot-interaction",
                "slack-bot-interaction-produces-slack-message",
                "slack-bot-interaction-involves-slack-user",
                "data-request-iteration-occurs-via-slack-bot-interaction",
                "data-request-iteration-uses-latest-slack-message"
              ],
              "primaryConceptIds": [
                "slack-bot-interaction",
                "data-request-iteration"
              ],
              "primaryRelationshipIds": [
                "data-request-iteration-occurs-via-slack-bot-interaction"
              ]
            },
            {
              "id": "ongoing-iteration-step-4-iteration-updates-request-artifacts",
              "index": 4,
              "title": "Iteration updates the data request artifacts",
              "narrative": "Using the full thread context and the latest user messages, the system updates the structured data request artifacts to reflect the new requirements.",
              "conceptIds": [
                "data-request-iteration",
                "data-request",
                "slack-thread",
                "slack-message"
              ],
              "relationshipIds": [
                "data-request-iteration-uses-slack-thread",
                "data-request-iteration-updates-data-request",
                "data-request-represented-by-thread-messages",
                "data-request-iteration-produces-slack-message"
              ],
              "primaryConceptIds": [
                "data-request-iteration",
                "data-request"
              ],
              "primaryRelationshipIds": [
                "data-request-iteration-updates-data-request"
              ]
            },
            {
              "id": "ongoing-iteration-step-5-status-reflects-updated-progress",
              "index": 5,
              "title": "Thread status reflects updated progress",
              "narrative": "After the iteration, the system adjusts the thread status to show that the request has been modified and is again in progress or ready for execution.",
              "conceptIds": [
                "thread-status",
                "slack-thread",
                "data-request"
              ],
              "relationshipIds": [
                "slack-thread-has-thread-status",
                "rel-thread-status-belongs-to-thread",
                "rel-thread-status-associated-with-data-request"
              ],
              "primaryConceptIds": [
                "thread-status"
              ],
              "primaryRelationshipIds": [
                "rel-thread-status-associated-with-data-request"
              ]
            }
          ]
        },
        {
          "id": "security-failure-blocks-bot-interaction",
          "name": "Error Case: Security Failure Blocks Bot Interaction",
          "kind": "error_flow",
          "description": "An incoming Slack event fails verification, preventing the bot from engaging and blocking creation or modification of a data request.",
          "tags": [
            "security",
            "error",
            "blocked-interaction"
          ],
          "focusConceptId": "slack-security",
          "steps": [
            {
              "id": "security-error-step-0-suspicious-message-arrives",
              "index": 0,
              "title": "Suspicious Slack message event arrives",
              "narrative": "A Slack message event is received that appears to start or modify a data request, but its signature or origin looks suspicious.",
              "conceptIds": [
                "slack-message",
                "slack-channel",
                "slack-thread"
              ],
              "relationshipIds": [
                "slack-message-in-channel",
                "slack-message-in-thread",
                "slack-channel-has-slack-message"
              ],
              "primaryConceptIds": [
                "slack-message"
              ],
              "primaryRelationshipIds": [
                "slack-message-in-channel"
              ]
            },
            {
              "id": "security-error-step-1-verification-fails",
              "index": 1,
              "title": "Slack request verification fails",
              "narrative": "The Slack request verification process detects that the event cannot be trusted and flags it as invalid, preventing further processing.",
              "conceptIds": [
                "slack-security",
                "slack-message",
                "slack-thread",
                "slack-channel",
                "slack-user"
              ],
              "relationshipIds": [
                "slack-security-uses-slack-message",
                "slack-security-protects-slack-user",
                "slack-security-protects-slack-channel",
                "slack-security-protects-slack-thread"
              ],
              "primaryConceptIds": [
                "slack-security"
              ],
              "primaryRelationshipIds": [
                "slack-security-uses-slack-message"
              ]
            },
            {
              "id": "security-error-step-2-bot-interaction-is-gated",
              "index": 2,
              "title": "Bot interaction is gated and does not start",
              "narrative": "Because verification failed, the security layer blocks any Slack bot interaction from starting, so no bot messages or reactions are posted in the thread.",
              "conceptIds": [
                "slack-security",
                "slack-bot-interaction",
                "slack-thread"
              ],
              "relationshipIds": [
                "slack-security-precedes-slack-bot-interaction",
                "slack-security-protects-slack-thread"
              ],
              "primaryConceptIds": [
                "slack-security"
              ],
              "primaryRelationshipIds": [
                "slack-security-precedes-slack-bot-interaction"
              ]
            },
            {
              "id": "security-error-step-3-no-data-request-is-created-or-updated",
              "index": 3,
              "title": "No data request is created or updated",
              "narrative": "Since the event is untrusted, the system neither creates a new data request nor applies any iteration to existing ones, preserving the integrity of prior artifacts.",
              "conceptIds": [
                "slack-security",
                "data-request",
                "data-request-iteration"
              ],
              "relationshipIds": [
                "slack-security-enables-data-request",
                "data-request-uses-slack-security",
                "data-request-iteration-relies-on-slack-security"
              ],
              "primaryConceptIds": [
                "slack-security"
              ],
              "primaryRelationshipIds": [
                "slack-security-enables-data-request"
              ]
            }
          ]
        },
        {
          "id": "system-level-review-and-iteration-loop",
          "name": "System-Level Review and Iteration Loop",
          "kind": "system_flow",
          "description": "The system performs an LLM-mediated review of a data request, then uses that review to drive an iteration loop with the user inside the Slack thread.",
          "tags": [
            "system-flow",
            "review",
            "iteration-loop"
          ],
          "focusConceptId": "data-request-review",
          "steps": [
            {
              "id": "system-loop-step-0-request-enters-review",
              "index": 0,
              "title": "Data request enters review phase",
              "narrative": "After initial capture, the structured data request is passed into a review process that will assess clarity, feasibility, and missing details.",
              "conceptIds": [
                "data-request",
                "data-request-review",
                "slack-thread"
              ],
              "relationshipIds": [
                "data-request-undergoes-review",
                "data-request-review-occurs-within-slack-thread",
                "data-request-review-depends-on-slack-security"
              ],
              "primaryConceptIds": [
                "data-request-review"
              ],
              "primaryRelationshipIds": [
                "data-request-undergoes-review"
              ]
            },
            {
              "id": "system-loop-step-1-review-produces-artifacts",
              "index": 1,
              "title": "Review produces structured artifacts and suggestions",
              "narrative": "The review process refines the data request, generating artifacts such as a normalized query description, assumptions, and a list of clarifying questions.",
              "conceptIds": [
                "data-request-review",
                "data-request"
              ],
              "relationshipIds": [
                "data-request-review-refines-data-request",
                "data-request-review-produces-artifacts-for-data-request",
                "data-request-has-artifacts"
              ],
              "primaryConceptIds": [
                "data-request-review",
                "data-request"
              ],
              "primaryRelationshipIds": [
                "data-request-review-refines-data-request"
              ]
            },
            {
              "id": "system-loop-step-2-bot-communicates-review-in-thread",
              "index": 2,
              "title": "Bot communicates review results in the Slack thread",
              "narrative": "The system uses the Slack bot to post a message summarizing the review findings and asking the user to confirm or adjust the proposed interpretation.",
              "conceptIds": [
                "data-request-review",
                "slack-bot-interaction",
                "slack-message",
                "slack-thread",
                "slack-user"
              ],
              "relationshipIds": [
                "data-request-review-communicates-via-slack-message",
                "data-request-review-is-mediated-by-slack-bot-interaction",
                "slack-bot-interaction-produces-slack-message",
                "slack-bot-interaction-involves-slack-user",
                "slack-message-participates-in-bot-interaction"
              ],
              "primaryConceptIds": [
                "slack-bot-interaction",
                "slack-message"
              ],
              "primaryRelationshipIds": [
                "data-request-review-communicates-via-slack-message"
              ]
            },
            {
              "id": "system-loop-step-3-user-responds-and-iteration-begins",
              "index": 3,
              "title": "User responds and iteration begins",
              "narrative": "The user replies in the thread with confirmations or corrections, triggering a data request iteration that builds on the review artifacts.",
              "conceptIds": [
                "slack-user",
                "slack-message",
                "data-request-iteration",
                "data-request-review",
                "slack-thread"
              ],
              "relationshipIds": [
                "slack-user-sends-slack-message",
                "data-request-review-enables-data-request-iteration",
                "data-request-iteration-follows-data-request-review",
                "data-request-iteration-uses-latest-slack-message",
                "data-request-iteration-uses-slack-thread"
              ],
              "primaryConceptIds": [
                "data-request-iteration"
              ],
              "primaryRelationshipIds": [
                "data-request-review-enables-data-request-iteration"
              ]
            },
            {
              "id": "system-loop-step-4-iteration-updates-request-and-communicates-back",
              "index": 4,
              "title": "Iteration updates the request and communicates back to user",
              "narrative": "The iteration process updates the data request artifacts and posts an updated summary message in the thread, closing the loop for this cycle of review and refinement.",
              "conceptIds": [
                "data-request-iteration",
                "data-request",
                "slack-message",
                "slack-thread"
              ],
              "relationshipIds": [
                "data-request-iteration-updates-data-request",
                "data-request-iteration-produces-slack-message",
                "data-request-represented-by-thread-messages",
                "slack-message-represents-bot-response"
              ],
              "primaryConceptIds": [
                "data-request-iteration",
                "data-request"
              ],
              "primaryRelationshipIds": [
                "data-request-iteration-updates-data-request"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "llm-orchestration",
      "title": "LLM Orchestration and Prompting",
      "description": "How the system constructs prompts, calls LLMs, and manages context to support data request understanding, iteration, and review.",
      "concepts": [
        {
          "id": "llm-request",
          "label": "LLM request",
          "category": "thing",
          "description": "A structured call to a large language model, including prompt text, parameters, and context.",
          "aliases": [
            "LLMRequest",
            "executePrompt request",
            "LLM call payload",
            "LLM invocation request"
          ],
          "notes": "An LLM request is the structured payload used when invoking a large language model. It encapsulates the concrete prompt text plus generation parameters (model name, temperature, max tokens). It is passed into the executePrompt operation, which uses it to call a specific model via a provider SDK and to record an LLM debug event. The request is conceptually the finalized, rendered prompt ready to be sent to the provider, not the reusable template definition."
        },
        {
          "id": "llm-response",
          "label": "LLM response",
          "category": "thing",
          "description": "The content and metadata returned by a large language model after processing a request.",
          "aliases": [
            "LLMResponse",
            "LLM response",
            "model response",
            "LLM output",
            "generated content"
          ],
          "notes": "An LLM response encapsulates both the human-readable text returned by the model and the underlying raw provider payload, along with timing and model identification metadata. It is the direct result of executing an LLMRequest via executePrompt and is used for downstream evaluation, display, and debugging."
        },
        {
          "id": "llm-context",
          "label": "LLM context",
          "category": "thing",
          "description": "The set of background facts, prior messages, and debug information provided to or produced by the LLM.",
          "aliases": [
            "LLM context",
            "context",
            "named context",
            "context file",
            "context bundle",
            "all context"
          ],
          "notes": "LLM context is the collection of reusable background materials (stored as markdown files) that can be loaded and combined to enrich prompts sent to an LLM. Each context item is identified by a name and backed by a .md file on disk. The system can load a single named context (useContext) or aggregate all available contexts into a single serialized block (useAllContext), which is suitable for embedding into a larger prompt or wrapper format (e.g., XML with CDATA). Contexts are cached in memory for reuse within the worker process."
        },
        {
          "id": "prompt-template",
          "label": "Prompt template",
          "category": "thing",
          "description": "A reusable, parameterized prompt definition that shapes how the LLM is asked to perform tasks such as classification, iteration, or review.",
          "aliases": [
            "PromptTemplate",
            "prompt template",
            "template",
            "EJS prompt template"
          ],
          "notes": "A Prompt template is a versioned, reusable EJS-based text pattern that defines how an LLM should be prompted for a particular task. It declares a set of required template variables, may be tagged and documented with change notes, and can be associated with a specific LLM model. Only one version per logical template id is marked as the active version and is used when constructing concrete LLM requests."
        },
        {
          "id": "template-variable",
          "label": "Template variable",
          "category": "thing",
          "description": "A named placeholder within a prompt template that is filled with concrete values from a data request or environment.",
          "aliases": [
            "template variable",
            "EJS variable",
            "EJS placeholder",
            "prompt variable",
            "variables",
            "template data",
            "template context"
          ],
          "notes": "A template variable is a named placeholder referenced inside a prompt template (implemented with EJS syntax like `<%= variableName %>`). At runtime, it is bound to a JSON-serializable value and used during template rendering to produce the final prompt that is sent as part of an LLM request. The system can statically extract variable names from the template source and later display the concrete variable values alongside the final rendered prompt for inspection and evaluation."
        },
        {
          "id": "template-rendering",
          "label": "Template rendering",
          "category": "activity",
          "description": "The process of combining a prompt template with variable values to produce a concrete prompt for the LLM.",
          "aliases": [
            "template rendering",
            "renderEJSTemplate",
            "render template",
            "EJS rendering",
            "prompt rendering"
          ],
          "notes": "Template rendering is the process of taking a stored prompt template definition and a set of variable values, validating that all required variables are present, and producing a concrete prompt string suitable for inclusion in an LLM request. In this system, EJS is the concrete templating engine used, and failures in rendering are surfaced as explicit errors that include the template identifier."
        },
        {
          "id": "llm-execution",
          "label": "LLM execution",
          "category": "activity",
          "description": "The act of sending a rendered prompt to a chosen LLM model and obtaining a response.",
          "aliases": [
            "LLM execution",
            "executePrompt",
            "prompt execution",
            "LLM call",
            "model invocation",
            "LLM invocation"
          ],
          "notes": "LLM execution is the runtime act of invoking a concrete LLM model with a fully rendered prompt and generation parameters, waiting for completion, and packaging the result as an LLMResponse. In this system it is implemented by executePrompt, which selects a model (defaulting to 'gemini-2.5-flash' if none is specified), calls model.generateContent, measures elapsed time, and optionally records LLM debug events before and after the call."
        },
        {
          "id": "llm-provider",
          "label": "LLM provider",
          "category": "role",
          "description": "The external service (such as Vertex AI) that hosts and runs the generative models used by the system.",
          "aliases": [
            "Vertex AI",
            "VertexAI",
            "generative model provider",
            "model host",
            "external LLM service",
            "LLM backend"
          ],
          "notes": "The LLM provider is an external managed service (e.g., Google Cloud Vertex AI) that hosts and serves generative models. In this system, it is accessed via environment-specific configuration (project, region/location) and returns model handles that are later used to perform LLM execution. The provider is responsible for exposing specific model names (e.g., gemini-3-pro-preview) and may require special locations/regions for certain models (such as 'global' for Gemini 3). Model instances from the provider are cached to avoid recreating clients repeatedly, but this caching is an implementation detail rather than a domain requirement."
        },
        {
          "id": "llm-debug-event",
          "label": "LLM debug event",
          "category": "event",
          "description": "A recorded event capturing details of LLM calls, prompts, and responses for later inspection and troubleshooting.",
          "aliases": [
            "DebugEvent",
            "debug event",
            "LLM debug event",
            "error debug event",
            "llm_request debug event",
            "llm_response debug event"
          ],
          "notes": "An LLM debug event is a structured, timestamped record stored (per Slack thread) in Firestore under a 'debugEvents' subcollection. It captures details about LLM-related operations (requests, responses, classifications) and related errors for later inspection, troubleshooting, and evaluation. Each event has a type discriminator (e.g., 'llm_request', 'llm_response', 'error_occurred') and a data payload whose shape depends on the type. Events are typically written asynchronously and failures to record them must not break the main flow."
        }
      ],
      "relationships": [
        {
          "id": "llm-request-to-llm-response",
          "from": "llm-request",
          "to": "llm-response",
          "phrase": "results in",
          "category": "causes",
          "description": "An LLM request, when executed, results in an LLM response containing the generated text and metadata."
        },
        {
          "id": "llm-request-uses-llm-context",
          "from": "llm-request",
          "to": "llm-context",
          "phrase": "may be derived from",
          "category": "uses",
          "description": "An LLM request may be derived from or incorporate LLM context such as prior messages or background facts, even though only the final prompt string is present in the request object."
        },
        {
          "id": "llm-request-derived-from-prompt-template",
          "from": "llm-request",
          "to": "prompt-template",
          "phrase": "is derived from",
          "category": "represents",
          "description": "An LLM request typically represents a concrete instance of a prompt template after variables have been filled in."
        },
        {
          "id": "llm-request-uses-template-rendering",
          "from": "llm-request",
          "to": "template-rendering",
          "phrase": "is produced by",
          "category": "precedes",
          "description": "An LLM request is produced by template rendering, which combines a prompt template with variable values into a concrete prompt string."
        },
        {
          "id": "llm-request-parameterizes-template-variables",
          "from": "llm-request",
          "to": "template-variable",
          "phrase": "concretizes",
          "category": "represents",
          "description": "An LLM request contains a fully rendered prompt where template variables have been replaced with concrete values."
        },
        {
          "id": "llm-request-enables-llm-execution",
          "from": "llm-request",
          "to": "llm-execution",
          "phrase": "enables",
          "category": "enables",
          "description": "An LLM request is the input required to perform LLM execution via the executePrompt operation."
        },
        {
          "id": "llm-request-uses-llm-provider",
          "from": "llm-request",
          "to": "llm-provider",
          "phrase": "is sent to",
          "category": "uses",
          "description": "An LLM request is ultimately sent to an LLM provider, which hosts the underlying model identified by the model name."
        },
        {
          "id": "llm-request-records-llm-debug-event",
          "from": "llm-request",
          "to": "llm-debug-event",
          "phrase": "is logged as",
          "category": "causes",
          "description": "When an LLM request is executed with debug context, it causes an LLM debug event of type 'llm_request' to be recorded, capturing the prompt, parameters, and template metadata."
        },
        {
          "id": "llm-response-from-request",
          "from": "llm-response",
          "to": "llm-request",
          "phrase": "is produced from",
          "category": "causes",
          "description": "An LLM response is produced from a specific LLM request when executePrompt sends the prompt to the model."
        },
        {
          "id": "llm-response-part-of-execution",
          "from": "llm-response",
          "to": "llm-execution",
          "phrase": "is returned by",
          "category": "part_of",
          "description": "An LLM response is the output artifact returned by an LLM execution after the provider processes the request."
        },
        {
          "id": "llm-response-uses-context",
          "from": "llm-response",
          "to": "llm-context",
          "phrase": "reflects",
          "category": "represents",
          "description": "The content of an LLM response reflects the LLM context (prompt text, background information, and prior messages) that was encoded into the originating LLM request."
        },
        {
          "id": "llm-response-uses-provider",
          "from": "llm-response",
          "to": "llm-provider",
          "phrase": "is generated by",
          "category": "causes",
          "description": "An LLM response is generated by an external LLM provider that executes the model call."
        },
        {
          "id": "llm-response-logged-as-debug-event",
          "from": "llm-response",
          "to": "llm-debug-event",
          "phrase": "may be logged as",
          "category": "causes",
          "description": "An LLM response may be captured in an LLM debug event for later inspection and troubleshooting, alongside the originating request."
        },
        {
          "id": "rel-llm-context-used-by-llm-request",
          "from": "llm-context",
          "to": "llm-request",
          "phrase": "may be incorporated into the prompt of",
          "category": "uses",
          "description": "Named context files loaded via useContext/useAllContext are intended to be embedded into the prompt string that forms part of an LLM request."
        },
        {
          "id": "rel-llm-context-influences-llm-response",
          "from": "llm-context",
          "to": "llm-response",
          "phrase": "influences",
          "category": "causes",
          "description": "When included in the prompt, LLM context shapes the background information the model uses, thereby influencing the resulting LLM response."
        },
        {
          "id": "rel-llm-context-logged-via-llm-debug-event",
          "from": "llm-context",
          "to": "llm-debug-event",
          "phrase": "is indirectly captured by",
          "category": "represents",
          "description": "Although not logged separately, any LLM context that is embedded into the prompt becomes part of the prompt text recorded in LLM debug events."
        },
        {
          "id": "prompt-template-uses-template-variable",
          "from": "prompt-template",
          "to": "template-variable",
          "phrase": "declares required",
          "category": "uses",
          "description": "A prompt template lists the names of template variables that must be supplied when rendering the template into a concrete prompt."
        },
        {
          "id": "prompt-template-enables-template-rendering",
          "from": "prompt-template",
          "to": "template-rendering",
          "phrase": "is input to",
          "category": "enables",
          "description": "A prompt template is combined with variable values during template rendering to produce a concrete prompt string."
        },
        {
          "id": "prompt-template-precedes-llm-request",
          "from": "prompt-template",
          "to": "llm-request",
          "phrase": "is source definition for",
          "category": "precedes",
          "description": "A prompt template serves as the source definition from which concrete LLM requests are derived after rendering."
        },
        {
          "id": "prompt-template-represents-llm-context",
          "from": "prompt-template",
          "to": "llm-context",
          "phrase": "structures inclusion of",
          "category": "represents",
          "description": "A prompt template can be designed to embed or reference elements of LLM context (such as prior messages or background facts) via its variables and template text."
        },
        {
          "id": "prompt-template-uses-llm-provider",
          "from": "prompt-template",
          "to": "llm-provider",
          "phrase": "may target model of",
          "category": "uses",
          "description": "A prompt template may specify which LLM model (hosted by an LLM provider) it is intended to be used with, via its model field."
        },
        {
          "id": "prompt-template-enables-llm-execution",
          "from": "prompt-template",
          "to": "llm-execution",
          "phrase": "enables consistent",
          "category": "enables",
          "description": "By standardizing how prompts are constructed, a prompt template enables repeatable LLM executions for testing and production use."
        },
        {
          "id": "template-variable-declared-by-prompt-template",
          "from": "template-variable",
          "to": "prompt-template",
          "phrase": "is declared within",
          "category": "part_of",
          "description": "A template variable is declared and referenced inside a prompt template using EJS tags such as `<%= variableName %>`."
        },
        {
          "id": "template-variable-used-in-template-rendering",
          "from": "template-variable",
          "to": "template-rendering",
          "phrase": "is substituted during",
          "category": "uses",
          "description": "During template rendering, each template variable is substituted with its bound value to produce the final prompt text."
        },
        {
          "id": "template-variable-concretized-by-llm-request",
          "from": "template-variable",
          "to": "llm-request",
          "phrase": "is concretized in",
          "category": "represents",
          "description": "When a prompt template is rendered into an LLM request, each template variable is bound to a concrete value that appears in the final prompt of the LLM request."
        },
        {
          "id": "template-variable-may-represent-llm-context",
          "from": "template-variable",
          "to": "llm-context",
          "phrase": "may reference data from",
          "category": "uses",
          "description": "Some template variables may be populated from LLM context such as prior messages, background facts, or debug information."
        },
        {
          "id": "template-variable-inspected-alongside-llm-response",
          "from": "template-variable",
          "to": "llm-response",
          "phrase": "is inspected alongside",
          "category": "other",
          "description": "In evaluation views, the concrete values of template variables are displayed together with the final rendered prompt and the resulting LLM response to aid debugging and analysis."
        },
        {
          "id": "template-rendering-uses-prompt-template",
          "from": "template-rendering",
          "to": "prompt-template",
          "phrase": "consumes",
          "category": "uses",
          "description": "Template rendering consumes a prompt template definition, including its template body and declared variables, as the basis for generating a concrete prompt."
        },
        {
          "id": "template-rendering-uses-template-variable",
          "from": "template-rendering",
          "to": "template-variable",
          "phrase": "substitutes",
          "category": "uses",
          "description": "Template rendering substitutes template variables in the prompt template with concrete values supplied at render time."
        },
        {
          "id": "template-rendering-precedes-llm-request",
          "from": "template-rendering",
          "to": "llm-request",
          "phrase": "produces prompt text for",
          "category": "precedes",
          "description": "Template rendering produces the concrete prompt string that is embedded into an LLM request."
        },
        {
          "id": "template-rendering-enables-llm-execution",
          "from": "template-rendering",
          "to": "llm-execution",
          "phrase": "enables",
          "category": "enables",
          "description": "By producing a concrete prompt string, template rendering enables subsequent LLM execution using that prompt."
        },
        {
          "id": "template-rendering-may-use-llm-context",
          "from": "template-rendering",
          "to": "llm-context",
          "phrase": "may draw variable values from",
          "category": "uses",
          "description": "Template rendering may use values derived from LLM context as inputs for template variables, even though this is indirect in the code."
        },
        {
          "id": "template-rendering-may-be-logged-as-llm-debug-event",
          "from": "template-rendering",
          "to": "llm-debug-event",
          "phrase": "is indirectly captured by",
          "category": "represents",
          "description": "The outcome of template rendering (prompt text and template variables) is recorded in LLM debug events when a rendered prompt is executed, allowing reconstruction of how the prompt was formed."
        },
        {
          "id": "rel-llm-exec-uses-llm-request",
          "from": "llm-execution",
          "to": "llm-request",
          "phrase": "consumes",
          "category": "uses",
          "description": "LLM execution consumes an LLM request containing the rendered prompt text and generation parameters."
        },
        {
          "id": "rel-llm-exec-produces-llm-response",
          "from": "llm-execution",
          "to": "llm-response",
          "phrase": "produces",
          "category": "causes",
          "description": "LLM execution produces an LLM response that includes the generated text, raw provider response, elapsed time, and resolved model name."
        },
        {
          "id": "rel-llm-exec-uses-llm-provider",
          "from": "llm-execution",
          "to": "llm-provider",
          "phrase": "invokes model from",
          "category": "uses",
          "description": "LLM execution invokes a concrete model instance obtained from an LLM provider such as Vertex AI."
        },
        {
          "id": "rel-llm-exec-logged-as-llm-debug-event",
          "from": "llm-execution",
          "to": "llm-debug-event",
          "phrase": "is logged as",
          "category": "causes",
          "description": "LLM execution causes LLM debug events to be recorded, capturing request details (model, prompt, parameters, template metadata) and, in other code paths, response details."
        },
        {
          "id": "rel-llm-exec-reflects-llm-context",
          "from": "llm-execution",
          "to": "llm-context",
          "phrase": "indirectly reflects",
          "category": "represents",
          "description": "LLM execution indirectly reflects LLM context because the rendered prompt and template variables embedded in the request encode prior messages and background facts."
        },
        {
          "id": "rel-llm-exec-uses-prompt-template",
          "from": "llm-execution",
          "to": "prompt-template",
          "phrase": "operates on prompts derived from",
          "category": "uses",
          "description": "LLM execution operates on prompts that are derived from prompt templates, even though it only sees the final rendered prompt string."
        },
        {
          "id": "rel-llm-exec-follows-template-rendering",
          "from": "llm-execution",
          "to": "template-rendering",
          "phrase": "follows",
          "category": "precedes",
          "description": "LLM execution follows template rendering, which has already combined the template and variables into a concrete prompt."
        },
        {
          "id": "llm-provider-hosts-models",
          "from": "llm-provider",
          "to": "llm-execution",
          "phrase": "supplies models for",
          "category": "enables",
          "description": "The LLM provider supplies concrete generative models that are invoked during LLM execution."
        },
        {
          "id": "llm-provider-serves-llm-request",
          "from": "llm-provider",
          "to": "llm-request",
          "phrase": "receives",
          "category": "uses",
          "description": "The LLM provider ultimately receives LLM requests that have been constructed and sent by the system."
        },
        {
          "id": "llm-provider-produces-llm-response",
          "from": "llm-provider",
          "to": "llm-response",
          "phrase": "produces",
          "category": "causes",
          "description": "The LLM provider processes incoming LLM requests and produces corresponding LLM responses."
        },
        {
          "id": "llm-provider-constrains-prompt-template",
          "from": "llm-provider",
          "to": "prompt-template",
          "phrase": "constrains",
          "category": "other",
          "description": "The capabilities and configuration of the LLM provider (e.g., available models and locations) constrain how prompt templates are targeted to specific models."
        },
        {
          "id": "llm-provider-influences-llm-context",
          "from": "llm-provider",
          "to": "llm-context",
          "phrase": "influences handling of",
          "category": "other",
          "description": "The LLM provider's model capabilities and configuration influence how much and what kind of context can be included in LLM requests."
        },
        {
          "id": "llm-provider-is-captured-by-llm-debug-event",
          "from": "llm-provider",
          "to": "llm-debug-event",
          "phrase": "is referenced by",
          "category": "represents",
          "description": "Information about which LLM provider and model were used can be captured in LLM debug events for troubleshooting and auditing."
        },
        {
          "id": "rel-llm-debug-event-logs-llm-request",
          "from": "llm-debug-event",
          "to": "llm-request",
          "phrase": "logs details of",
          "category": "represents",
          "description": "An LLM debug event of type 'llm_request' records the prompt, model, parameters, and identifiers associated with a specific LLM request."
        },
        {
          "id": "rel-llm-debug-event-logs-llm-response",
          "from": "llm-debug-event",
          "to": "llm-response",
          "phrase": "logs details of",
          "category": "represents",
          "description": "An LLM debug event of type 'llm_response' records the model name, raw response payload, elapsed time, and related metadata for a specific LLM response."
        },
        {
          "id": "rel-llm-debug-event-reflects-llm-context",
          "from": "llm-debug-event",
          "to": "llm-context",
          "phrase": "captures aspects of",
          "category": "represents",
          "description": "LLM debug events include template variables, template identifiers, and other contextual fields that reflect the LLM context used during a request or response."
        },
        {
          "id": "rel-llm-debug-event-references-prompt-template",
          "from": "llm-debug-event",
          "to": "prompt-template",
          "phrase": "references",
          "category": "represents",
          "description": "LLM debug events for LLM requests and responses may store the templateId and templateVersion, tying the recorded interaction back to the specific prompt template used."
        },
        {
          "id": "rel-llm-debug-event-includes-template-variables",
          "from": "llm-debug-event",
          "to": "template-variable",
          "phrase": "includes values of",
          "category": "represents",
          "description": "LLM debug events for LLM requests may embed the concrete templateVariables used to render the prompt, allowing later inspection of how template variables influenced the LLM call."
        },
        {
          "id": "rel-llm-debug-event-recorded-during-llm-execution",
          "from": "llm-debug-event",
          "to": "llm-execution",
          "phrase": "is recorded during",
          "category": "part_of",
          "description": "LLM debug events are created as part of LLM execution, capturing the request before the model call and the response after completion for a single execution."
        },
        {
          "id": "rel-llm-debug-event-refers-to-llm-provider",
          "from": "llm-debug-event",
          "to": "llm-provider",
          "phrase": "refers to model from",
          "category": "represents",
          "description": "LLM debug events store the model name used for a request or response, indirectly referencing the LLM provider that hosts that model."
        }
      ],
      "rules": [
        {
          "id": "llm-request-must-have-prompt",
          "title": "LLM request must include prompt text",
          "text": "Every LLM request must specify a non-empty prompt string that will be sent to the model.",
          "kind": "constraint",
          "conceptIds": [
            "llm-request"
          ]
        },
        {
          "id": "llm-request-model-default",
          "title": "LLM request uses default model when unspecified",
          "text": "If an LLM request does not specify a model name, the system will default to a predefined model (currently 'gemini-2.5-flash').",
          "kind": "assumption",
          "conceptIds": [
            "llm-request"
          ]
        },
        {
          "id": "llm-request-parameters-are-optional",
          "title": "LLM request parameters are optional",
          "text": "Temperature and maximum token count in an LLM request are optional; when omitted, the provider or system defaults are used.",
          "kind": "assumption",
          "conceptIds": [
            "llm-request"
          ]
        },
        {
          "id": "llm-request-debug-event-correlation",
          "title": "LLM request may be correlated via requestId",
          "text": "When debug context is provided, an LLM request should include or be assigned a requestId so that its debug event can be correlated with related events for the same root timestamp.",
          "kind": "policy",
          "conceptIds": [
            "llm-request"
          ]
        },
        {
          "id": "rule-llm-response-has-text",
          "title": "LLM response must include generated text",
          "text": "Every LLM response must contain a text field representing the primary natural-language output extracted from the provider's raw response.",
          "kind": "invariant",
          "conceptIds": [
            "llm-response"
          ]
        },
        {
          "id": "rule-llm-response-has-model-name",
          "title": "LLM response must record model name",
          "text": "Every LLM response must record the modelName that produced it so that evaluations and debugging can be tied to a specific model configuration.",
          "kind": "invariant",
          "conceptIds": [
            "llm-response"
          ]
        },
        {
          "id": "rule-llm-response-has-elapsed-time",
          "title": "LLM response must record elapsed time",
          "text": "Every LLM response must include elapsedMs, the measured duration between sending the request and receiving the response, to support performance monitoring and evaluation.",
          "kind": "invariant",
          "conceptIds": [
            "llm-response"
          ]
        },
        {
          "id": "rule-llm-response-has-raw-payload",
          "title": "LLM response should preserve raw provider payload",
          "text": "Every LLM response should preserve the rawResponse payload from the LLM provider to enable richer debugging, parsing, and alternative interpretations beyond the primary text field.",
          "kind": "assumption",
          "conceptIds": [
            "llm-response"
          ]
        },
        {
          "id": "rule-llm-context-name-maps-to-md-file",
          "title": "Context name must map to a markdown file",
          "text": "Each LLM context is identified by a name that must correspond to a .md file on disk in either the configured CONTEXT_DIR or the default apps/worker/context directory.",
          "kind": "constraint",
          "conceptIds": [
            "llm-context"
          ]
        },
        {
          "id": "rule-llm-context-file-extension",
          "title": "Context files must use .md extension",
          "text": "Only files with a .md extension are treated as valid LLM context items and are discoverable via listContext and useAllContext.",
          "kind": "constraint",
          "conceptIds": [
            "llm-context"
          ]
        },
        {
          "id": "rule-llm-context-cached-per-name",
          "title": "Context content is cached by name",
          "text": "Once a context file is read for a given name, its content is cached in memory and reused for subsequent accesses with the same name within the worker process.",
          "kind": "assumption",
          "conceptIds": [
            "llm-context"
          ]
        },
        {
          "id": "rule-llm-context-sanitized-for-embedding",
          "title": "Context content must be sanitized before structured embedding",
          "text": "When aggregating all contexts into a single structured string (e.g., XML with CDATA), occurrences of ']]>' in context content are escaped to avoid breaking the surrounding markup.",
          "kind": "policy",
          "conceptIds": [
            "llm-context"
          ]
        },
        {
          "id": "prompt-template-must-have-id-name-template",
          "title": "Prompt template must have core identifiers and content",
          "text": "Each prompt template must have a unique id, a human-readable name, and a template body string that defines the EJS prompt content.",
          "kind": "invariant",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "prompt-template-variables-must-be-satisfied",
          "title": "All declared template variables must be provided at render time",
          "text": "When rendering a prompt template, values must be provided for all variable names listed in the template's variables array; otherwise, template rendering fails.",
          "kind": "constraint",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "prompt-template-versioning",
          "title": "Prompt template versions are tracked and linked",
          "text": "Each prompt template version must have a numeric version identifier and may reference a parentVersion to indicate its lineage from a previous version.",
          "kind": "assumption",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "prompt-template-single-active-version",
          "title": "Only one active version per prompt template id",
          "text": "For a given logical prompt template id, exactly one version is designated as the active version and is the one fetched for use in LLM executions.",
          "kind": "assumption",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "prompt-template-activity-flag",
          "title": "Prompt template version activity is controlled by isActive flag",
          "text": "Each prompt template version has an isActive flag indicating whether that version is eligible to be used as the active version for LLM requests.",
          "kind": "policy",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "prompt-template-creation-metadata",
          "title": "Prompt template versions record creation metadata",
          "text": "Each prompt template version records when it was created and by whom, using createdAt and createdBy fields.",
          "kind": "invariant",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "prompt-template-model-compatibility",
          "title": "Prompt template may be bound to specific LLM models",
          "text": "A prompt template may specify a model identifier, constraining its intended use to that LLM model type.",
          "kind": "policy",
          "conceptIds": [
            "prompt-template"
          ]
        },
        {
          "id": "template-variable-name-must-be-valid-identifier",
          "title": "Template variable names must be valid identifiers",
          "text": "A template variable name must be a valid JavaScript identifier (matching `[a-zA-Z_$][a-zA-Z0-9_$]*`) to be recognized and extracted from an EJS-based prompt template.",
          "kind": "constraint",
          "conceptIds": [
            "template-variable"
          ]
        },
        {
          "id": "template-variable-name-must-not-be-js-keyword",
          "title": "Template variable names must not be JavaScript keywords or built-ins",
          "text": "Names that are JavaScript language keywords or common built-in objects/functions are ignored and cannot be used as template variables in EJS-based prompt templates.",
          "kind": "constraint",
          "conceptIds": [
            "template-variable"
          ]
        },
        {
          "id": "template-variable-value-must-be-json-serializable",
          "title": "Template variable values must be JSON-serializable",
          "text": "The value bound to a template variable must be JSON-serializable (string, number, boolean, null, array, or object composed of such values) so that it can be logged, inspected, and rendered in evaluation UIs.",
          "kind": "assumption",
          "conceptIds": [
            "template-variable"
          ]
        },
        {
          "id": "template-rendering-must-have-all-required-variables",
          "title": "Template rendering requires all declared variables to be provided",
          "text": "When rendering a prompt template, all variables declared by the template must be present in the provided variable map; otherwise, template rendering fails with an error listing the missing variables.",
          "kind": "constraint",
          "conceptIds": [
            "template-rendering"
          ]
        },
        {
          "id": "template-rendering-failure-prevents-llm-request",
          "title": "Failed template rendering prevents LLM request creation",
          "text": "If template rendering fails (for example due to missing variables or EJS errors), no valid prompt string is produced and therefore an LLM request based on that template cannot be issued.",
          "kind": "assumption",
          "conceptIds": [
            "template-rendering"
          ]
        },
        {
          "id": "template-rendering-uses-active-template-version",
          "title": "Template rendering uses the active version of a prompt template",
          "text": "When fetching a prompt template for rendering, the system resolves and uses the active version of that template as stored in the template repository.",
          "kind": "policy",
          "conceptIds": [
            "template-rendering"
          ]
        },
        {
          "id": "rule-llm-exec-default-model",
          "title": "Default model when none specified",
          "text": "If an LLM request does not specify a modelName, LLM execution must default to using the 'gemini-2.5-flash' model.",
          "kind": "constraint",
          "conceptIds": [
            "llm-execution"
          ]
        },
        {
          "id": "rule-llm-exec-requires-prompt",
          "title": "Prompt text is required",
          "text": "LLM execution requires that the LLM request contain a non-empty prompt string to send to the model.",
          "kind": "invariant",
          "conceptIds": [
            "llm-execution"
          ]
        },
        {
          "id": "rule-llm-exec-measures-latency",
          "title": "Execution must measure elapsed time",
          "text": "LLM execution must measure and record the elapsed time between sending the request and receiving the response, exposing it via the LLM response.",
          "kind": "policy",
          "conceptIds": [
            "llm-execution"
          ]
        },
        {
          "id": "rule-llm-exec-logs-request-debug",
          "title": "Request debug event logging",
          "text": "When debug context is provided, LLM execution must record an LLM request debug event containing model, prompt, temperature, maxTokens, requestId, templateId, templateVersion, and templateVariables.",
          "kind": "policy",
          "conceptIds": [
            "llm-execution"
          ]
        },
        {
          "id": "rule-llm-exec-uses-generation-config",
          "title": "Use generation configuration from request",
          "text": "LLM execution must pass temperature and maxTokens from the LLM request into the provider-specific generation configuration when invoking the model.",
          "kind": "constraint",
          "conceptIds": [
            "llm-execution"
          ]
        },
        {
          "id": "llm-provider-requires-project-id",
          "title": "LLM provider requires project identifier",
          "text": "An LLM provider integration must be configured with a valid project identifier (e.g., PROJECT_ID) before any generative model can be created or used.",
          "kind": "constraint",
          "conceptIds": [
            "llm-provider"
          ]
        },
        {
          "id": "llm-provider-requires-region-or-location",
          "title": "LLM provider requires a valid location or region",
          "text": "An LLM provider integration must be configured with a valid region or location before creating or using a generative model, except for models that explicitly require a special global location.",
          "kind": "constraint",
          "conceptIds": [
            "llm-provider"
          ]
        },
        {
          "id": "llm-provider-may-require-special-location-per-model",
          "title": "LLM provider may require model-specific locations",
          "text": "Certain models exposed by the LLM provider may only be available in specific locations (such as a global location), and the system must route requests for those models to the required location.",
          "kind": "assumption",
          "conceptIds": [
            "llm-provider"
          ]
        },
        {
          "id": "llm-provider-model-name-must-be-specified",
          "title": "Model name must be specified for LLM provider access",
          "text": "To obtain a generative model from the LLM provider, the system must specify a concrete model name recognized by that provider.",
          "kind": "constraint",
          "conceptIds": [
            "llm-provider"
          ]
        },
        {
          "id": "rule-llm-debug-event-has-type-and-timestamp",
          "title": "LLM debug event must have a type and timestamp",
          "text": "Every LLM debug event must specify a 'type' discriminator and an ISO-8601 'timestamp' string so that it can be interpreted and ordered during later inspection.",
          "kind": "invariant",
          "conceptIds": [
            "llm-debug-event"
          ]
        },
        {
          "id": "rule-llm-debug-event-type-specific-data-shape",
          "title": "LLM debug event data must match its type",
          "text": "The 'data' payload of an LLM debug event must conform to the structure defined for its 'type' (e.g., 'llm_request' events must include model, prompt, and optional template metadata; 'llm_response' events must include model, rawResponse, and elapsedMs).",
          "kind": "constraint",
          "conceptIds": [
            "llm-debug-event"
          ]
        },
        {
          "id": "rule-llm-debug-event-non-fatal-on-failure",
          "title": "Failure to record LLM debug event must not disrupt main flow",
          "text": "If recording an LLM debug event fails (for example, due to Firestore issues), the system should log the failure but must not throw an error that interrupts the primary LLM execution or user-facing operation.",
          "kind": "policy",
          "conceptIds": [
            "llm-debug-event"
          ]
        },
        {
          "id": "rule-llm-debug-event-identified-per-thread",
          "title": "LLM debug events are stored per root thread",
          "text": "Each LLM debug event is stored under a Slack root thread identifier (rootTs), grouping all debug events related to that conversation thread for coherent inspection.",
          "kind": "assumption",
          "conceptIds": [
            "llm-debug-event"
          ]
        },
        {
          "id": "rule-llm-debug-event-unique-id-per-type-timestamp",
          "title": "LLM debug event identifier is derived from type and timestamp",
          "text": "An LLM debug event's storage identifier is constructed from its type and timestamp, ensuring uniqueness within a thread's debugEvents subcollection.",
          "kind": "assumption",
          "conceptIds": [
            "llm-debug-event"
          ]
        }
      ],
      "lifecycles": [
        {
          "id": "prompt-template-version-lifecycle",
          "subjectConceptId": "prompt-template",
          "stateConceptIds": [
            "prompt-template-draft",
            "prompt-template-active",
            "prompt-template-inactive"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "prompt-template-draft",
          "terminalStateIds": [
            "prompt-template-inactive"
          ]
        }
      ],
      "views": [
        {
          "id": "llm-orchestration-overview",
          "name": "LLM orchestration overview",
          "kind": "overview",
          "description": "High-level flow from prompt definition through LLM execution to responses and debug logging.",
          "groups": [
            {
              "id": "prompt-design",
              "name": "Prompt design",
              "conceptIds": [
                "prompt-template",
                "template-variable"
              ]
            },
            {
              "id": "prompt-materialization",
              "name": "Prompt materialization",
              "conceptIds": [
                "template-rendering",
                "llm-request"
              ]
            },
            {
              "id": "execution-and-output",
              "name": "Execution and output",
              "conceptIds": [
                "llm-execution",
                "llm-response",
                "llm-debug-event"
              ]
            }
          ],
          "conceptIds": [
            "prompt-template",
            "template-variable",
            "template-rendering",
            "llm-request",
            "llm-execution",
            "llm-response",
            "llm-debug-event"
          ],
          "relationshipIds": [
            "prompt-template-uses-template-variable",
            "prompt-template-enables-template-rendering",
            "prompt-template-precedes-llm-request",
            "template-rendering-uses-prompt-template",
            "template-rendering-uses-template-variable",
            "template-rendering-precedes-llm-request",
            "llm-request-enables-llm-execution",
            "rel-llm-exec-produces-llm-response",
            "rel-llm-exec-logged-as-llm-debug-event",
            "rel-llm-debug-event-logs-llm-response"
          ]
        },
        {
          "id": "prompt-construction-and-context",
          "name": "Prompt construction and context use",
          "kind": "structure",
          "description": "How templates, variables, and context combine to form a concrete LLM request.",
          "groups": [
            {
              "id": "prompt-structure",
              "name": "Prompt structure",
              "conceptIds": [
                "prompt-template",
                "template-variable"
              ]
            },
            {
              "id": "context-source",
              "name": "Context source",
              "conceptIds": [
                "llm-context"
              ]
            },
            {
              "id": "prompt-instantiation",
              "name": "Prompt instantiation",
              "conceptIds": [
                "template-rendering",
                "llm-request"
              ]
            }
          ],
          "conceptIds": [
            "prompt-template",
            "template-variable",
            "llm-context",
            "template-rendering",
            "llm-request"
          ],
          "relationshipIds": [
            "prompt-template-uses-template-variable",
            "prompt-template-represents-llm-context",
            "template-variable-may-represent-llm-context",
            "template-rendering-uses-prompt-template",
            "template-rendering-uses-template-variable",
            "template-rendering-may-use-llm-context",
            "template-rendering-precedes-llm-request",
            "llm-request-uses-llm-context",
            "llm-request-derived-from-prompt-template",
            "llm-request-parameterizes-template-variables"
          ]
        },
        {
          "id": "llm-execution-plumbing",
          "name": "LLM execution plumbing",
          "kind": "implementation",
          "description": "Technical flow of an LLM call: request, provider, execution, response, and debug logging.",
          "groups": [
            {
              "id": "call-preparation",
              "name": "Call preparation",
              "conceptIds": [
                "llm-request"
              ]
            },
            {
              "id": "provider",
              "name": "LLM provider",
              "conceptIds": [
                "llm-provider"
              ]
            },
            {
              "id": "runtime",
              "name": "Execution runtime",
              "conceptIds": [
                "llm-execution"
              ]
            },
            {
              "id": "results-and-logging",
              "name": "Results and logging",
              "conceptIds": [
                "llm-response",
                "llm-debug-event"
              ]
            }
          ],
          "conceptIds": [
            "llm-request",
            "llm-provider",
            "llm-execution",
            "llm-response",
            "llm-debug-event"
          ],
          "relationshipIds": [
            "llm-request-uses-llm-provider",
            "llm-request-enables-llm-execution",
            "rel-llm-exec-uses-llm-request",
            "rel-llm-exec-uses-llm-provider",
            "llm-provider-hosts-models",
            "rel-llm-exec-produces-llm-response",
            "llm-provider-produces-llm-response",
            "llm-request-records-llm-debug-event",
            "rel-llm-exec-logged-as-llm-debug-event",
            "llm-response-logged-as-debug-event"
          ]
        },
        {
          "id": "context-influence-on-llm",
          "name": "Context influence on LLM behavior",
          "kind": "lifecycle",
          "description": "How LLM context flows into requests, shapes responses, and is captured for later analysis.",
          "groups": [
            {
              "id": "context",
              "name": "Context",
              "conceptIds": [
                "llm-context"
              ]
            },
            {
              "id": "prompt-and-execution",
              "name": "Prompt and execution",
              "conceptIds": [
                "llm-request",
                "llm-execution"
              ]
            },
            {
              "id": "outcome",
              "name": "Outcome",
              "conceptIds": [
                "llm-response"
              ]
            },
            {
              "id": "observability",
              "name": "Observability",
              "conceptIds": [
                "llm-debug-event"
              ]
            }
          ],
          "conceptIds": [
            "llm-context",
            "llm-request",
            "llm-execution",
            "llm-response",
            "llm-debug-event"
          ],
          "relationshipIds": [
            "llm-request-uses-llm-context",
            "rel-llm-context-used-by-llm-request",
            "rel-llm-exec-reflects-llm-context",
            "rel-llm-context-influences-llm-response",
            "llm-response-uses-context",
            "rel-llm-debug-event-reflects-llm-context",
            "rel-llm-context-logged-via-llm-debug-event",
            "rel-llm-debug-event-logs-llm-request",
            "rel-llm-debug-event-logs-llm-response"
          ]
        },
        {
          "id": "debug-event-as-observability-hub",
          "name": "LLM debug event as observability hub",
          "kind": "datastore",
          "description": "What an LLM debug event ties together: request, response, template, variables, context, and provider.",
          "groups": [
            {
              "id": "inputs",
              "name": "Inputs",
              "conceptIds": [
                "llm-request",
                "prompt-template",
                "template-variable"
              ]
            },
            {
              "id": "runtime-and-provider",
              "name": "Runtime and provider",
              "conceptIds": [
                "llm-execution",
                "llm-provider"
              ]
            },
            {
              "id": "outputs",
              "name": "Outputs",
              "conceptIds": [
                "llm-response"
              ]
            },
            {
              "id": "logging",
              "name": "Logging",
              "conceptIds": [
                "llm-context",
                "llm-debug-event"
              ]
            }
          ],
          "conceptIds": [
            "llm-request",
            "prompt-template",
            "template-variable",
            "llm-execution",
            "llm-provider",
            "llm-response",
            "llm-context",
            "llm-debug-event"
          ],
          "relationshipIds": [
            "rel-llm-debug-event-logs-llm-request",
            "rel-llm-debug-event-logs-llm-response",
            "rel-llm-debug-event-reflects-llm-context",
            "rel-llm-debug-event-references-prompt-template",
            "rel-llm-debug-event-includes-template-variables",
            "rel-llm-debug-event-recorded-during-llm-execution",
            "rel-llm-debug-event-refers-to-llm-provider",
            "llm-request-records-llm-debug-event",
            "rel-llm-exec-logged-as-llm-debug-event",
            "llm-response-logged-as-debug-event"
          ]
        }
      ],
      "storyViews": [
        {
          "id": "basic-llm-call-from-template-to-response",
          "name": "Basic LLM Call: From Template to Response",
          "kind": "system_flow",
          "description": "A straightforward orchestration where a prompt template is rendered with variables, sent to an LLM provider, and the response is logged for later inspection.",
          "tags": [
            "happy-path",
            "single-call",
            "prompting"
          ],
          "focusConceptId": "llm-request",
          "steps": [
            {
              "id": "select-prompt-template-and-variables",
              "index": 0,
              "title": "Select Prompt Template and Required Variables",
              "narrative": "The system selects an appropriate prompt template and identifies the template variables that must be filled before calling the LLM.",
              "conceptIds": [
                "prompt-template",
                "template-variable"
              ],
              "relationshipIds": [
                "prompt-template-uses-template-variable",
                "template-variable-declared-by-prompt-template"
              ],
              "primaryConceptIds": [
                "prompt-template"
              ],
              "primaryRelationshipIds": [
                "prompt-template-uses-template-variable"
              ]
            },
            {
              "id": "render-template-into-concrete-prompt",
              "index": 1,
              "title": "Render Template into a Concrete Prompt",
              "narrative": "The template rendering process substitutes concrete values for each template variable, producing finalized prompt text ready to be sent as an LLM request.",
              "conceptIds": [
                "template-rendering",
                "prompt-template",
                "template-variable",
                "llm-request"
              ],
              "relationshipIds": [
                "template-rendering-uses-prompt-template",
                "template-rendering-uses-template-variable",
                "template-rendering-precedes-llm-request",
                "llm-request-uses-template-rendering",
                "llm-request-parameterizes-template-variables"
              ],
              "primaryConceptIds": [
                "template-rendering",
                "llm-request"
              ],
              "primaryRelationshipIds": [
                "template-rendering-precedes-llm-request"
              ]
            },
            {
              "id": "send-llm-request-to-provider",
              "index": 2,
              "title": "Send LLM Request to Provider",
              "narrative": "The system packages the rendered prompt and parameters into an LLM request and sends it to the chosen LLM provider, enabling an LLM execution.",
              "conceptIds": [
                "llm-request",
                "llm-execution",
                "llm-provider"
              ],
              "relationshipIds": [
                "llm-request-enables-llm-execution",
                "llm-request-uses-llm-provider",
                "rel-llm-exec-uses-llm-request",
                "rel-llm-exec-uses-llm-provider",
                "llm-provider-serves-llm-request",
                "llm-provider-hosts-models"
              ],
              "primaryConceptIds": [
                "llm-request",
                "llm-execution"
              ],
              "primaryRelationshipIds": [
                "llm-request-enables-llm-execution"
              ]
            },
            {
              "id": "provider-produces-llm-response",
              "index": 3,
              "title": "Provider Executes and Produces LLM Response",
              "narrative": "The LLM provider runs the model, and the LLM execution produces an LLM response that is returned to the system.",
              "conceptIds": [
                "llm-execution",
                "llm-response",
                "llm-provider"
              ],
              "relationshipIds": [
                "rel-llm-exec-produces-llm-response",
                "llm-response-part-of-execution",
                "llm-response-uses-provider",
                "llm-provider-produces-llm-response"
              ],
              "primaryConceptIds": [
                "llm-response"
              ],
              "primaryRelationshipIds": [
                "rel-llm-exec-produces-llm-response"
              ]
            },
            {
              "id": "log-request-and-response-for-debugging",
              "index": 4,
              "title": "Log Request and Response for Debugging",
              "narrative": "The system records an LLM debug event that captures details of the LLM request, the LLM response, and the provider used, enabling later troubleshooting and evaluation.",
              "conceptIds": [
                "llm-request",
                "llm-response",
                "llm-debug-event",
                "llm-provider"
              ],
              "relationshipIds": [
                "llm-request-records-llm-debug-event",
                "llm-response-logged-as-debug-event",
                "rel-llm-debug-event-logs-llm-request",
                "rel-llm-debug-event-logs-llm-response",
                "rel-llm-debug-event-refers-to-llm-provider",
                "llm-provider-is-captured-by-llm-debug-event"
              ],
              "primaryConceptIds": [
                "llm-debug-event"
              ],
              "primaryRelationshipIds": [
                "llm-request-records-llm-debug-event"
              ]
            }
          ]
        },
        {
          "id": "context-rich-iteration-on-data-request",
          "name": "Context-Rich Iteration on a Data Request",
          "kind": "user_flow",
          "description": "A user iterates on a data-related question, with the system carrying forward LLM context and updating template variables to refine responses.",
          "tags": [
            "iteration",
            "context",
            "data-requests"
          ],
          "focusConceptId": "llm-context",
          "steps": [
            {
              "id": "initialize-context-and-template",
              "index": 0,
              "title": "Initialize LLM Context and Select Template",
              "narrative": "The system gathers initial background facts and prior messages into LLM context and selects a prompt template that structures how this context will be included.",
              "conceptIds": [
                "llm-context",
                "prompt-template",
                "template-variable"
              ],
              "relationshipIds": [
                "prompt-template-represents-llm-context",
                "prompt-template-uses-template-variable",
                "template-variable-may-represent-llm-context"
              ],
              "primaryConceptIds": [
                "llm-context",
                "prompt-template"
              ],
              "primaryRelationshipIds": [
                "prompt-template-represents-llm-context"
              ]
            },
            {
              "id": "render-context-aware-prompt",
              "index": 1,
              "title": "Render a Context-Aware Prompt",
              "narrative": "Template rendering pulls values from the LLM context into template variables, producing a prompt that embeds relevant history and constraints.",
              "conceptIds": [
                "template-rendering",
                "llm-context",
                "template-variable",
                "llm-request"
              ],
              "relationshipIds": [
                "template-rendering-may-use-llm-context",
                "template-rendering-uses-template-variable",
                "template-variable-may-represent-llm-context",
                "template-rendering-precedes-llm-request",
                "llm-request-uses-llm-context",
                "rel-llm-context-used-by-llm-request"
              ],
              "primaryConceptIds": [
                "template-rendering",
                "llm-context"
              ],
              "primaryRelationshipIds": [
                "template-rendering-may-use-llm-context"
              ]
            },
            {
              "id": "execute-llm-call-with-context",
              "index": 2,
              "title": "Execute LLM Call with Embedded Context",
              "narrative": "The LLM execution consumes the context-rich LLM request, invokes the providerâ€™s model, and produces a response that reflects the supplied context.",
              "conceptIds": [
                "llm-execution",
                "llm-request",
                "llm-response",
                "llm-context",
                "llm-provider"
              ],
              "relationshipIds": [
                "rel-llm-exec-uses-llm-request",
                "rel-llm-exec-uses-llm-provider",
                "rel-llm-exec-produces-llm-response",
                "rel-llm-exec-reflects-llm-context",
                "llm-response-uses-context",
                "rel-llm-context-influences-llm-response",
                "llm-response-uses-provider"
              ],
              "primaryConceptIds": [
                "llm-execution",
                "llm-response"
              ],
              "primaryRelationshipIds": [
                "rel-llm-exec-reflects-llm-context"
              ]
            },
            {
              "id": "update-context-from-response",
              "index": 3,
              "title": "Update LLM Context from Response",
              "narrative": "The system incorporates key parts of the LLM response back into LLM context so that follow-up questions can build on the latest answer.",
              "conceptIds": [
                "llm-response",
                "llm-context"
              ],
              "relationshipIds": [
                "llm-response-uses-context",
                "rel-llm-context-influences-llm-response"
              ],
              "primaryConceptIds": [
                "llm-context"
              ],
              "primaryRelationshipIds": []
            },
            {
              "id": "iterate-with-refined-variables",
              "index": 4,
              "title": "Iterate with Refined Template Variables",
              "narrative": "On the next turn, the system adjusts template variables based on the updated context and user feedback, re-renders the template, and issues another LLM request for a refined answer.",
              "conceptIds": [
                "template-variable",
                "template-rendering",
                "llm-context",
                "llm-request"
              ],
              "relationshipIds": [
                "template-variable-may-represent-llm-context",
                "template-rendering-may-use-llm-context",
                "template-rendering-uses-template-variable",
                "template-rendering-precedes-llm-request",
                "llm-request-parameterizes-template-variables",
                "llm-request-uses-llm-context"
              ],
              "primaryConceptIds": [
                "template-variable",
                "llm-request"
              ],
              "primaryRelationshipIds": [
                "template-rendering-precedes-llm-request"
              ]
            },
            {
              "id": "log-iterative-debug-events",
              "index": 5,
              "title": "Log Iterative Debug Events",
              "narrative": "Each iteration records an LLM debug event that captures evolving context, template variables, and responses, enabling later analysis of how the conversation evolved.",
              "conceptIds": [
                "llm-debug-event",
                "llm-context",
                "template-variable",
                "llm-response"
              ],
              "relationshipIds": [
                "rel-llm-debug-event-reflects-llm-context",
                "rel-llm-debug-event-includes-template-variables",
                "rel-llm-debug-event-logs-llm-response",
                "rel-llm-debug-event-recorded-during-llm-execution",
                "rel-llm-context-logged-via-llm-debug-event"
              ],
              "primaryConceptIds": [
                "llm-debug-event"
              ],
              "primaryRelationshipIds": [
                "rel-llm-debug-event-reflects-llm-context"
              ]
            }
          ]
        },
        {
          "id": "admin-configures-provider-specific-template",
          "name": "Admin Configures a Provider-Specific Prompt Template",
          "kind": "admin_flow",
          "description": "An admin configures a prompt template that is constrained by a particular LLM providerâ€™s capabilities and prepares it for consistent execution and debugging.",
          "tags": [
            "admin",
            "configuration",
            "provider-constraints"
          ],
          "focusConceptId": "prompt-template",
          "steps": [
            {
              "id": "analyze-provider-constraints",
              "index": 0,
              "title": "Analyze LLM Provider Constraints",
              "narrative": "The admin reviews the chosen LLM providerâ€™s limits and capabilities, which will constrain how the prompt template can be structured and what context can be included.",
              "conceptIds": [
                "llm-provider",
                "prompt-template",
                "llm-context"
              ],
              "relationshipIds": [
                "llm-provider-constrains-prompt-template",
                "llm-provider-influences-llm-context",
                "prompt-template-uses-llm-provider"
              ],
              "primaryConceptIds": [
                "llm-provider",
                "prompt-template"
              ],
              "primaryRelationshipIds": [
                "llm-provider-constrains-prompt-template"
              ]
            },
            {
              "id": "define-template-and-variables",
              "index": 1,
              "title": "Define Prompt Template and Its Variables",
              "narrative": "The admin creates a prompt template that declares required template variables and specifies how LLM context will be structured within the prompt.",
              "conceptIds": [
                "prompt-template",
                "template-variable",
                "llm-context"
              ],
              "relationshipIds": [
                "prompt-template-uses-template-variable",
                "template-variable-declared-by-prompt-template",
                "prompt-template-represents-llm-context"
              ],
              "primaryConceptIds": [
                "prompt-template"
              ],
              "primaryRelationshipIds": [
                "prompt-template-uses-template-variable"
              ]
            },
            {
              "id": "test-template-rendering",
              "index": 2,
              "title": "Test Template Rendering with Sample Values",
              "narrative": "The admin runs a test template rendering using sample variable values and mock context to verify that the resulting prompt text is well-formed and within provider limits.",
              "conceptIds": [
                "template-rendering",
                "prompt-template",
                "template-variable",
                "llm-context",
                "llm-request"
              ],
              "relationshipIds": [
                "prompt-template-enables-template-rendering",
                "template-rendering-uses-prompt-template",
                "template-rendering-uses-template-variable",
                "template-rendering-may-use-llm-context",
                "template-rendering-precedes-llm-request",
                "llm-request-derived-from-prompt-template"
              ],
              "primaryConceptIds": [
                "template-rendering"
              ],
              "primaryRelationshipIds": [
                "prompt-template-enables-template-rendering"
              ]
            },
            {
              "id": "run-validation-execution",
              "index": 3,
              "title": "Run a Validation LLM Execution",
              "narrative": "Using the rendered prompt, the admin triggers an LLM execution against the provider to validate that the model behaves as expected with the new template.",
              "conceptIds": [
                "llm-request",
                "llm-execution",
                "llm-response",
                "llm-provider"
              ],
              "relationshipIds": [
                "llm-request-enables-llm-execution",
                "rel-llm-exec-uses-llm-request",
                "rel-llm-exec-uses-llm-provider",
                "rel-llm-exec-produces-llm-response",
                "llm-provider-serves-llm-request",
                "llm-provider-produces-llm-response"
              ],
              "primaryConceptIds": [
                "llm-execution"
              ],
              "primaryRelationshipIds": [
                "rel-llm-exec-produces-llm-response"
              ]
            },
            {
              "id": "inspect-debug-event-for-template-validation",
              "index": 4,
              "title": "Inspect Debug Event for Template Validation",
              "narrative": "The admin examines the LLM debug event to confirm that the template, variables, context, and provider details are correctly captured and suitable for production use.",
              "conceptIds": [
                "llm-debug-event",
                "prompt-template",
                "template-variable",
                "llm-context",
                "llm-provider",
                "llm-response"
              ],
              "relationshipIds": [
                "rel-llm-debug-event-references-prompt-template",
                "rel-llm-debug-event-includes-template-variables",
                "rel-llm-debug-event-reflects-llm-context",
                "rel-llm-debug-event-refers-to-llm-provider",
                "rel-llm-debug-event-logs-llm-response"
              ],
              "primaryConceptIds": [
                "llm-debug-event"
              ],
              "primaryRelationshipIds": [
                "rel-llm-debug-event-references-prompt-template"
              ]
            }
          ]
        },
        {
          "id": "error-handling-when-provider-fails",
          "name": "Error Handling When LLM Provider Fails",
          "kind": "error_flow",
          "description": "The system attempts an LLM execution, encounters a provider-level failure, and uses debug events and context to support diagnosis and potential retry.",
          "tags": [
            "error",
            "provider-failure",
            "observability"
          ],
          "focusConceptId": "llm-debug-event",
          "steps": [
            {
              "id": "prepare-request-for-execution",
              "index": 0,
              "title": "Prepare LLM Request for Execution",
              "narrative": "The system renders a prompt from a template and context, then constructs an LLM request that is ready to be sent to the provider.",
              "conceptIds": [
                "prompt-template",
                "template-rendering",
                "template-variable",
                "llm-context",
                "llm-request"
              ],
              "relationshipIds": [
                "prompt-template-enables-template-rendering",
                "template-rendering-uses-prompt-template",
                "template-rendering-uses-template-variable",
                "template-rendering-may-use-llm-context",
                "template-rendering-precedes-llm-request",
                "llm-request-uses-llm-context",
                "llm-request-parameterizes-template-variables"
              ],
              "primaryConceptIds": [
                "llm-request"
              ],
              "primaryRelationshipIds": [
                "template-rendering-precedes-llm-request"
              ]
            },
            {
              "id": "attempt-execution-with-provider",
              "index": 1,
              "title": "Attempt LLM Execution with Provider",
              "narrative": "The system sends the LLM request to the provider, initiating an LLM execution that is expected to produce a response.",
              "conceptIds": [
                "llm-request",
                "llm-execution",
                "llm-provider"
              ],
              "relationshipIds": [
                "llm-request-enables-llm-execution",
                "rel-llm-exec-uses-llm-request",
                "rel-llm-exec-uses-llm-provider",
                "llm-provider-serves-llm-request",
                "llm-provider-hosts-models"
              ],
              "primaryConceptIds": [
                "llm-execution"
              ],
              "primaryRelationshipIds": [
                "llm-request-enables-llm-execution"
              ]
            },
            {
              "id": "provider-fails-to-produce-response",
              "index": 2,
              "title": "Provider Fails to Produce a Valid Response",
              "narrative": "Due to an outage or constraint violation, the provider does not return a valid LLM response, causing the execution to fail without usable content.",
              "conceptIds": [
                "llm-execution",
                "llm-response",
                "llm-provider"
              ],
              "relationshipIds": [
                "rel-llm-exec-produces-llm-response",
                "llm-provider-produces-llm-response"
              ],
              "primaryConceptIds": [
                "llm-execution"
              ],
              "primaryRelationshipIds": []
            },
            {
              "id": "record-detailed-debug-event",
              "index": 3,
              "title": "Record Detailed Debug Event for Failure",
              "narrative": "The system records an LLM debug event that captures the failed request, any partial response or error metadata, the provider used, and relevant context.",
              "conceptIds": [
                "llm-debug-event",
                "llm-request",
                "llm-response",
                "llm-context",
                "llm-provider",
                "llm-execution"
              ],
              "relationshipIds": [
                "llm-request-records-llm-debug-event",
                "llm-response-logged-as-debug-event",
                "rel-llm-debug-event-logs-llm-request",
                "rel-llm-debug-event-logs-llm-response",
                "rel-llm-debug-event-reflects-llm-context",
                "rel-llm-debug-event-refers-to-llm-provider",
                "rel-llm-debug-event-recorded-during-llm-execution",
                "llm-provider-is-captured-by-llm-debug-event",
                "rel-llm-exec-logged-as-llm-debug-event"
              ],
              "primaryConceptIds": [
                "llm-debug-event"
              ],
              "primaryRelationshipIds": [
                "rel-llm-exec-logged-as-llm-debug-event"
              ]
            },
            {
              "id": "support-diagnosis-and-retry",
              "index": 4,
              "title": "Support Diagnosis and Potential Retry",
              "narrative": "Operators inspect the debug event, reviewing the original template, variables, and context to decide whether to adjust the prompt, switch providers, or retry later.",
              "conceptIds": [
                "llm-debug-event",
                "prompt-template",
                "template-variable",
                "llm-context",
                "llm-provider"
              ],
              "relationshipIds": [
                "rel-llm-debug-event-references-prompt-template",
                "rel-llm-debug-event-includes-template-variables",
                "rel-llm-debug-event-reflects-llm-context",
                "rel-llm-debug-event-refers-to-llm-provider"
              ],
              "primaryConceptIds": [
                "llm-debug-event"
              ],
              "primaryRelationshipIds": [
                "rel-llm-debug-event-references-prompt-template"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "template-management-and-evals",
      "title": "Template Management and Evaluation",
      "description": "How administrators manage prompt templates, define test cases and checks, and evaluate LLM behavior over time.",
      "concepts": [
        {
          "id": "template",
          "label": "Template",
          "category": "thing",
          "description": "A configurable unit that defines how the system should prompt the LLM for a particular task or workflow.",
          "aliases": [
            "PromptTemplate",
            "Template metadata",
            "promptTemplates document",
            "Template"
          ],
          "notes": "A Template is the logical, named prompt configuration for a particular LLM task or workflow. In storage, it appears as a document in the `promptTemplates` collection that holds stable metadata (id, name, description, tags, activeVersion, default model, timestamps). The actual prompt text and variable definitions live in associated Template versions. Runtime workers fetch the Template's currently active Template version and treat the combined structure as a PromptTemplate when calling the LLM. The TemplateManager UI lets users browse Templates, select one, edit or add Template versions, and explicitly choose which version is active for production use."
        },
        {
          "id": "template-version",
          "label": "Template version",
          "category": "thing",
          "description": "A specific revision of a template, allowing changes to be tracked, tested, and activated independently.",
          "aliases": [
            "TemplateVersion",
            "version",
            "activeVersion",
            "prompt template version"
          ],
          "notes": "A template version is a numbered snapshot of a Template's prompt text, variables, and related metadata (model, author, timestamps, change notes). Versions are stored under a Template's `versions` subcollection and one of them is marked as active for production use."
        },
        {
          "id": "active-template",
          "label": "Active template",
          "category": "state",
          "description": "The currently selected version of a template that is used in production LLM calls.",
          "aliases": [
            "Active template",
            "activeVersion",
            "isActive",
            "fetchActiveTemplate",
            "active version"
          ],
          "notes": "An Active template is the specific Template version currently designated for use in production LLM calls. It is identified via the template-level `activeVersion` metadata and corresponds to a single stored Template version document whose `isActive` flag is true. Fetching an Active template resolves the templateâ€™s metadata together with the content and configuration of the active version into a single PromptTemplate object used at runtime."
        },
        {
          "id": "template-editing",
          "label": "Template editing",
          "category": "activity",
          "description": "The act of modifying template content, variables, and configuration through an editor interface.",
          "aliases": [
            "TemplateEditorTab",
            "template editor",
            "template editing mode",
            "editingTemplate",
            "isEditing",
            "template code editor",
            "CodeMirror template editor",
            "EJS template editor"
          ],
          "notes": "Template editing is the interactive activity where a user modifies the text of a template (often EJS-like prompt code), its variables, and related configuration (such as model selection and change notes) through an editor UI. In the code, this is primarily represented by the TemplateEditorTab component, which embeds a CodeMirror-based EJS-aware editor. The editor supports read-only vs editable modes, syntax highlighting for EJS delimiters and control structures, and tracks an 'editingTemplate' value separate from the currently selected template version. Saving changes typically creates or updates a template version and may later be made active."
        },
        {
          "id": "test-case",
          "label": "Test case",
          "category": "thing",
          "description": "An example input and expected behavior used to evaluate how a template and LLM perform.",
          "aliases": [
            "TestCase",
            "test case"
          ],
          "notes": "A test case is a saved example scenario used in the evals UI to exercise a Template. It captures a named set of inputVariables (matching the template's variables), optional tags and description, and a list of Check IDs that should be applied when the test is executed. Test cases are currently UI-only and stored per template (e.g., under 'promptTemplates/{templateId}/testCases'). They are created, edited, executed individually, or executed as part of a Test batch, and their outcomes are recorded as Test run results."
        },
        {
          "id": "check",
          "label": "Check",
          "category": "thing",
          "description": "A rule or assertion applied to LLM outputs to determine whether they meet certain criteria.",
          "aliases": [
            "Check",
            "evaluation check",
            "LLM check",
            "validation check"
          ],
          "notes": "A Check is a reusable, named rule that describes criteria for judging whether an LLMâ€™s output for a test case is acceptable. Each Check stores natural-language criteria and the LLM model that should be used to perform the evaluation. Checks are persisted in a shared 'checks' collection, can be created/edited/deleted via the UI, and are referenced by test cases. During test execution, the system uses a dedicated check_validation template to turn a Checkâ€™s criteria plus the test input/output into an LLM prompt, whose response is interpreted as pass/fail and reasoning, producing CheckResult records."
        },
        {
          "id": "test-execution",
          "label": "Test execution",
          "category": "activity",
          "description": "Running templates against test cases and applying checks to produce evaluation results.",
          "aliases": [
            "Test execution",
            "executeTest",
            "test execution job",
            "test-execution job",
            "test run",
            "test execution task"
          ],
          "notes": "Test execution is the operational act of running a single test case against a specific template (typically its active template version), invoking the LLM, and applying the configured checks to produce a test run result. It may be initiated from the UI (via a callable function) and is actually processed by a worker job, often as part of a test batch."
        },
        {
          "id": "test-run-result",
          "label": "Test run result",
          "category": "thing",
          "description": "The outcome of executing a test case, including pass, fail, or error details.",
          "aliases": [
            "TestRunResult",
            "Test run",
            "Test run pass",
            "Test run fail",
            "Test run error",
            "TestRunPass",
            "TestRunFail",
            "TestRunError"
          ],
          "notes": "A test run result captures the outcome of executing a single test case against a specific template/template version, including timing, execution context, and any check-level evaluation results. It is modeled as a discriminated union with three variants: pass, fail, and error."
        },
        {
          "id": "test-batch",
          "label": "Test batch",
          "category": "thing",
          "description": "A grouped set of test executions run together, often to evaluate a template change across many scenarios.",
          "aliases": [
            "TestBatch",
            "batch",
            "test batch",
            "testBatches"
          ],
          "notes": "A Test batch groups multiple test executions (often across many test cases) for a given template into a single, trackable unit. It is persisted as a Firestore document (collection `testBatches`) and is referenced by a `batchId` in all associated test execution tasks and results. The UI surfaces batch-level progress, status, and details, and allows cancellation while the batch is running."
        }
      ],
      "relationships": [
        {
          "id": "template-has-template-versions",
          "from": "template",
          "to": "template-version",
          "phrase": "has",
          "category": "part_of",
          "description": "A Template has one or more Template versions, each capturing a specific revision of the prompt content and configuration."
        },
        {
          "id": "template-selects-active-template",
          "from": "template",
          "to": "active-template",
          "phrase": "selects",
          "category": "uses",
          "description": "A Template selects one of its Template versions as the Active template, which is used for production LLM calls."
        },
        {
          "id": "template-participates-in-template-editing",
          "from": "template",
          "to": "template-editing",
          "phrase": "is subject of",
          "category": "other",
          "description": "Template editing operations in the TemplateManager UI act on a specific Template and its Template versions."
        },
        {
          "id": "template-used-in-test-case",
          "from": "template",
          "to": "test-case",
          "phrase": "is exercised by",
          "category": "uses",
          "description": "Test cases are defined and run against a specific Template (via one of its versions) to evaluate its behavior."
        },
        {
          "id": "template-used-in-test-execution",
          "from": "template",
          "to": "test-execution",
          "phrase": "is used in",
          "category": "uses",
          "description": "During test execution, a Template (through a chosen Template version) is rendered and sent to the LLM to produce outputs for evaluation."
        },
        {
          "id": "template-evaluated-by-test-run-result",
          "from": "template",
          "to": "test-run-result",
          "phrase": "is evaluated in",
          "category": "other",
          "description": "Each test run result reflects how a particular Template configuration performed for a given test case."
        },
        {
          "id": "template-included-in-test-batch",
          "from": "template",
          "to": "test-batch",
          "phrase": "is evaluated across",
          "category": "uses",
          "description": "A test batch can run many test executions for a Template to assess the impact of Template changes across scenarios."
        },
        {
          "id": "rel-template-version-of-template",
          "from": "template-version",
          "to": "template",
          "phrase": "is version of",
          "category": "part_of",
          "description": "Each template version belongs to a specific template and is stored under that template's versions collection."
        },
        {
          "id": "rel-template-has-template-versions",
          "from": "template",
          "to": "template-version",
          "phrase": "has versions",
          "category": "part_of",
          "description": "A template can have multiple template versions, each representing a different revision of the template's content and configuration."
        },
        {
          "id": "rel-template-version-can-be-active-template",
          "from": "template-version",
          "to": "active-template",
          "phrase": "can serve as",
          "category": "represents",
          "description": "A template version can be designated as the active template for its parent template, meaning it is used in production LLM calls."
        },
        {
          "id": "rel-template-selects-active-version",
          "from": "template",
          "to": "template-version",
          "phrase": "selects active version",
          "category": "uses",
          "description": "A template records which template version is currently active via its activeVersion field."
        },
        {
          "id": "rel-template-version-used-in-test-execution",
          "from": "template-version",
          "to": "test-execution",
          "phrase": "is used in",
          "category": "uses",
          "description": "A specific template version is used when running test executions so that evaluation results can be tied to a concrete revision of the template."
        },
        {
          "id": "rel-template-version-evaluated-in-test-run-result",
          "from": "template-version",
          "to": "test-run-result",
          "phrase": "is evaluated in",
          "category": "other",
          "description": "Test run results conceptually correspond to the behavior of a particular template version under given test cases and checks."
        },
        {
          "id": "rel-template-version-evaluated-across-test-batch",
          "from": "template-version",
          "to": "test-batch",
          "phrase": "is evaluated across",
          "category": "uses",
          "description": "A test batch can be used to evaluate a specific template version across many scenarios."
        },
        {
          "id": "rel-template-version-subject-of-editing",
          "from": "template-version",
          "to": "template-editing",
          "phrase": "is subject of",
          "category": "other",
          "description": "Template editing activities create new template versions or modify draft versions before they are activated."
        },
        {
          "id": "active-template-from-template",
          "from": "active-template",
          "to": "template",
          "phrase": "is selected for",
          "category": "represents",
          "description": "An Active template represents the currently selected version of a Template that should be used for production LLM calls."
        },
        {
          "id": "active-template-from-template-version",
          "from": "active-template",
          "to": "template-version",
          "phrase": "is realized as",
          "category": "represents",
          "description": "An Active template is realized as a specific Template version document whose content, variables, and metadata are used at runtime."
        },
        {
          "id": "active-template-uses-template-version",
          "from": "active-template",
          "to": "template-version",
          "phrase": "combines metadata with",
          "category": "uses",
          "description": "An Active template combines template-level metadata (name, description, tags) with the fields of the active Template version (template body, variables, version number, createdAt, createdBy, parentVersion, changeNotes, model)."
        },
        {
          "id": "active-template-used-in-llm-calls",
          "from": "active-template",
          "to": "template",
          "phrase": "is used to render prompts for",
          "category": "uses",
          "description": "An Active template is the concrete prompt configuration used when a Template is invoked to render prompts for LLM calls in production."
        },
        {
          "id": "template-editing-template",
          "from": "template-editing",
          "to": "template",
          "phrase": "modifies",
          "category": "other",
          "description": "Template editing modifies the content and configuration of a Template through an editor interface."
        },
        {
          "id": "template-editing-template-version",
          "from": "template-editing",
          "to": "template-version",
          "phrase": "creates or updates",
          "category": "causes",
          "description": "Template editing results in new or updated Template versions when the user saves their changes."
        },
        {
          "id": "template-editing-active-template",
          "from": "template-editing",
          "to": "active-template",
          "phrase": "prepares changes for",
          "category": "precedes",
          "description": "Template editing prepares changes that may later be selected as the Active template for production use."
        },
        {
          "id": "template-editing-test-case",
          "from": "template-editing",
          "to": "test-case",
          "phrase": "is informed by",
          "category": "uses",
          "description": "Template editing is often guided by how Templates behave against Test cases, although the direct linkage is not shown in this snippet."
        },
        {
          "id": "template-editing-test-execution",
          "from": "template-editing",
          "to": "test-execution",
          "phrase": "leads to",
          "category": "precedes",
          "description": "After template editing, Test executions can be run to evaluate the impact of the changes."
        },
        {
          "id": "template-editing-test-run-result",
          "from": "template-editing",
          "to": "test-run-result",
          "phrase": "is evaluated by",
          "category": "precedes",
          "description": "Changes made during template editing are ultimately evaluated via Test run results after execution."
        },
        {
          "id": "template-editing-test-batch",
          "from": "template-editing",
          "to": "test-batch",
          "phrase": "can trigger",
          "category": "precedes",
          "description": "A round of template editing can trigger a Test batch to assess the new or updated template version across many scenarios."
        },
        {
          "id": "test-case-for-template",
          "from": "test-case",
          "to": "template",
          "phrase": "is defined for",
          "category": "uses",
          "description": "Each test case is defined in the context of a specific template and is stored under that template's testCases collection; it is used to exercise that template with concrete input variables."
        },
        {
          "id": "test-case-uses-template-variables",
          "from": "test-case",
          "to": "template-version",
          "phrase": "aligns input variables with",
          "category": "uses",
          "description": "A test case's inputVariables are expected to align with the variables defined by a template version, allowing the template version to be rendered and evaluated under that scenario."
        },
        {
          "id": "test-case-has-checks",
          "from": "test-case",
          "to": "check",
          "phrase": "selects checks",
          "category": "uses",
          "description": "A test case references one or more checks via checkIds, specifying which checks should be run against the LLM output when this test case is executed."
        },
        {
          "id": "test-case-participates-in-test-execution",
          "from": "test-case",
          "to": "test-execution",
          "phrase": "is executed in",
          "category": "uses",
          "description": "A test case is executed via test execution, which runs the associated template with the test case's inputVariables and applies the selected checks."
        },
        {
          "id": "test-case-produces-test-run-result",
          "from": "test-case",
          "to": "test-run-result",
          "phrase": "produces",
          "category": "causes",
          "description": "Executing a test case yields one or more test run results that record whether the test passed, failed, or errored for that specific scenario."
        },
        {
          "id": "test-case-included-in-test-batch",
          "from": "test-case",
          "to": "test-batch",
          "phrase": "is included in",
          "category": "part_of",
          "description": "A test case can be part of a test batch, allowing multiple test cases for a template to be executed together as a group."
        },
        {
          "id": "test-case-informs-template-editing",
          "from": "test-case",
          "to": "template-editing",
          "phrase": "informs",
          "category": "uses",
          "description": "Test cases provide concrete scenarios and expectations that guide template editing, helping authors refine prompts and configurations."
        },
        {
          "id": "check-selected-by-test-case",
          "from": "test-case",
          "to": "check",
          "phrase": "selects checks",
          "category": "uses",
          "description": "A test case selects one or more checks that will be applied to the LLM output when the test case is executed."
        },
        {
          "id": "check-used-in-test-execution",
          "from": "check",
          "to": "test-execution",
          "phrase": "is applied during",
          "category": "uses",
          "description": "During a test execution, each selected check is applied to the produced LLM output to determine whether the output satisfies the checkâ€™s criteria."
        },
        {
          "id": "check-contributes-to-test-run-result",
          "from": "check",
          "to": "test-run-result",
          "phrase": "contributes evaluation details to",
          "category": "other",
          "description": "Each check produces a pass/fail outcome and reasoning that are aggregated into the overall test run result."
        },
        {
          "id": "check-executed-via-template",
          "from": "check",
          "to": "template",
          "phrase": "is evaluated using active check_validation template",
          "category": "uses",
          "description": "When executing checks, the system fetches the active 'check_validation' template and renders it with the test input, test output, and the checkâ€™s criteria to form the evaluation prompt."
        },
        {
          "id": "check-executed-via-active-template",
          "from": "check",
          "to": "active-template",
          "phrase": "relies on active check_validation template",
          "category": "uses",
          "description": "Check execution depends on whichever template version is currently active for the 'check_validation' template."
        },
        {
          "id": "check-created-by-user",
          "from": "check",
          "to": "user",
          "phrase": "is created by",
          "category": "other",
          "description": "Each check records the identifier of the user who created it, enabling attribution and governance of evaluation rules."
        },
        {
          "id": "check-managed-in-template-editing-context",
          "from": "template-editing",
          "to": "check",
          "phrase": "is configured alongside",
          "category": "other",
          "description": "Checks are managed in the same evaluation configuration context as templates, allowing editors to define or adjust checks while working on template behavior."
        },
        {
          "id": "check-produces-check-result",
          "from": "check",
          "to": "check-result",
          "phrase": "produces",
          "category": "causes",
          "description": "When a check is executed for a specific test run, it produces a CheckResult capturing pass/fail status, reasoning, and timing."
        },
        {
          "id": "check-uses-llm-model",
          "from": "check",
          "to": "llm-model",
          "phrase": "specifies evaluation model",
          "category": "uses",
          "description": "Each check specifies which LLM model (e.g., gemini-2.5-flash, gemini-2.5-pro) should be used to perform the evaluation according to its criteria."
        },
        {
          "id": "test-execution-uses-template",
          "from": "test-execution",
          "to": "template",
          "phrase": "executes against template",
          "category": "uses",
          "description": "Test execution runs a test case against a specific template identified by templateId."
        },
        {
          "id": "test-execution-uses-active-template",
          "from": "test-execution",
          "to": "active-template",
          "phrase": "fetches active template for",
          "category": "uses",
          "description": "Test execution fetches the active template version for a template before rendering and executing the prompt."
        },
        {
          "id": "test-execution-uses-template-version",
          "from": "test-execution",
          "to": "template-version",
          "phrase": "runs against template version",
          "category": "uses",
          "description": "Test execution uses the specific active template version (including its model and variables) when rendering and executing the prompt."
        },
        {
          "id": "test-execution-uses-test-case",
          "from": "test-execution",
          "to": "test-case",
          "phrase": "executes test case",
          "category": "uses",
          "description": "Test execution executes a single test case identified by testCaseId, using its input variables and assigned checks."
        },
        {
          "id": "test-execution-uses-check",
          "from": "test-execution",
          "to": "check",
          "phrase": "applies checks from",
          "category": "uses",
          "description": "Test execution retrieves the checks assigned to the test case and applies them to the LLM output."
        },
        {
          "id": "test-execution-causes-test-run-result",
          "from": "test-execution",
          "to": "test-run-result",
          "phrase": "produces",
          "category": "causes",
          "description": "Each test execution produces a test run result record, including overall status, model used, and check results."
        },
        {
          "id": "test-execution-part-of-test-batch",
          "from": "test-execution",
          "to": "test-batch",
          "phrase": "is included in",
          "category": "part_of",
          "description": "Individual test executions are processed as tasks within a test batch, identified by a batchId."
        },
        {
          "id": "test-execution-precedes-test-batch-completion",
          "from": "test-execution",
          "to": "test-batch",
          "phrase": "contributes to completion of",
          "category": "precedes",
          "description": "Completion of all scheduled test executions in a batch is a prerequisite for the batch to be considered complete."
        },
        {
          "id": "test-run-result-from-test-case",
          "from": "test-run-result",
          "to": "test-case",
          "phrase": "is produced for",
          "category": "causes",
          "description": "Each test run result is tied to a specific test case via testCaseId, representing the outcome of executing that test case."
        },
        {
          "id": "test-run-result-evaluates-template",
          "from": "test-run-result",
          "to": "template",
          "phrase": "evaluates",
          "category": "other",
          "description": "A test run result records how a particular template behaved when executing a test case, identified by templateId."
        },
        {
          "id": "test-run-result-evaluates-template-version",
          "from": "test-run-result",
          "to": "template-version",
          "phrase": "evaluates",
          "category": "other",
          "description": "A test run result is associated with a specific template version when available, allowing comparison of behavior across versions."
        },
        {
          "id": "test-run-result-produced-by-test-execution",
          "from": "test-run-result",
          "to": "test-execution",
          "phrase": "is produced by",
          "category": "causes",
          "description": "A test execution run against a template and test case yields a test run result capturing the outcome."
        },
        {
          "id": "test-run-result-included-in-test-batch",
          "from": "test-run-result",
          "to": "test-batch",
          "phrase": "is aggregated into",
          "category": "part_of",
          "description": "Individual test run results are grouped within a test batch to evaluate a template change across many scenarios."
        },
        {
          "id": "test-run-result-has-check-results",
          "from": "test-run-result",
          "to": "check",
          "phrase": "records results of",
          "category": "other",
          "description": "A test run result may include check results for the checks selected by the test case and applied during execution."
        },
        {
          "id": "test-batch-template",
          "from": "test-batch",
          "to": "template",
          "phrase": "is created for template",
          "category": "uses",
          "description": "Each test batch is associated with a specific template (via templateId) whose behavior is being evaluated across multiple test executions."
        },
        {
          "id": "test-batch-test-case",
          "from": "test-batch",
          "to": "test-case",
          "phrase": "groups test cases",
          "category": "part_of",
          "description": "A test batch groups one or more test cases that will be executed together; totalTestCases and completedCount reflect how many test cases in the batch have been run."
        },
        {
          "id": "test-batch-test-execution",
          "from": "test-batch",
          "to": "test-execution",
          "phrase": "groups test executions",
          "category": "part_of",
          "description": "All test executions in the system are associated with a test batch via batchId, and together they constitute the work performed by that batch."
        },
        {
          "id": "test-batch-test-run-result",
          "from": "test-batch",
          "to": "test-run-result",
          "phrase": "aggregates test run results",
          "category": "part_of",
          "description": "A test batch aggregates the individual test run results produced by its test executions, enabling batch-level analysis of template performance."
        },
        {
          "id": "test-batch-template-editing",
          "from": "test-batch",
          "to": "template-editing",
          "phrase": "evaluates changes from",
          "category": "precedes",
          "description": "Test batches are often triggered after template editing to evaluate the impact of template changes across many scenarios."
        },
        {
          "id": "test-batch-user",
          "from": "test-batch",
          "to": "user",
          "phrase": "is initiated by user",
          "category": "causes",
          "description": "A user must be authenticated to initiate a test batch; the batch and its execution tasks record the initiating userId."
        },
        {
          "id": "test-batch-test-execution-task-payload",
          "from": "test-batch",
          "to": "test-execution",
          "phrase": "is referenced by batchId in execution tasks",
          "category": "uses",
          "description": "Each TestExecutionTaskPayload includes a batchId field that ties the execution task back to its parent test batch."
        }
      ],
      "rules": [
        {
          "id": "template-must-have-active-version",
          "title": "Template must reference an active version",
          "text": "Each Template must have an `activeVersion` value that points to an existing Template version document; otherwise the Template cannot be used for production LLM calls.",
          "kind": "constraint",
          "conceptIds": [
            "template"
          ]
        },
        {
          "id": "template-active-version-must-exist",
          "title": "Active Template version must exist",
          "text": "When fetching a Template for runtime use, the system must be able to load the Template version identified by the Template's `activeVersion`; if that version document does not exist, the operation fails.",
          "kind": "invariant",
          "conceptIds": [
            "template"
          ]
        },
        {
          "id": "template-save-creates-new-version",
          "title": "Saving Template changes creates a new Template version",
          "text": "Saving changes to a Template's prompt content or configuration creates a new Template version rather than overwriting the existing active version.",
          "kind": "policy",
          "conceptIds": [
            "template"
          ]
        },
        {
          "id": "template-save-does-not-auto-activate",
          "title": "Saving a Template does not automatically activate the new version",
          "text": "Creating or saving a new Template version does not automatically make it the active version; an explicit 'Make Active' action is required before the new version is used in production.",
          "kind": "policy",
          "conceptIds": [
            "template"
          ]
        },
        {
          "id": "template-id-required",
          "title": "Template must have an identifier",
          "text": "Each Template must have a unique identifier used to locate its metadata and associated Template versions in storage.",
          "kind": "invariant",
          "conceptIds": [
            "template"
          ]
        },
        {
          "id": "template-name-required",
          "title": "Template must have a name",
          "text": "Each Template must have a human-readable name to be displayed and selected in the TemplateManager UI.",
          "kind": "constraint",
          "conceptIds": [
            "template"
          ]
        },
        {
          "id": "rule-template-version-number-required",
          "title": "Template version must have a version number",
          "text": "Each template version must have a numeric version identifier that distinguishes it from other versions of the same template.",
          "kind": "invariant",
          "conceptIds": [
            "template-version"
          ]
        },
        {
          "id": "rule-template-version-belongs-to-template",
          "title": "Template version must belong to a template",
          "text": "Each template version must be stored under and associated with exactly one parent template.",
          "kind": "constraint",
          "conceptIds": [
            "template-version"
          ]
        },
        {
          "id": "rule-template-active-version-must-exist",
          "title": "Active version must exist for template",
          "text": "If a template declares an activeVersion, a corresponding template version document with that version identifier must exist.",
          "kind": "constraint",
          "conceptIds": [
            "template-version"
          ]
        },
        {
          "id": "rule-template-version-has-author-and-timestamp",
          "title": "Template version must record author and creation time",
          "text": "Each template version records who created it and when, via createdBy and createdAt fields.",
          "kind": "assumption",
          "conceptIds": [
            "template-version"
          ]
        },
        {
          "id": "rule-template-version-has-prompt-and-variables",
          "title": "Template version must define prompt content and variables",
          "text": "Each template version must include the prompt template text and the list of variables it expects.",
          "kind": "invariant",
          "conceptIds": [
            "template-version"
          ]
        },
        {
          "id": "rule-template-version-active-flag-consistent",
          "title": "Template version active flag should align with template's activeVersion",
          "text": "For a given template, exactly one template version should be marked as isActive and its version number should match the template's activeVersion field.",
          "kind": "policy",
          "conceptIds": [
            "template-version"
          ]
        },
        {
          "id": "rule-active-template-must-exist",
          "title": "Active template must exist for a template used in production",
          "text": "If a Template is used in production LLM calls, its metadata must specify an `activeVersion` that points to an existing Template version document.",
          "kind": "constraint",
          "conceptIds": [
            "active-template"
          ]
        },
        {
          "id": "rule-active-version-document-must-exist",
          "title": "Active version document must be present",
          "text": "The Template version referenced by a Templateâ€™s `activeVersion` field must exist; otherwise, fetching the Active template fails.",
          "kind": "invariant",
          "conceptIds": [
            "active-template"
          ]
        },
        {
          "id": "rule-active-template-uniqueness-per-template",
          "title": "At most one active template version per template",
          "text": "For a given Template, only the Template version referenced by `activeVersion` is treated as the Active template at runtime, even if multiple stored versions might have `isActive` flags.",
          "kind": "assumption",
          "conceptIds": [
            "active-template"
          ]
        },
        {
          "id": "rule-active-template-variables-must-be-satisfied",
          "title": "Active template requires all declared variables at render time",
          "text": "When rendering an Active template, all variables listed in its `variables` field must be provided; otherwise, rendering fails.",
          "kind": "invariant",
          "conceptIds": [
            "active-template"
          ]
        },
        {
          "id": "rule-active-template-cache-ttl",
          "title": "Active template may be cached for a limited time",
          "text": "An Active template fetched for runtime use may be cached and reused for a bounded time window (e.g., 5 minutes) to avoid repeated reads from persistent storage.",
          "kind": "policy",
          "conceptIds": [
            "active-template"
          ]
        },
        {
          "id": "rule-template-editing-readonly",
          "title": "Template editing requires editable mode",
          "text": "Template editing may only change template content when the editor is in editable mode; when readOnly is true, the template content must not be modified through the editor.",
          "kind": "constraint",
          "conceptIds": [
            "template-editing"
          ]
        },
        {
          "id": "rule-template-editing-version-context",
          "title": "Template editing operates on a selected template version",
          "text": "Template editing is performed in the context of a selected template and template version; if no template version is selected, the editor should not allow saving changes as a new or updated version.",
          "kind": "assumption",
          "conceptIds": [
            "template-editing"
          ]
        },
        {
          "id": "rule-template-editing-change-notes",
          "title": "Template editing captures change notes",
          "text": "When saving edits to a template, the user is expected to provide change notes describing what was modified in the template version.",
          "kind": "policy",
          "conceptIds": [
            "template-editing"
          ]
        },
        {
          "id": "rule-template-editing-model-selection",
          "title": "Template editing includes model selection",
          "text": "During template editing, the user may select or adjust the associated LLM model configuration for the template version (e.g., choosing among supported Gemini models).",
          "kind": "assumption",
          "conceptIds": [
            "template-editing"
          ]
        },
        {
          "id": "rule-test-case-must-have-name",
          "title": "Test case must have a name",
          "text": "Every test case must have a non-empty name to identify it in the UI and when selecting it for execution.",
          "kind": "constraint",
          "conceptIds": [
            "test-case"
          ]
        },
        {
          "id": "rule-test-case-must-have-input-variables",
          "title": "Test case must define input variables",
          "text": "Every test case must define an inputVariables object, which provides concrete values for some or all of the template's variables when the test is executed.",
          "kind": "constraint",
          "conceptIds": [
            "test-case"
          ]
        },
        {
          "id": "rule-test-case-must-record-audit-fields",
          "title": "Test case must record creator and timestamps",
          "text": "Every test case records createdBy, createdAt, and updatedAt fields to track authorship and changes over time.",
          "kind": "assumption",
          "conceptIds": [
            "test-case"
          ]
        },
        {
          "id": "rule-test-case-check-ids-optional",
          "title": "Test case may omit checks",
          "text": "A test case may have an empty or missing checkIds list, in which case the test execution will not run any checks for that scenario.",
          "kind": "assumption",
          "conceptIds": [
            "test-case"
          ]
        },
        {
          "id": "rule-test-case-tags-optional",
          "title": "Test case tags are optional metadata",
          "text": "Tags on a test case are optional and used only for organizing and filtering test cases in the UI.",
          "kind": "assumption",
          "conceptIds": [
            "test-case"
          ]
        },
        {
          "id": "rule-check-requires-name",
          "title": "Check must have a name",
          "text": "Every Check must have a non-empty name to be created or updated, so that users can identify it in lists and when attaching it to test cases.",
          "kind": "constraint",
          "conceptIds": [
            "check"
          ]
        },
        {
          "id": "rule-check-requires-criteria",
          "title": "Check must define criteria",
          "text": "Every Check must have non-empty criteria text describing the evaluation rule that will be applied to LLM outputs.",
          "kind": "constraint",
          "conceptIds": [
            "check"
          ]
        },
        {
          "id": "rule-check-requires-model",
          "title": "Check must specify an evaluation model",
          "text": "Every Check must specify which LLM model will be used to execute the check, chosen from the supported model options.",
          "kind": "constraint",
          "conceptIds": [
            "check"
          ]
        },
        {
          "id": "rule-check-has-auditing-metadata",
          "title": "Check records creation metadata",
          "text": "Every persisted Check records createdAt and createdBy metadata for auditing and traceability.",
          "kind": "assumption",
          "conceptIds": [
            "check"
          ]
        },
        {
          "id": "rule-check-immutability-of-results",
          "title": "Check results are tied to specific check definitions at execution time",
          "text": "A CheckResult reflects the criteria and model of the Check as they existed at the time of execution; later edits to the Check do not retroactively change past CheckResults.",
          "kind": "assumption",
          "conceptIds": [
            "check"
          ]
        },
        {
          "id": "rule-test-execution-requires-authenticated-user",
          "title": "Test execution requires an authenticated user",
          "text": "A test execution can only be initiated via the callable function if the user is authenticated; unauthenticated requests must be rejected.",
          "kind": "policy",
          "conceptIds": [
            "test-execution"
          ]
        },
        {
          "id": "rule-test-execution-requires-identifiers-and-inputs",
          "title": "Test execution requires template, test case, and input variables",
          "text": "To start a test execution, the system must receive a templateId, a testCaseId, and a set of inputVariables; if any are missing, the execution request is invalid.",
          "kind": "constraint",
          "conceptIds": [
            "test-execution"
          ]
        },
        {
          "id": "rule-test-execution-uses-active-template-version",
          "title": "Test execution uses the active template version",
          "text": "When executing a test, the system must fetch and use the active template version for the specified template, rather than an arbitrary or outdated version.",
          "kind": "assumption",
          "conceptIds": [
            "test-execution"
          ]
        },
        {
          "id": "rule-test-execution-skips-cancelled-batch",
          "title": "Test execution must not run for cancelled batches",
          "text": "If the associated test batch does not exist or has status 'cancelled', the test execution must be skipped and no LLM call or evaluation should be performed.",
          "kind": "policy",
          "conceptIds": [
            "test-execution"
          ]
        },
        {
          "id": "rule-test-execution-requires-test-case-input-variables",
          "title": "Test execution requires test case input variables",
          "text": "A test execution for a given test case must only proceed if the test case defines inputVariables; otherwise the execution should fail with an error.",
          "kind": "constraint",
          "conceptIds": [
            "test-execution"
          ]
        },
        {
          "id": "rule-test-execution-no-duplicate-client-run",
          "title": "Client must prevent duplicate concurrent test executions per test case",
          "text": "The client-side test execution handler must not start a new execution for a test case that is already running, and should instead return a TEST_ALREADY_RUNNING error.",
          "kind": "policy",
          "conceptIds": [
            "test-execution"
          ]
        },
        {
          "id": "rule-test-run-result-has-core-identifiers",
          "title": "Test run result must reference test case and template",
          "text": "Every test run result must have an id, a testCaseId, a templateId, an executedBy identifier, and an executedAt timestamp.",
          "kind": "invariant",
          "conceptIds": [
            "test-run-result"
          ]
        },
        {
          "id": "rule-test-run-pass-requires-request-context",
          "title": "Pass results must include request and thread context",
          "text": "When a test run result has status 'pass', it must include requestId, threadId, and elapsedMs values.",
          "kind": "constraint",
          "conceptIds": [
            "test-run-result"
          ]
        },
        {
          "id": "rule-test-run-fail-requires-check-results",
          "title": "Fail results must include check results",
          "text": "When a test run result has status 'fail', it must include at least one check result describing which checks failed or passed.",
          "kind": "constraint",
          "conceptIds": [
            "test-run-result"
          ]
        },
        {
          "id": "rule-test-run-error-template-version-optional",
          "title": "Error results may lack template version",
          "text": "When a test run result has status 'error', the templateVersion may be absent if the template could not be fetched or resolved.",
          "kind": "assumption",
          "conceptIds": [
            "test-run-result"
          ]
        },
        {
          "id": "rule-test-run-status-mutually-exclusive",
          "title": "Test run result has exactly one status",
          "text": "A test run result must be in exactly one of three mutually exclusive states: 'pass', 'fail', or 'error'.",
          "kind": "invariant",
          "conceptIds": [
            "test-run-result"
          ]
        },
        {
          "id": "rule-test-batch-auth-required",
          "title": "User must be authenticated to execute tests in a batch",
          "text": "Creating or executing a test batch requires an authenticated user; unauthenticated requests to execute tests are rejected.",
          "kind": "policy",
          "conceptIds": [
            "test-batch"
          ]
        },
        {
          "id": "rule-test-batch-has-template",
          "title": "Test batch must reference a template",
          "text": "Every test batch must be associated with a templateId indicating which template is being evaluated.",
          "kind": "constraint",
          "conceptIds": [
            "test-batch"
          ]
        },
        {
          "id": "rule-test-batch-has-batch-id",
          "title": "Test batch has a unique batch identifier",
          "text": "Each test batch is created with a unique batchId that is used to associate all related test execution tasks and results with that batch.",
          "kind": "invariant",
          "conceptIds": [
            "test-batch"
          ]
        },
        {
          "id": "rule-test-batch-total-test-cases-nonnegative",
          "title": "Test batch total test cases is non-negative",
          "text": "The totalTestCases count on a test batch must be zero or a positive integer; progress calculations assume a non-negative total.",
          "kind": "assumption",
          "conceptIds": [
            "test-batch"
          ]
        },
        {
          "id": "rule-test-batch-completed-count-bounds",
          "title": "Test batch completed count cannot exceed total test cases",
          "text": "The completedCount for a test batch is expected to be between 0 and totalTestCases, inclusive, to ensure meaningful progress percentages.",
          "kind": "assumption",
          "conceptIds": [
            "test-batch"
          ]
        },
        {
          "id": "rule-test-batch-executions-part-of-batch",
          "title": "All test executions must belong to a batch",
          "text": "Every test execution task payload includes a batchId, meaning all test executions are part of some test batch.",
          "kind": "invariant",
          "conceptIds": [
            "test-batch"
          ]
        }
      ],
      "lifecycles": [
        {
          "id": "lifecycle-template-editing-session",
          "subjectConceptId": "template-editing",
          "stateConceptIds": [
            "template-editing-state-idle",
            "template-editing-state-active"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "template-editing-state-idle",
          "terminalStateIds": [
            "template-editing-state-idle"
          ]
        },
        {
          "id": "lifecycle-test-run-result-status",
          "subjectConceptId": "test-run-result",
          "stateConceptIds": [
            "test-run-result-pass",
            "test-run-result-fail",
            "test-run-result-error"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "test-run-result-pass",
          "terminalStateIds": [
            "test-run-result-pass",
            "test-run-result-fail",
            "test-run-result-error"
          ]
        },
        {
          "id": "lifecycle-test-batch-status",
          "subjectConceptId": "test-batch",
          "stateConceptIds": [
            "test-batch-pending",
            "test-batch-running",
            "test-batch-completed",
            "test-batch-cancelled",
            "test-batch-failed"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "test-batch-pending",
          "terminalStateIds": [
            "test-batch-completed",
            "test-batch-cancelled",
            "test-batch-failed"
          ]
        }
      ],
      "views": [
        {
          "id": "template-artifacts-structure",
          "name": "Template artifacts and structure",
          "kind": "structure",
          "description": "Shows how a template, its versions, and the active template relate as core artifacts used in production.",
          "conceptIds": [
            "template",
            "template-version",
            "active-template",
            "template-editing"
          ],
          "relationshipIds": [
            "template-has-template-versions",
            "rel-template-version-of-template",
            "rel-template-has-template-versions",
            "rel-template-version-can-be-active-template",
            "rel-template-selects-active-version",
            "active-template-from-template",
            "active-template-from-template-version",
            "active-template-uses-template-version",
            "template-editing-template-version",
            "template-editing-active-template"
          ]
        },
        {
          "id": "template-editing-lifecycle",
          "name": "Template editing and activation lifecycle",
          "kind": "lifecycle",
          "description": "Focuses on how editing activities create or update template versions and lead to activation and evaluation.",
          "conceptIds": [
            "template",
            "template-version",
            "active-template",
            "template-editing",
            "test-batch",
            "test-execution",
            "test-run-result"
          ],
          "relationshipIds": [
            "template-participates-in-template-editing",
            "rel-template-version-subject-of-editing",
            "template-editing-template",
            "template-editing-template-version",
            "template-editing-active-template",
            "template-editing-test-execution",
            "template-editing-test-run-result",
            "template-editing-test-batch",
            "rel-template-version-evaluated-across-test-batch",
            "rel-template-version-evaluated-in-test-run-result"
          ]
        },
        {
          "id": "test-case-and-check-design",
          "name": "Designing test cases and checks",
          "kind": "structure",
          "description": "Explains how test cases are defined for templates, how they align with template versions, and how checks are attached.",
          "conceptIds": [
            "template",
            "template-version",
            "test-case",
            "check",
            "template-editing"
          ],
          "relationshipIds": [
            "test-case-for-template",
            "test-case-uses-template-variables",
            "test-case-has-checks",
            "check-selected-by-test-case",
            "test-case-informs-template-editing",
            "template-editing-test-case",
            "check-managed-in-template-editing-context",
            "check-created-by-user",
            "check-uses-llm-model"
          ]
        },
        {
          "id": "single-test-execution-flow",
          "name": "Single test execution flow",
          "kind": "lifecycle",
          "description": "Shows how a single test execution uses a template, test case, and checks to produce a test run result.",
          "conceptIds": [
            "template",
            "template-version",
            "active-template",
            "test-case",
            "check",
            "test-execution",
            "test-run-result"
          ],
          "relationshipIds": [
            "test-execution-uses-template",
            "test-execution-uses-active-template",
            "test-execution-uses-template-version",
            "test-execution-uses-test-case",
            "test-execution-uses-check",
            "test-execution-causes-test-run-result",
            "test-case-participates-in-test-execution",
            "test-case-produces-test-run-result",
            "check-used-in-test-execution",
            "check-contributes-to-test-run-result"
          ]
        },
        {
          "id": "batch-testing-and-aggregation",
          "name": "Batch testing and aggregation",
          "kind": "overview",
          "description": "Shows how test batches group test cases and executions, and aggregate test run results for a template.",
          "conceptIds": [
            "template",
            "test-case",
            "test-execution",
            "test-run-result",
            "test-batch",
            "user"
          ],
          "relationshipIds": [
            "test-batch-template",
            "test-batch-test-case",
            "test-batch-test-execution",
            "test-batch-test-run-result",
            "test-batch-template-editing",
            "test-batch-user",
            "test-execution-part-of-test-batch",
            "test-execution-precedes-test-batch-completion",
            "test-run-result-included-in-test-batch",
            "test-batch-test-execution-task-payload"
          ]
        },
        {
          "id": "checks-and-llm-evaluation",
          "name": "Checks and LLM-based evaluation",
          "kind": "implementation",
          "description": "Highlights how checks use LLM models and templates to evaluate outputs and produce detailed check results.",
          "conceptIds": [
            "check",
            "template",
            "active-template",
            "test-run-result",
            "check-result",
            "llm-model"
          ],
          "relationshipIds": [
            "check-executed-via-template",
            "check-executed-via-active-template",
            "check-produces-check-result",
            "check-uses-llm-model",
            "check-contributes-to-test-run-result",
            "test-run-result-has-check-results"
          ]
        }
      ],
      "storyViews": [
        {
          "id": "create-and-activate-new-template-version",
          "name": "Create and Activate a New Template Version",
          "kind": "admin_flow",
          "description": "An admin edits a template, creates a new version, evaluates it with tests, and then promotes it to be the active template.",
          "tags": [
            "versioning",
            "activation",
            "regression-testing"
          ],
          "focusConceptId": "template-version",
          "steps": [
            {
              "id": "open-template-for-editing",
              "index": 0,
              "title": "Admin Opens Template for Editing",
              "narrative": "An admin selects an existing template to refine its behavior, starting a template editing session focused on that template and its current version.",
              "conceptIds": [
                "template",
                "template-version",
                "template-editing"
              ],
              "relationshipIds": [
                "template-participates-in-template-editing",
                "rel-template-version-subject-of-editing",
                "template-editing-template",
                "template-editing-template-version"
              ],
              "primaryConceptIds": [
                "template-editing",
                "template-version"
              ],
              "primaryRelationshipIds": [
                "rel-template-version-subject-of-editing"
              ]
            },
            {
              "id": "adjust-template-and-align-test-cases",
              "index": 1,
              "title": "Admin Adjusts Template and Reviews Test Cases",
              "narrative": "While editing, the admin tweaks prompt wording and variables, reviewing existing test cases to ensure they still reflect desired behavior and coverage.",
              "conceptIds": [
                "template-editing",
                "template-version",
                "test-case"
              ],
              "relationshipIds": [
                "template-editing-test-case",
                "test-case-for-template",
                "test-case-uses-template-variables"
              ],
              "primaryConceptIds": [
                "template-editing",
                "test-case"
              ],
              "primaryRelationshipIds": [
                "template-editing-test-case"
              ]
            },
            {
              "id": "run-tests-on-new-version",
              "index": 2,
              "title": "Admin Runs Tests on the New Template Version",
              "narrative": "The admin triggers a test execution that runs the updated template version against selected test cases, applying their configured checks.",
              "conceptIds": [
                "template-version",
                "test-execution",
                "test-case",
                "check"
              ],
              "relationshipIds": [
                "rel-template-version-used-in-test-execution",
                "test-execution-uses-test-case",
                "test-execution-uses-check",
                "test-case-participates-in-test-execution",
                "check-used-in-test-execution"
              ],
              "primaryConceptIds": [
                "test-execution",
                "template-version"
              ],
              "primaryRelationshipIds": [
                "rel-template-version-used-in-test-execution"
              ]
            },
            {
              "id": "review-test-run-results",
              "index": 3,
              "title": "Admin Reviews Test Run Results",
              "narrative": "Each test execution produces test run results that show passes, failures, and check-level details, allowing the admin to judge whether the new version is acceptable.",
              "conceptIds": [
                "test-execution",
                "test-run-result",
                "check",
                "template-version"
              ],
              "relationshipIds": [
                "test-execution-causes-test-run-result",
                "test-run-result-produced-by-test-execution",
                "test-run-result-has-check-results",
                "rel-template-version-evaluated-in-test-run-result",
                "check-contributes-to-test-run-result"
              ],
              "primaryConceptIds": [
                "test-run-result"
              ],
              "primaryRelationshipIds": [
                "test-execution-causes-test-run-result"
              ]
            },
            {
              "id": "promote-version-to-active-template",
              "index": 4,
              "title": "Admin Promotes Version to Active Template",
              "narrative": "Satisfied with the results, the admin selects the tested template version as the active template, so future LLM calls use this configuration in production.",
              "conceptIds": [
                "template",
                "template-version",
                "active-template"
              ],
              "relationshipIds": [
                "rel-template-version-can-be-active-template",
                "rel-template-selects-active-version",
                "active-template-from-template-version",
                "active-template-from-template",
                "active-template-uses-template-version",
                "active-template-used-in-llm-calls"
              ],
              "primaryConceptIds": [
                "active-template",
                "template-version"
              ],
              "primaryRelationshipIds": [
                "rel-template-version-can-be-active-template"
              ]
            }
          ]
        },
        {
          "id": "define-test-cases-and-checks-for-template",
          "name": "Define Test Cases and Checks for a Template",
          "kind": "admin_flow",
          "description": "An admin designs test cases and checks around a template to formalize expectations and enable automated evaluation.",
          "tags": [
            "test-design",
            "checks",
            "quality"
          ],
          "focusConceptId": "test-case",
          "steps": [
            {
              "id": "identify-template-behavior-to-validate",
              "index": 0,
              "title": "Admin Identifies Template Behavior to Validate",
              "narrative": "An admin reviews a template and its versions to decide which behaviors and edge cases should be captured as explicit test cases.",
              "conceptIds": [
                "template",
                "template-version",
                "template-editing",
                "test-case"
              ],
              "relationshipIds": [
                "template-participates-in-template-editing",
                "rel-template-version-subject-of-editing",
                "template-editing-test-case",
                "test-case-for-template"
              ],
              "primaryConceptIds": [
                "template",
                "test-case"
              ],
              "primaryRelationshipIds": [
                "test-case-for-template"
              ]
            },
            {
              "id": "align-test-inputs-with-template-variables",
              "index": 1,
              "title": "Admin Aligns Test Inputs with Template Variables",
              "narrative": "For each new test case, the admin specifies concrete input values that align with the template versionâ€™s variables and structure.",
              "conceptIds": [
                "test-case",
                "template-version"
              ],
              "relationshipIds": [
                "test-case-uses-template-variables",
                "rel-template-version-of-template"
              ],
              "primaryConceptIds": [
                "test-case"
              ],
              "primaryRelationshipIds": [
                "test-case-uses-template-variables"
              ]
            },
            {
              "id": "configure-checks-for-test-cases",
              "index": 2,
              "title": "Admin Configures Checks for Each Test Case",
              "narrative": "The admin attaches checks to each test case, defining what constitutes a pass or fail for the LLMâ€™s response.",
              "conceptIds": [
                "test-case",
                "check",
                "template-editing"
              ],
              "relationshipIds": [
                "test-case-has-checks",
                "check-selected-by-test-case",
                "check-managed-in-template-editing-context"
              ],
              "primaryConceptIds": [
                "check",
                "test-case"
              ],
              "primaryRelationshipIds": [
                "test-case-has-checks"
              ]
            },
            {
              "id": "execute-single-test-to-validate-setup",
              "index": 3,
              "title": "Admin Executes a Single Test to Validate Setup",
              "narrative": "To confirm the test and checks are configured correctly, the admin runs a test execution for one test case and inspects the resulting evaluation.",
              "conceptIds": [
                "test-case",
                "check",
                "test-execution",
                "test-run-result"
              ],
              "relationshipIds": [
                "test-case-participates-in-test-execution",
                "test-execution-uses-test-case",
                "test-execution-uses-check",
                "test-execution-causes-test-run-result",
                "test-run-result-has-check-results"
              ],
              "primaryConceptIds": [
                "test-execution",
                "test-run-result"
              ],
              "primaryRelationshipIds": [
                "test-execution-causes-test-run-result"
              ]
            }
          ]
        },
        {
          "id": "regression-test-template-change-with-batch",
          "name": "Regression Test a Template Change with a Test Batch",
          "kind": "system_flow",
          "description": "A user initiates a test batch to run many test cases against a template version, aggregating results to assess regression risk.",
          "tags": [
            "batch-testing",
            "regression",
            "aggregation"
          ],
          "focusConceptId": "test-batch",
          "steps": [
            {
              "id": "initiate-test-batch-for-template",
              "index": 0,
              "title": "User Initiates a Test Batch for a Template",
              "narrative": "After editing a template, a user starts a test batch to evaluate the impact of changes across a wide set of scenarios.",
              "conceptIds": [
                "template",
                "template-editing",
                "test-batch"
              ],
              "relationshipIds": [
                "template-editing-test-batch",
                "test-batch-template",
                "test-batch-template-editing",
                "test-batch-user"
              ],
              "primaryConceptIds": [
                "test-batch"
              ],
              "primaryRelationshipIds": [
                "test-batch-template"
              ]
            },
            {
              "id": "group-test-cases-into-batch",
              "index": 1,
              "title": "System Groups Relevant Test Cases into the Batch",
              "narrative": "The system associates a curated set of test cases with the test batch, defining the coverage for this regression run.",
              "conceptIds": [
                "test-batch",
                "test-case"
              ],
              "relationshipIds": [
                "test-batch-test-case",
                "test-case-included-in-test-batch"
              ],
              "primaryConceptIds": [
                "test-batch",
                "test-case"
              ],
              "primaryRelationshipIds": [
                "test-batch-test-case"
              ]
            },
            {
              "id": "spawn-test-executions-for-batch",
              "index": 2,
              "title": "System Spawns Test Executions for Each Test Case",
              "narrative": "For each test case in the batch, the system creates a test execution task that references the batch and runs against the appropriate template version.",
              "conceptIds": [
                "test-batch",
                "test-execution",
                "template-version",
                "test-case"
              ],
              "relationshipIds": [
                "test-batch-test-execution",
                "test-execution-part-of-test-batch",
                "test-batch-test-execution-task-payload",
                "test-execution-uses-template-version",
                "test-execution-uses-test-case"
              ],
              "primaryConceptIds": [
                "test-execution",
                "test-batch"
              ],
              "primaryRelationshipIds": [
                "test-batch-test-execution"
              ]
            },
            {
              "id": "apply-checks-and-generate-results",
              "index": 3,
              "title": "Executions Apply Checks and Generate Results",
              "narrative": "Each test execution applies the checks from its test case, producing detailed test run results that evaluate the template versionâ€™s behavior.",
              "conceptIds": [
                "test-execution",
                "check",
                "test-run-result",
                "template-version"
              ],
              "relationshipIds": [
                "test-execution-uses-check",
                "check-used-in-test-execution",
                "test-execution-causes-test-run-result",
                "test-run-result-produced-by-test-execution",
                "rel-template-version-evaluated-in-test-run-result"
              ],
              "primaryConceptIds": [
                "test-run-result"
              ],
              "primaryRelationshipIds": [
                "test-execution-causes-test-run-result"
              ]
            },
            {
              "id": "aggregate-results-and-complete-batch",
              "index": 4,
              "title": "System Aggregates Results and Completes the Batch",
              "narrative": "As all executions finish, their test run results are aggregated into the test batch, which is then marked complete and ready for review.",
              "conceptIds": [
                "test-batch",
                "test-execution",
                "test-run-result"
              ],
              "relationshipIds": [
                "test-execution-precedes-test-batch-completion",
                "test-batch-test-run-result",
                "test-run-result-included-in-test-batch"
              ],
              "primaryConceptIds": [
                "test-batch"
              ],
              "primaryRelationshipIds": [
                "test-batch-test-run-result"
              ]
            }
          ]
        },
        {
          "id": "checks-driven-evaluation-loop",
          "name": "Checks-Driven Evaluation Loop for a Template",
          "kind": "system_flow",
          "description": "The system uses checks attached to test cases to continuously evaluate a template and its versions, feeding results back into editing.",
          "tags": [
            "checks",
            "feedback-loop",
            "continuous-improvement"
          ],
          "focusConceptId": "check",
          "steps": [
            {
              "id": "configure-checks-alongside-template",
              "index": 0,
              "title": "Checks Are Configured Alongside the Template",
              "narrative": "During template editing, checks are configured and associated with test cases so that future executions can automatically judge LLM outputs.",
              "conceptIds": [
                "template-editing",
                "check",
                "test-case"
              ],
              "relationshipIds": [
                "check-managed-in-template-editing-context",
                "test-case-has-checks",
                "check-selected-by-test-case"
              ],
              "primaryConceptIds": [
                "check",
                "test-case"
              ],
              "primaryRelationshipIds": [
                "test-case-has-checks"
              ]
            },
            {
              "id": "run-tests-using-active-template",
              "index": 1,
              "title": "Tests Run Using the Active Template",
              "narrative": "When tests are executed, the system fetches the active template and its version, then runs test cases while applying their configured checks.",
              "conceptIds": [
                "test-execution",
                "active-template",
                "template",
                "template-version",
                "test-case",
                "check"
              ],
              "relationshipIds": [
                "test-execution-uses-active-template",
                "test-execution-uses-template",
                "test-execution-uses-template-version",
                "test-execution-uses-test-case",
                "test-execution-uses-check",
                "check-used-in-test-execution"
              ],
              "primaryConceptIds": [
                "test-execution",
                "active-template"
              ],
              "primaryRelationshipIds": [
                "test-execution-uses-active-template"
              ]
            },
            {
              "id": "checks-produce-detailed-evaluation",
              "index": 2,
              "title": "Checks Produce Detailed Evaluation Results",
              "narrative": "Each check evaluates the LLM output and contributes structured evaluation details to the test run result, indicating passes, failures, or issues.",
              "conceptIds": [
                "check",
                "test-run-result",
                "test-case"
              ],
              "relationshipIds": [
                "check-contributes-to-test-run-result",
                "test-run-result-has-check-results",
                "test-case-produces-test-run-result",
                "test-run-result-from-test-case"
              ],
              "primaryConceptIds": [
                "check",
                "test-run-result"
              ],
              "primaryRelationshipIds": [
                "check-contributes-to-test-run-result"
              ]
            },
            {
              "id": "results-inform-further-template-editing",
              "index": 3,
              "title": "Results Inform Further Template Editing",
              "narrative": "Admins review test run results and use failing checks and edge cases to guide the next round of template editing and new test case creation.",
              "conceptIds": [
                "test-run-result",
                "template-editing",
                "template-version",
                "test-case"
              ],
              "relationshipIds": [
                "test-run-result-evaluates-template-version",
                "template-editing-test-run-result",
                "test-case-informs-template-editing",
                "rel-template-version-subject-of-editing"
              ],
              "primaryConceptIds": [
                "template-editing",
                "test-run-result"
              ],
              "primaryRelationshipIds": [
                "template-editing-test-run-result"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "job-processing-and-runtime",
      "title": "Job Processing and Shared Runtime",
      "description": "How background jobs are queued and executed, and how shared runtime utilities support consistent behavior across services.",
      "concepts": [
        {
          "id": "background-job",
          "label": "Background job",
          "category": "thing",
          "description": "A unit of work executed asynchronously, such as running an LLM classification or executing tests.",
          "aliases": [
            "Background job",
            "job",
            "LLM job",
            "test execution job",
            "runLlmJob",
            "runTestExecutionJob",
            "task",
            "Cloud Task",
            "TaskPayload",
            "TestExecutionTaskPayload",
            "worker job"
          ],
          "notes": "A background job is a unit of work executed asynchronously by a worker process, typically triggered via a Cloud Task. In this system, examples include longâ€‘running LLM processing for Slack threads and execution of individual test cases in a batch. Jobs receive a structured payload, perform work that may involve LLM calls and Firestore reads/writes, and may record logs, debug information, and test results. They are decoupled from the initiating Slack event or user interaction and run in a shared runtime environment."
        },
        {
          "id": "event-envelope",
          "label": "Event envelope",
          "category": "thing",
          "description": "A standardized wrapper around events or tasks that carry metadata for processing and logging.",
          "aliases": [
            "EventEnvelope",
            "Slack event envelope",
            "incoming Slack event",
            "Slack message event"
          ],
          "notes": "An event envelope is a standardized wrapper for incoming Slack-originated events or messages. It captures the minimal identifying and routing metadata (such as channel, timestamps, and user) needed to correlate the event with Slack threads, initiate background jobs, and support logging and debugging. It is intentionally lightweight and focused on representing the original Slack event context, not the full internal task payload used for background processing."
        },
        {
          "id": "test-execution-result",
          "label": "Test execution result",
          "category": "thing",
          "description": "A structured record of the outcome of a test execution job, including check results and debug info.",
          "aliases": [
            "TestExecutionResult",
            "test execution result",
            "test run result"
          ],
          "notes": "A TestExecutionResult is the structured outcome of executing a single test case against a prompt template and LLM model. It captures the model output text, the model used, an identifier linking it to a broader test run, the overall pass/fail status derived from executing checks, the execution timestamp, and the individual check results. It is produced by executeTest in the shared runtime and is intended to be persisted (e.g., in Firestore) and used for later analysis and debugging."
        },
        {
          "id": "firestore-database",
          "label": "Firestore database",
          "category": "place",
          "description": "The central data store where threads, templates, debug events, and test results are persisted.",
          "aliases": [
            "Firestore database",
            "Firestore",
            "db",
            "getDb",
            "Firebase Firestore",
            "FirestoreLike"
          ],
          "notes": "The Firestore database is the central cloud-hosted document store used by workers, ingest services, and evaluation UIs/functions to persist domain data such as threads, debug events, templates, and test results. It is accessed both via server-side SDKs (@google-cloud/firestore, firebase-admin/firestore) and client-side SDKs (firebase/firestore). A minimal FirestoreLike interface is used in shared runtime utilities so that debug recording can work against real Firestore or test doubles."
        },
        {
          "id": "debug-recording",
          "label": "Debug recording",
          "category": "activity",
          "description": "Capturing and storing debug events and errors to support observability and troubleshooting.",
          "aliases": [
            "Debug recording",
            "debug event",
            "DebugEvent",
            "debugEvents",
            "recordDebugEvent",
            "recordError",
            "debug event recording"
          ],
          "notes": "Debug recording represents the act of capturing structured debug events (including errors) and persisting them, primarily under a thread in Firestore, to support observability and troubleshooting of background jobs, LLM executions, and Slack interactions. Each debug event has a type, timestamp, and structured data payload, and is typically correlated to a root thread timestamp (rootTs) and optionally to a requestId."
        },
        {
          "id": "environment-configuration",
          "label": "Environment configuration",
          "category": "thing",
          "description": "The set of environment variables and configuration values required for services to run correctly.",
          "aliases": [
            "env",
            "environment",
            "environment variables",
            "config",
            "configuration",
            "runtime configuration",
            "worker config",
            "ingest config",
            "functions config"
          ],
          "notes": "Environment configuration represents the collection of environment variables and configuration parameters that must be present for each service (worker, ingest, evals-functions, shared runtime) to operate correctly. It includes raw environment variables (e.g., SLACK_BOT_TOKEN, GOOGLE_CLOUD_PROJECT, REGION, SLACK_SIGNING_SECRET, TASK_QUEUE) and higher-level configuration parameters defined via Firebase Functions params (e.g., WORKER_URL, TASKS_SERVICE_ACCOUNT, TASKS_QUEUE, TASKS_LOCATION). The shared-runtime helpers (requireEnv, optionalEnv) centralize safe access to these values, enforcing that required variables are present at startup or first use."
        },
        {
          "id": "error-handling",
          "label": "Error handling",
          "category": "activity",
          "description": "The practice of capturing, classifying, and safely responding to errors across the system.",
          "aliases": [
            "error handling",
            "structured error handling",
            "structured error system",
            "error boundary",
            "error logging",
            "AppError handling",
            "OperationResult error handling"
          ],
          "notes": "Error handling in this system is a structured, shared-runtime concern that standardizes how errors are captured, classified by severity, logged, and surfaced to users. It uses a common AppError shape and ErrorSeverity enum, and is applied both in UI (React ErrorBoundary, ErrorDisplay) and backend/shared code (ErrorHandler service, OperationResult wrapper). It distinguishes between user-facing messages and technical details, and tracks whether operations are recoverable."
        },
        {
          "id": "logging",
          "label": "Logging",
          "category": "activity",
          "description": "Recording informational and error logs, often tied to specific requests or jobs.",
          "aliases": [
            "logging",
            "structured logging",
            "logInfo",
            "logError",
            "withRequest",
            "logs",
            "log messages"
          ],
          "notes": "Logging is the practice of emitting structured informational and error messages during job and request processing. In this system, logs are JSON-structured records with at least a level and message, and may include additional contextual fields (such as request-related metadata). Logging is shared across services and is intentionally minimal but designed to be extended with richer structured fields over time."
        },
        {
          "id": "cloud-task",
          "label": "Cloud task",
          "category": "thing",
          "description": "A Google Cloud Tasks entry used to schedule and run background jobs like test execution or LLM work.",
          "aliases": [
            "Cloud Tasks entry",
            "Cloud Tasks job",
            "task",
            "queued task",
            "background task"
          ],
          "notes": "A Cloud task is a Google Cloud Tasks entry created by the system to invoke the worker Cloud Run service asynchronously for background jobs such as test execution or LLM work. It is configured via environment parameters for queue name, location, worker URL, and service account used for OIDC authentication."
        }
      ],
      "relationships": [
        {
          "id": "background-job-uses-cloud-task",
          "from": "background-job",
          "to": "cloud-task",
          "phrase": "is triggered by",
          "category": "uses",
          "description": "A background job is triggered by a Cloud Task entry that delivers the job payload to the worker endpoint."
        },
        {
          "id": "background-job-uses-firestore",
          "from": "background-job",
          "to": "firestore-database",
          "phrase": "reads from and writes to",
          "category": "uses",
          "description": "A background job uses the Firestore database to load and persist domain data such as threads, test batches, test cases, and test results."
        },
        {
          "id": "background-job-produces-test-execution-result",
          "from": "background-job",
          "to": "test-execution-result",
          "phrase": "produces",
          "category": "causes",
          "description": "A test execution background job produces a test execution result after running a single test case."
        },
        {
          "id": "background-job-uses-environment-configuration",
          "from": "background-job",
          "to": "environment-configuration",
          "phrase": "depends on",
          "category": "uses",
          "description": "A background job depends on environment configuration such as worker URLs, project identifiers, regions, queues, and service accounts to run correctly."
        },
        {
          "id": "background-job-participates-in-debug-recording",
          "from": "background-job",
          "to": "debug-recording",
          "phrase": "emits events for",
          "category": "causes",
          "description": "A background job emits debug information and timing data that can be captured as debug recordings for observability and troubleshooting."
        },
        {
          "id": "background-job-uses-logging",
          "from": "background-job",
          "to": "logging",
          "phrase": "writes",
          "category": "uses",
          "description": "A background job writes informational and warning logs to trace its execution and decisions."
        },
        {
          "id": "background-job-uses-error-handling",
          "from": "background-job",
          "to": "error-handling",
          "phrase": "applies",
          "category": "uses",
          "description": "A background job applies structured error handling to detect missing data, invalid states, and operational failures, and to decide whether to continue or abort."
        },
        {
          "id": "background-job-represents-asynchronous-work",
          "from": "background-job",
          "to": "event-envelope",
          "phrase": "may be initiated from",
          "category": "represents",
          "description": "A background job may be initiated as a followâ€‘up to an incoming Slack event represented by an event envelope, decoupling the longâ€‘running work from the original event."
        },
        {
          "id": "event-envelope-represents-background-job-trigger",
          "from": "event-envelope",
          "to": "background-job",
          "phrase": "may initiate",
          "category": "causes",
          "description": "An event envelope representing an incoming Slack event may be used as the trigger that initiates a background job, such as running an LLM classification or executing tests."
        },
        {
          "id": "event-envelope-represents-slack-message-context",
          "from": "event-envelope",
          "to": "debug-recording",
          "phrase": "provides context for",
          "category": "enables",
          "description": "Event envelopes provide Slack-specific context (channel, timestamps, user, text) that can be attached to debug recordings to make troubleshooting and observability easier."
        },
        {
          "id": "event-envelope-enables-logging-correlation",
          "from": "event-envelope",
          "to": "logging",
          "phrase": "provides correlation identifiers for",
          "category": "enables",
          "description": "Event envelopes supply identifiers such as channel and timestamps that can be used to correlate logs related to a specific Slack event or thread."
        },
        {
          "id": "event-envelope-enables-error-handling-context",
          "from": "event-envelope",
          "to": "error-handling",
          "phrase": "provides contextual data for",
          "category": "enables",
          "description": "Event envelopes can be used as contextual data when capturing and classifying errors, helping error handling routines tie failures back to the originating Slack event."
        },
        {
          "id": "event-envelope-related-to-task-payload",
          "from": "event-envelope",
          "to": "task-payload",
          "phrase": "is transformed into",
          "category": "precedes",
          "description": "An event envelope representing an incoming Slack event is typically transformed into a task payload that is more suitable for background processing and scheduling."
        },
        {
          "id": "rel-test-exec-result-produced-by-background-job",
          "from": "test-execution-result",
          "to": "background-job",
          "phrase": "is produced by",
          "category": "causes",
          "description": "A Test execution result is produced as the outcome of a background job that runs a test case."
        },
        {
          "id": "rel-test-exec-result-stored-in-firestore",
          "from": "test-execution-result",
          "to": "firestore-database",
          "phrase": "is stored in",
          "category": "uses",
          "description": "A Test execution result is intended to be persisted in the Firestore database for later retrieval and analysis."
        },
        {
          "id": "rel-test-exec-result-linked-to-debug-recording",
          "from": "test-execution-result",
          "to": "debug-recording",
          "phrase": "is associated with",
          "category": "enables",
          "description": "A Test execution result is associated with debug recordings created via the debug context used during prompt execution."
        },
        {
          "id": "rel-test-exec-result-derived-from-background-job-logging",
          "from": "test-execution-result",
          "to": "logging",
          "phrase": "is complemented by",
          "category": "uses",
          "description": "A Test execution result is complemented by logs written during test execution, such as template and model information."
        },
        {
          "id": "rel-test-exec-result-aggregated-by-test-run",
          "from": "test-execution-result",
          "to": "test-run",
          "phrase": "belongs to",
          "category": "part_of",
          "description": "A Test execution result belongs to a broader test run, identified by testRunResultId, which aggregates multiple test execution results."
        },
        {
          "id": "rel-test-exec-result-derived-from-test-case",
          "from": "test-execution-result",
          "to": "test-case",
          "phrase": "is derived from",
          "category": "causes",
          "description": "A Test execution result is derived from executing a specific test case, including its assigned checks."
        },
        {
          "id": "rel-test-exec-result-derived-from-prompt-template",
          "from": "test-execution-result",
          "to": "prompt-template",
          "phrase": "is derived from",
          "category": "causes",
          "description": "A Test execution result is derived from rendering and executing a specific prompt template with input variables."
        },
        {
          "id": "rel-test-exec-result-includes-check-results",
          "from": "test-execution-result",
          "to": "check-result",
          "phrase": "includes",
          "category": "part_of",
          "description": "A Test execution result includes one or more check results that evaluate the model output against expectations."
        },
        {
          "id": "rel-test-exec-result-produced-by-llm-execution",
          "from": "test-execution-result",
          "to": "llm-execution",
          "phrase": "summarizes outcome of",
          "category": "represents",
          "description": "A Test execution result summarizes the outcome of an LLM execution (executePrompt) for a rendered prompt."
        },
        {
          "id": "firestore-stores-test-execution-result",
          "from": "firestore-database",
          "to": "test-execution-result",
          "phrase": "stores",
          "category": "uses",
          "description": "The Firestore database persists structured test execution results produced by background jobs so they can be queried and inspected later."
        },
        {
          "id": "firestore-receives-debug-recording",
          "from": "firestore-database",
          "to": "debug-recording",
          "phrase": "receives and stores",
          "category": "uses",
          "description": "The Firestore database stores debug recordings, such as debug events and error events, under thread documents to support observability and troubleshooting."
        },
        {
          "id": "firestore-used-by-background-job",
          "from": "firestore-database",
          "to": "background-job",
          "phrase": "is read and written by",
          "category": "uses",
          "description": "Background jobs use the Firestore database as their primary persistence layer for threads, debug events, and test results."
        },
        {
          "id": "firestore-used-by-debug-recording-utilities",
          "from": "firestore-database",
          "to": "debug-recording",
          "phrase": "is accessed through a FirestoreLike interface by",
          "category": "enables",
          "description": "Debug recording utilities depend on a Firestore-like interface to write debug events into the Firestore database, enabling consistent debug storage across services."
        },
        {
          "id": "firestore-organizes-threads",
          "from": "firestore-database",
          "to": "thread",
          "phrase": "organizes debug events under",
          "category": "part_of",
          "description": "The Firestore database stores debug events in a debugEvents subcollection under a thread document, using the thread's root timestamp as the document identifier."
        },
        {
          "id": "firestore-stores-llm-debug-events",
          "from": "firestore-database",
          "to": "debug-recording",
          "phrase": "stores LLM request debug events as",
          "category": "uses",
          "description": "When executing prompts, LLM request metadata is recorded as debug events in the Firestore database, capturing model, prompt, template, and variable information."
        },
        {
          "id": "firestore-configured-by-environment",
          "from": "firestore-database",
          "to": "environment-configuration",
          "phrase": "is configured by",
          "category": "uses",
          "description": "The Firestore database connection and project selection depend on environment configuration such as Firebase config and ADC (Application Default Credentials)."
        },
        {
          "id": "debug-recording-uses-firestore",
          "from": "debug-recording",
          "to": "firestore-database",
          "phrase": "stores events in",
          "category": "uses",
          "description": "Debug recording stores debug events in the Firestore database, under the thread document's debugEvents subcollection."
        },
        {
          "id": "debug-recording-part-of-thread",
          "from": "debug-recording",
          "to": "thread",
          "phrase": "is organized under",
          "category": "part_of",
          "description": "Each debug recording is associated with a specific thread, identified by rootTs, and stored as a debugEvents subcollection of that thread."
        },
        {
          "id": "debug-recording-enables-test-execution-result",
          "from": "debug-recording",
          "to": "test-execution-result",
          "phrase": "provides supporting detail for",
          "category": "enables",
          "description": "Debug recordings provide detailed context and trace information that complement and help interpret test execution results."
        },
        {
          "id": "debug-recording-uses-error-handling",
          "from": "debug-recording",
          "to": "error-handling",
          "phrase": "captures structured error information for",
          "category": "uses",
          "description": "Debug recording captures error codes, messages, severity, context, and stack traces as structured error_occurred events that support the system's error handling practices."
        },
        {
          "id": "debug-recording-uses-logging",
          "from": "debug-recording",
          "to": "logging",
          "phrase": "logs errors alongside",
          "category": "uses",
          "description": "When recording errors, debug recording also writes to the logging system (e.g., logError and console.error) to ensure visibility even if persistence fails."
        },
        {
          "id": "debug-recording-enables-background-job-observability",
          "from": "debug-recording",
          "to": "background-job",
          "phrase": "captures events emitted by",
          "category": "enables",
          "description": "Debug recording captures debug events emitted by background jobs, enabling observability into their behavior and performance."
        },
        {
          "id": "debug-recording-uses-environment-configuration",
          "from": "debug-recording",
          "to": "environment-configuration",
          "phrase": "depends on configuration of",
          "category": "uses",
          "description": "Debug recording indirectly depends on environment configuration that sets up Firestore access and related runtime settings."
        },
        {
          "id": "debug-recording-represents-llm-interactions",
          "from": "debug-recording",
          "to": "llm-execution",
          "phrase": "captures request and response details for",
          "category": "represents",
          "description": "Debug recording represents LLM interactions via llm_request and llm_response events, including prompts, models, timing, and template context."
        },
        {
          "id": "debug-recording-represents-slack-interactions",
          "from": "debug-recording",
          "to": "slack-message",
          "phrase": "captures metadata for",
          "category": "represents",
          "description": "Debug recording represents Slack interactions via events such as incoming_slack_message, thread_created, and time_to_react, capturing message timestamps, channels, users, and timing."
        },
        {
          "id": "debug-recording-uses-event-envelope-context",
          "from": "debug-recording",
          "to": "event-envelope",
          "phrase": "is enriched by context from",
          "category": "uses",
          "description": "Debug recording can use correlation identifiers and contextual data from the event envelope to relate debug events to specific jobs or requests."
        },
        {
          "id": "environment-configuration-configures-firestore-database-project-region",
          "from": "environment-configuration",
          "to": "firestore-database",
          "phrase": "configures project and region for",
          "category": "uses",
          "description": "Environment configuration provides the Google Cloud project ID and region values that determine which Firestore database instance the services connect to."
        },
        {
          "id": "environment-configuration-enables-background-job-slack-integration",
          "from": "environment-configuration",
          "to": "background-job",
          "phrase": "enables Slack integration for",
          "category": "enables",
          "description": "Environment configuration supplies Slack-related secrets (such as SLACK_BOT_TOKEN and SLACK_SIGNING_SECRET) that allow background jobs and related services to authenticate with Slack."
        },
        {
          "id": "environment-configuration-configures-cloud-task-queue",
          "from": "environment-configuration",
          "to": "cloud-task",
          "phrase": "configures queue and location for",
          "category": "uses",
          "description": "Environment configuration provides the Cloud Tasks queue name and location (e.g., TASKS_QUEUE, TASKS_LOCATION, TASK_QUEUE) used when creating and dispatching Cloud Tasks."
        },
        {
          "id": "environment-configuration-configures-cloud-task-service-account",
          "from": "environment-configuration",
          "to": "cloud-task",
          "phrase": "configures service account for",
          "category": "uses",
          "description": "Environment configuration specifies the service account email (TASKS_SERVICE_ACCOUNT) used for Cloud Tasks OIDC tokens when invoking worker services."
        },
        {
          "id": "environment-configuration-configures-worker-endpoint-for-background-job",
          "from": "environment-configuration",
          "to": "background-job",
          "phrase": "configures worker endpoint for",
          "category": "enables",
          "description": "Environment configuration defines the worker service URL (WORKER_URL) that is used to route job execution requests to the worker that runs background jobs."
        },
        {
          "id": "environment-configuration-enables-debug-recording-storage",
          "from": "environment-configuration",
          "to": "debug-recording",
          "phrase": "enables storage location for",
          "category": "enables",
          "description": "Environment configuration, by determining the Firestore project and region, indirectly controls where debug recordings are written and read."
        },
        {
          "id": "environment-configuration-enables-error-handling-behavior",
          "from": "environment-configuration",
          "to": "error-handling",
          "phrase": "enables strict checks for",
          "category": "enables",
          "description": "Environment configuration is accessed via helpers like requireEnv, which throw explicit errors when required variables are missing, supporting consistent error handling around misconfiguration."
        },
        {
          "id": "environment-configuration-influences-logging-context",
          "from": "environment-configuration",
          "to": "logging",
          "phrase": "influences context for",
          "category": "enables",
          "description": "Environment configuration values such as project ID and region influence the contextual information included in logs, tying log entries to a specific deployment environment."
        },
        {
          "id": "rel-error-handling-uses-debug-recording",
          "from": "error-handling",
          "to": "debug-recording",
          "phrase": "produces structured error events for",
          "category": "causes",
          "description": "Error handling emits structured error information (e.g., via logError in the shared runtime) that is captured as debug recordings to support observability and troubleshooting."
        },
        {
          "id": "rel-error-handling-uses-logging",
          "from": "error-handling",
          "to": "logging",
          "phrase": "writes structured error logs to",
          "category": "uses",
          "description": "Error handling uses the logging system to record errors with severity, codes, and context, ensuring consistent error log output across the system."
        },
        {
          "id": "rel-error-handling-uses-firestore-database",
          "from": "error-handling",
          "to": "firestore-database",
          "phrase": "normalizes datastore errors from",
          "category": "uses",
          "description": "Error handling converts low-level Firestore or Firebase errors into structured AppError instances, mapping datastore error codes to user-friendly messages and recoverability flags."
        },
        {
          "id": "rel-error-handling-enables-background-job",
          "from": "error-handling",
          "to": "background-job",
          "phrase": "classifies and reports failures in",
          "category": "enables",
          "description": "Error handling provides a consistent way for background jobs to represent success or failure (via OperationResult and AppError), including severity and recoverability."
        },
        {
          "id": "rel-error-handling-uses-event-envelope",
          "from": "error-handling",
          "to": "event-envelope",
          "phrase": "may attach contextual metadata from",
          "category": "uses",
          "description": "Error handling can include contextual metadata from the originating event envelope in the AppError.context field to aid debugging and correlation."
        },
        {
          "id": "rel-error-handling-uses-environment-configuration",
          "from": "error-handling",
          "to": "environment-configuration",
          "phrase": "is influenced by strictness settings in",
          "category": "uses",
          "description": "Error handling behavior, such as strict checks or logging destinations, is influenced by environment configuration, which can enable stricter error policies in certain environments."
        },
        {
          "id": "rel-error-handling-represents-operation-result",
          "from": "error-handling",
          "to": "operation-result",
          "phrase": "structures outcomes as",
          "category": "represents",
          "description": "Error handling represents the outcome of operations using a shared OperationResult type that encapsulates success flags, data, and AppError details."
        },
        {
          "id": "rel-error-handling-represents-app-error",
          "from": "error-handling",
          "to": "app-error",
          "phrase": "encapsulates error details in",
          "category": "represents",
          "description": "Error handling uses the AppError structure to represent machine-readable error codes, user-facing messages, severity, technical details, recoverability, and context."
        },
        {
          "id": "rel-error-handling-classifies-error-severity",
          "from": "error-handling",
          "to": "error-severity",
          "phrase": "classifies errors by",
          "category": "represents",
          "description": "Error handling classifies each error with an ErrorSeverity level (low, medium, high, critical) to drive logging level and user communication."
        },
        {
          "id": "rel-error-handling-enables-ui-error-display",
          "from": "error-handling",
          "to": "ui-error-display",
          "phrase": "surfaces user-facing messages through",
          "category": "enables",
          "description": "Error handling surfaces user-friendly error messages via UI components such as ErrorDisplay, which present the error and allow dismissal."
        },
        {
          "id": "rel-error-handling-enables-error-boundary",
          "from": "error-handling",
          "to": "error-boundary",
          "phrase": "captures uncaught UI errors via",
          "category": "enables",
          "description": "Error handling in the frontend uses an ErrorBoundary to catch uncaught React errors, log them via the shared runtime, and present a fallback UI."
        },
        {
          "id": "logging-uses-event-envelope-context",
          "from": "logging",
          "to": "event-envelope",
          "phrase": "includes contextual fields from",
          "category": "uses",
          "description": "Logging entries can include correlation identifiers and other contextual metadata derived from the event envelope, typically via helper functions that merge request-related fields into the log record."
        },
        {
          "id": "logging-supports-test-execution-result",
          "from": "logging",
          "to": "test-execution-result",
          "phrase": "complements",
          "category": "uses",
          "description": "Logging provides additional runtime context and narrative around the creation and evaluation of a test execution result, such as what steps were taken and any notable conditions."
        },
        {
          "id": "logging-is-shaped-by-environment-configuration",
          "from": "logging",
          "to": "environment-configuration",
          "phrase": "is influenced by",
          "category": "uses",
          "description": "Logging behavior and context can be influenced by environment configuration, such as which fields are included, how verbose logs should be, or which environment the logs pertain to."
        },
        {
          "id": "logging-is-fed-by-error-handling",
          "from": "logging",
          "to": "error-handling",
          "phrase": "receives structured error logs from",
          "category": "uses",
          "description": "Error handling emits structured error logs through the logging system, ensuring that failures are recorded with consistent structure and severity."
        },
        {
          "id": "logging-is-used-by-background-job",
          "from": "logging",
          "to": "background-job",
          "phrase": "records activity for",
          "category": "uses",
          "description": "Background jobs use logging to record informational and error messages about their execution, including job start, progress, and failures."
        },
        {
          "id": "logging-coexists-with-debug-recording",
          "from": "logging",
          "to": "debug-recording",
          "phrase": "is used alongside",
          "category": "other",
          "description": "Logging operates in parallel with debug recording, with logs capturing concise structured messages while debug recordings may store richer, more detailed diagnostic data."
        },
        {
          "id": "cloud-task-uses-environment-configuration",
          "from": "cloud-task",
          "to": "environment-configuration",
          "phrase": "is configured by",
          "category": "uses",
          "description": "A cloud task relies on environment configuration values such as queue name, location, worker URL, and service account to be created and dispatched correctly."
        },
        {
          "id": "cloud-task-triggers-background-job",
          "from": "cloud-task",
          "to": "background-job",
          "phrase": "triggers",
          "category": "causes",
          "description": "A cloud task, when executed by Cloud Tasks, triggers a background job on the worker service to perform work such as test execution or LLM processing."
        },
        {
          "id": "cloud-task-carries-event-envelope",
          "from": "cloud-task",
          "to": "event-envelope",
          "phrase": "carries as payload",
          "category": "represents",
          "description": "A cloud task carries an event envelope (or a derived task payload) that encapsulates the contextual data and metadata needed by the background job."
        },
        {
          "id": "cloud-task-precedes-background-job",
          "from": "cloud-task",
          "to": "background-job",
          "phrase": "is enqueued before",
          "category": "precedes",
          "description": "A cloud task is created and enqueued before the corresponding background job is actually executed by the worker."
        }
      ],
      "rules": [
        {
          "id": "background-job-requires-valid-payload",
          "title": "Background job requires a valid payload",
          "text": "A background job must receive a wellâ€‘formed payload (such as TaskPayload or TestExecutionTaskPayload) containing all required identifiers and context needed to perform its work.",
          "kind": "invariant",
          "conceptIds": [
            "background-job"
          ]
        },
        {
          "id": "background-job-must-check-cancellation",
          "title": "Test execution job must respect batch cancellation",
          "text": "A test execution background job must check whether its associated test batch exists and is not cancelled before executing the test; if the batch is missing or cancelled, the job must skip execution.",
          "kind": "policy",
          "conceptIds": [
            "background-job"
          ]
        },
        {
          "id": "background-job-must-handle-missing-domain-data",
          "title": "Background job must handle missing domain data",
          "text": "If a background job depends on domain data such as a test case or input variables and that data is missing, the job must treat this as an error and stop further processing for that unit of work.",
          "kind": "constraint",
          "conceptIds": [
            "background-job"
          ]
        },
        {
          "id": "background-job-llm-requires-channel-and-rootTs",
          "title": "LLM job requires channel and root thread timestamp",
          "text": "An LLM background job must have both a Slack channel identifier and a root thread timestamp; if either is missing, the job must not proceed.",
          "kind": "invariant",
          "conceptIds": [
            "background-job"
          ]
        },
        {
          "id": "rule-event-envelope-identifies-slack-message",
          "title": "Event envelope must uniquely identify the originating Slack message",
          "text": "An event envelope must include an eventId, channel, and ts so that the originating Slack message or event can be uniquely identified and correlated with subsequent processing and logging.",
          "kind": "constraint",
          "conceptIds": [
            "event-envelope"
          ]
        },
        {
          "id": "rule-event-envelope-thread-linking",
          "title": "Event envelope may link to a Slack thread",
          "text": "If the originating Slack event is part of a thread, the event envelope should include threadTs to allow downstream jobs, logging, and debug recordings to associate work with the correct Slack thread.",
          "kind": "assumption",
          "conceptIds": [
            "event-envelope"
          ]
        },
        {
          "id": "rule-event-envelope-user-and-text-optional",
          "title": "User and text in event envelope are optional context",
          "text": "The user and text fields in an event envelope are optional and are treated as additional context for processing, logging, and debugging rather than as required identifiers.",
          "kind": "assumption",
          "conceptIds": [
            "event-envelope"
          ]
        },
        {
          "id": "rule-test-exec-result-overall-status-required",
          "title": "Test execution result must have an overall status",
          "text": "Each Test execution result must record an overallStatus value of either 'pass' or 'fail' to indicate the aggregate outcome of all checks.",
          "kind": "constraint",
          "conceptIds": [
            "test-execution-result"
          ]
        },
        {
          "id": "rule-test-exec-result-has-model-name",
          "title": "Test execution result must record model name",
          "text": "Each Test execution result must record the modelName used for the LLM execution so that results can be attributed to a specific model configuration.",
          "kind": "constraint",
          "conceptIds": [
            "test-execution-result"
          ]
        },
        {
          "id": "rule-test-exec-result-has-executed-at",
          "title": "Test execution result must record execution time",
          "text": "Each Test execution result must record an executedAt timestamp indicating when the test case was executed.",
          "kind": "constraint",
          "conceptIds": [
            "test-execution-result"
          ]
        },
        {
          "id": "rule-test-exec-result-linked-to-test-run",
          "title": "Test execution result must be linked to a test run",
          "text": "Each Test execution result must include a testRunResultId that links it to a broader test run context.",
          "kind": "assumption",
          "conceptIds": [
            "test-execution-result"
          ]
        },
        {
          "id": "rule-test-exec-result-text-required",
          "title": "Test execution result must capture model output text",
          "text": "Each Test execution result must capture the model output text produced during LLM execution in the text field.",
          "kind": "constraint",
          "conceptIds": [
            "test-execution-result"
          ]
        },
        {
          "id": "rule-test-exec-result-check-results-optional",
          "title": "Check results may be absent",
          "text": "A Test execution result may omit checkResults when no checks are defined or executed for the test case.",
          "kind": "assumption",
          "conceptIds": [
            "test-execution-result"
          ]
        },
        {
          "id": "firestore-ignore-undefined-properties",
          "title": "Firestore ignores undefined properties",
          "text": "When writing documents to the Firestore database, undefined properties are ignored rather than stored, ensuring only defined fields are persisted.",
          "kind": "invariant",
          "conceptIds": [
            "firestore-database"
          ]
        },
        {
          "id": "firestore-debug-events-under-threads",
          "title": "Debug events are stored under thread documents",
          "text": "Debug events must be stored in a debugEvents subcollection under a thread document identified by the root timestamp, so that all debug information for a thread is grouped together.",
          "kind": "constraint",
          "conceptIds": [
            "firestore-database"
          ]
        },
        {
          "id": "firestore-debug-event-id-format",
          "title": "Debug event identifiers encode type and timestamp",
          "text": "Each debug event stored in Firestore uses an identifier composed of the event type and its timestamp, ensuring uniqueness and traceability within a thread.",
          "kind": "assumption",
          "conceptIds": [
            "firestore-database"
          ]
        },
        {
          "id": "firestore-error-recording-non-fatal",
          "title": "Failure to record debug events must not break main flow",
          "text": "If writing a debug event or error event to the Firestore database fails, the system logs the failure but does not propagate the error, so primary job processing continues.",
          "kind": "policy",
          "conceptIds": [
            "firestore-database"
          ]
        },
        {
          "id": "debug-recording-unique-event-id",
          "title": "Debug event identifier is derived from type and timestamp",
          "text": "Each debug recording stored in Firestore must use an eventId composed of the event type and timestamp (\"<type>_<timestamp>\") to identify the document within the debugEvents subcollection.",
          "kind": "invariant",
          "conceptIds": [
            "debug-recording"
          ]
        },
        {
          "id": "debug-recording-requires-type-timestamp-data",
          "title": "Debug event must be structured",
          "text": "Every debug recording must include a type string, an ISO-8601 timestamp string, and a structured data object appropriate to that type.",
          "kind": "constraint",
          "conceptIds": [
            "debug-recording"
          ]
        },
        {
          "id": "debug-recording-associated-with-root-thread",
          "title": "Debug event must be associated with a root thread",
          "text": "Every debug recording must be associated with a root thread identifier (rootTs) so that it can be stored under the corresponding thread document.",
          "kind": "constraint",
          "conceptIds": [
            "debug-recording"
          ]
        },
        {
          "id": "debug-recording-error-always-logged",
          "title": "Errors are always logged even if debug recording fails",
          "text": "When recording an error, the system must log the error via the logging mechanism before attempting to persist it as a debug event, and failures to persist the debug event must not prevent the original error from being logged.",
          "kind": "policy",
          "conceptIds": [
            "debug-recording"
          ]
        },
        {
          "id": "debug-recording-non-fatal-on-failure",
          "title": "Debug recording failures are non-fatal",
          "text": "If persisting a debug recording fails, the system must not throw or propagate that failure in a way that disrupts the main job or request flow; it should instead log the failure.",
          "kind": "policy",
          "conceptIds": [
            "debug-recording"
          ]
        },
        {
          "id": "debug-recording-json-serializable-data",
          "title": "Debug event data must be JSON-serializable",
          "text": "The data payload of a debug recording must be JSON-serializable so that it can be safely stored in Firestore and rendered in the debug events UI.",
          "kind": "assumption",
          "conceptIds": [
            "debug-recording"
          ]
        },
        {
          "id": "environment-configuration-required-vars-must-be-present",
          "title": "Required environment variables must be present",
          "text": "Any environment variable accessed via the shared requireEnv helper is considered mandatory; if it is not set, the system must throw an error and fail fast rather than running with an undefined configuration.",
          "kind": "invariant",
          "conceptIds": [
            "environment-configuration"
          ]
        },
        {
          "id": "environment-configuration-slack-secrets-must-be-configured",
          "title": "Slack secrets must be configured for Slack-related services",
          "text": "Services that interact with Slack must have the appropriate Slack secrets configured in the environment (e.g., SLACK_BOT_TOKEN for the worker and SLACK_SIGNING_SECRET for the ingest service); otherwise, Slack requests cannot be authenticated or authorized.",
          "kind": "constraint",
          "conceptIds": [
            "environment-configuration"
          ]
        },
        {
          "id": "environment-configuration-project-id-must-be-known",
          "title": "Project ID must be known for GCP resources",
          "text": "A valid Google Cloud project identifier must be provided via environment configuration (e.g., GOOGLE_CLOUD_PROJECT or PROJECT_ID) so that Firestore and Cloud Tasks can be addressed correctly.",
          "kind": "constraint",
          "conceptIds": [
            "environment-configuration"
          ]
        },
        {
          "id": "environment-configuration-queue-and-location-must-be-consistent",
          "title": "Cloud Tasks queue and location must be configured consistently",
          "text": "The Cloud Tasks queue name and location provided in environment configuration must correspond to an existing queue in the target project; misalignment will prevent background jobs from being scheduled.",
          "kind": "assumption",
          "conceptIds": [
            "environment-configuration"
          ]
        },
        {
          "id": "environment-configuration-may-provide-defaults",
          "title": "Environment configuration may provide safe defaults",
          "text": "Some configuration parameters may define default values (for example, default worker URL, default tasks queue, or default tasks location) that are used when explicit environment values are not provided, allowing non-production environments to function without full configuration.",
          "kind": "policy",
          "conceptIds": [
            "environment-configuration"
          ]
        },
        {
          "id": "rule-error-handling-structured-app-error",
          "title": "Errors must be represented as structured AppError objects",
          "text": "Application-level errors should be represented using the shared AppError type, including a machine-readable code, user-friendly message, severity, recoverability flag, and optional technical and context fields.",
          "kind": "invariant",
          "conceptIds": [
            "error-handling"
          ]
        },
        {
          "id": "rule-error-handling-severity-drives-logging",
          "title": "Error severity determines logging level",
          "text": "The ErrorSeverity associated with an AppError determines how it is logged: critical and high severities are logged as errors, medium as warnings, and low as informational messages.",
          "kind": "policy",
          "conceptIds": [
            "error-handling"
          ]
        },
        {
          "id": "rule-error-handling-operation-result-wrapper",
          "title": "Operations should return structured results",
          "text": "Operations that can fail should return an OperationResult wrapper indicating success or failure and, on failure, include a structured AppError instead of throwing unstructured errors.",
          "kind": "policy",
          "conceptIds": [
            "error-handling"
          ]
        },
        {
          "id": "rule-error-handling-firebase-normalization",
          "title": "Firebase errors must be normalized",
          "text": "Errors originating from Firebase or Firestore should be converted into AppError instances using the shared normalization logic so that datastore-specific codes are mapped to consistent user-facing messages and recoverability flags.",
          "kind": "policy",
          "conceptIds": [
            "error-handling"
          ]
        },
        {
          "id": "rule-error-handling-user-vs-technical-message",
          "title": "Separate user-facing and technical error information",
          "text": "Error handling must distinguish between user-facing messages and technical details, exposing only the user-friendly message to end users while reserving technical details for logs and debug recordings.",
          "kind": "policy",
          "conceptIds": [
            "error-handling"
          ]
        },
        {
          "id": "logging-structured-json",
          "title": "Logs must be structured as JSON objects",
          "text": "All log entries are emitted as JSON objects containing at least a level and message field, with optional additional structured fields.",
          "kind": "invariant",
          "conceptIds": [
            "logging"
          ]
        },
        {
          "id": "logging-level-required",
          "title": "Logs must include a severity level",
          "text": "Each log entry must include a level field indicating its severity, such as 'info' or 'error'.",
          "kind": "invariant",
          "conceptIds": [
            "logging"
          ]
        },
        {
          "id": "logging-message-required",
          "title": "Logs must include a human-readable message",
          "text": "Each log entry must include a message field that provides a human-readable description of the event being logged.",
          "kind": "invariant",
          "conceptIds": [
            "logging"
          ]
        },
        {
          "id": "logging-request-context-merge",
          "title": "Request context fields are merged into log fields",
          "text": "When request or job context is attached to a log entry, its fields are merged into the log's structured fields, with later fields overriding earlier ones on key conflicts.",
          "kind": "assumption",
          "conceptIds": [
            "logging"
          ]
        },
        {
          "id": "cloud-task-must-have-queue-and-location",
          "title": "Cloud task must specify queue and location",
          "text": "Every cloud task must be associated with a configured Cloud Tasks queue name and location, derived from environment configuration, to be enqueued and executed.",
          "kind": "constraint",
          "conceptIds": [
            "cloud-task"
          ]
        },
        {
          "id": "cloud-task-must-target-worker-url",
          "title": "Cloud task must target worker service URL",
          "text": "Every cloud task created for this system must target the configured worker Cloud Run service URL so that background jobs are executed by the correct worker.",
          "kind": "policy",
          "conceptIds": [
            "cloud-task"
          ]
        },
        {
          "id": "cloud-task-must-use-tasks-service-account",
          "title": "Cloud task must use tasks service account for authentication",
          "text": "Every cloud task must be configured to use the designated tasks service account for OIDC tokens when invoking the worker, ensuring authenticated calls to the worker service.",
          "kind": "policy",
          "conceptIds": [
            "cloud-task"
          ]
        }
      ],
      "lifecycles": [],
      "views": [
        {
          "id": "job-trigger-and-queueing",
          "name": "Background job trigger and queueing",
          "kind": "lifecycle",
          "description": "Shows how environment configuration, event envelopes, and Cloud Tasks work together to trigger background jobs.",
          "conceptIds": [
            "environment-configuration",
            "event-envelope",
            "cloud-task",
            "background-job",
            "logging"
          ],
          "relationshipIds": [
            "environment-configuration-configures-cloud-task-queue",
            "environment-configuration-configures-cloud-task-service-account",
            "cloud-task-uses-environment-configuration",
            "cloud-task-carries-event-envelope",
            "cloud-task-precedes-background-job",
            "cloud-task-triggers-background-job",
            "background-job-represents-asynchronous-work",
            "event-envelope-represents-background-job-trigger",
            "event-envelope-enables-logging-correlation",
            "logging-uses-event-envelope-context"
          ]
        },
        {
          "id": "job-execution-and-results",
          "name": "Background job execution and test results",
          "kind": "lifecycle",
          "description": "Focuses on how a background job uses Firestore and produces structured test execution results.",
          "conceptIds": [
            "background-job",
            "firestore-database",
            "test-execution-result",
            "logging",
            "debug-recording"
          ],
          "relationshipIds": [
            "background-job-uses-firestore",
            "background-job-produces-test-execution-result",
            "background-job-participates-in-debug-recording",
            "background-job-uses-logging",
            "firestore-stores-test-execution-result",
            "firestore-receives-debug-recording",
            "debug-recording-enables-test-execution-result",
            "debug-recording-enables-background-job-observability",
            "logging-supports-test-execution-result",
            "logging-is-used-by-background-job"
          ]
        },
        {
          "id": "observability-and-error-pipeline",
          "name": "Error handling, logging, and debug recording",
          "kind": "implementation",
          "description": "Explains how errors are captured, structured, logged, and recorded for observability around background jobs.",
          "conceptIds": [
            "environment-configuration",
            "event-envelope",
            "error-handling",
            "logging",
            "debug-recording",
            "background-job"
          ],
          "relationshipIds": [
            "environment-configuration-enables-error-handling-behavior",
            "environment-configuration-influences-logging-context",
            "logging-is-shaped-by-environment-configuration",
            "rel-error-handling-uses-environment-configuration",
            "rel-error-handling-uses-event-envelope",
            "event-envelope-enables-error-handling-context",
            "logging-uses-event-envelope-context",
            "rel-error-handling-uses-logging",
            "rel-error-handling-uses-debug-recording",
            "rel-error-handling-enables-background-job"
          ]
        },
        {
          "id": "datastore-and-runtime-configuration",
          "name": "Firestore and runtime configuration",
          "kind": "datastore",
          "description": "Shows how environment configuration shapes Firestore usage and how debug recordings and test results are organized in storage.",
          "conceptIds": [
            "environment-configuration",
            "firestore-database",
            "debug-recording",
            "test-execution-result",
            "thread"
          ],
          "relationshipIds": [
            "environment-configuration-configures-firestore-database-project-region",
            "firestore-configured-by-environment",
            "environment-configuration-enables-debug-recording-storage",
            "debug-recording-uses-firestore",
            "firestore-receives-debug-recording",
            "firestore-stores-test-execution-result",
            "firestore-organizes-threads",
            "debug-recording-part-of-thread",
            "rel-test-exec-result-stored-in-firestore",
            "firestore-used-by-debug-recording-utilities"
          ]
        },
        {
          "id": "test-result-context",
          "name": "Test execution result in its testing context",
          "kind": "structure",
          "description": "Positions the test execution result within the broader testing artefacts and LLM execution it summarizes.",
          "conceptIds": [
            "test-execution-result",
            "background-job",
            "test-run",
            "test-case",
            "prompt-template",
            "check-result",
            "llm-execution"
          ],
          "relationshipIds": [
            "rel-test-exec-result-produced-by-background-job",
            "background-job-produces-test-execution-result",
            "rel-test-exec-result-aggregated-by-test-run",
            "rel-test-exec-result-derived-from-test-case",
            "rel-test-exec-result-derived-from-prompt-template",
            "rel-test-exec-result-includes-check-results",
            "rel-test-exec-result-produced-by-llm-execution"
          ]
        }
      ],
      "storyViews": [
        {
          "id": "enqueue-and-run-test-execution-job",
          "name": "Enqueue and Run a Test Execution Background Job",
          "kind": "system_flow",
          "description": "A test execution is requested, wrapped in an event envelope, enqueued as a Cloud Task, executed as a background job, and persisted with logs and debug details.",
          "tags": [
            "background-job",
            "cloud-task",
            "test-execution-result"
          ],
          "focusConceptId": "background-job",
          "steps": [
            {
              "id": "step-0-wrap-request-in-event-envelope",
              "index": 0,
              "title": "Wrap test execution request in an event envelope",
              "narrative": "A test execution request is normalized into an event envelope that carries metadata, correlation IDs, and context for downstream processing and logging.",
              "conceptIds": [
                "event-envelope",
                "logging",
                "debug-recording"
              ],
              "relationshipIds": [
                "event-envelope-enables-logging-correlation",
                "event-envelope-represents-slack-message-context",
                "logging-uses-event-envelope-context",
                "debug-recording-uses-event-envelope-context"
              ],
              "primaryConceptIds": [
                "event-envelope"
              ],
              "primaryRelationshipIds": [
                "event-envelope-enables-logging-correlation"
              ]
            },
            {
              "id": "step-1-enqueue-cloud-task-with-envelope",
              "index": 1,
              "title": "Enqueue Cloud Task carrying the event envelope",
              "narrative": "The system enqueues a Cloud Task whose payload is the event envelope, using environment configuration to select the correct queue, region, and service account.",
              "conceptIds": [
                "cloud-task",
                "event-envelope",
                "environment-configuration"
              ],
              "relationshipIds": [
                "cloud-task-carries-event-envelope",
                "cloud-task-uses-environment-configuration",
                "environment-configuration-configures-cloud-task-queue",
                "environment-configuration-configures-cloud-task-service-account"
              ],
              "primaryConceptIds": [
                "cloud-task"
              ],
              "primaryRelationshipIds": [
                "cloud-task-carries-event-envelope"
              ]
            },
            {
              "id": "step-2-cloud-task-triggers-background-job",
              "index": 2,
              "title": "Cloud Task triggers the background job worker",
              "narrative": "When the Cloud Task becomes due, it calls the configured worker endpoint, triggering a background job that will execute the tests described in the envelope.",
              "conceptIds": [
                "cloud-task",
                "background-job",
                "environment-configuration",
                "event-envelope"
              ],
              "relationshipIds": [
                "cloud-task-triggers-background-job",
                "cloud-task-precedes-background-job",
                "background-job-uses-cloud-task",
                "event-envelope-represents-background-job-trigger",
                "environment-configuration-configures-worker-endpoint-for-background-job"
              ],
              "primaryConceptIds": [
                "background-job"
              ],
              "primaryRelationshipIds": [
                "cloud-task-triggers-background-job"
              ]
            },
            {
              "id": "step-3-job-reads-inputs-and-executes-tests",
              "index": 3,
              "title": "Background job reads inputs and executes tests",
              "narrative": "The background job uses environment configuration to connect to Firestore, reads test definitions and templates, and runs the LLM-based tests while emitting logs and debug events.",
              "conceptIds": [
                "background-job",
                "firestore-database",
                "environment-configuration",
                "logging",
                "debug-recording"
              ],
              "relationshipIds": [
                "background-job-uses-firestore",
                "background-job-uses-environment-configuration",
                "firestore-configured-by-environment",
                "logging-is-shaped-by-environment-configuration",
                "background-job-uses-logging",
                "background-job-participates-in-debug-recording",
                "debug-recording-uses-firestore"
              ],
              "primaryConceptIds": [
                "background-job",
                "firestore-database"
              ],
              "primaryRelationshipIds": [
                "background-job-uses-firestore"
              ]
            },
            {
              "id": "step-4-job-produces-and-stores-test-execution-result",
              "index": 4,
              "title": "Background job produces and stores test execution result",
              "narrative": "After running the tests, the background job assembles a test execution result, complements it with logs and debug references, and writes it to Firestore for later retrieval.",
              "conceptIds": [
                "background-job",
                "test-execution-result",
                "firestore-database",
                "logging",
                "debug-recording"
              ],
              "relationshipIds": [
                "background-job-produces-test-execution-result",
                "rel-test-exec-result-produced-by-background-job",
                "rel-test-exec-result-stored-in-firestore",
                "firestore-stores-test-execution-result",
                "rel-test-exec-result-derived-from-background-job-logging",
                "logging-supports-test-execution-result",
                "rel-test-exec-result-linked-to-debug-recording",
                "debug-recording-enables-test-execution-result"
              ],
              "primaryConceptIds": [
                "test-execution-result"
              ],
              "primaryRelationshipIds": [
                "background-job-produces-test-execution-result"
              ]
            },
            {
              "id": "step-5-debug-recording-and-logs-complete-observability",
              "index": 5,
              "title": "Debug recording and logs complete observability",
              "narrative": "Debug recordings and logs associated with the job are stored in Firestore and can be correlated back to the test execution result using the event envelope context.",
              "conceptIds": [
                "debug-recording",
                "logging",
                "firestore-database",
                "event-envelope",
                "test-execution-result"
              ],
              "relationshipIds": [
                "firestore-stores-llm-debug-events",
                "firestore-receives-debug-recording",
                "debug-recording-uses-firestore",
                "debug-recording-uses-logging",
                "logging-coexists-with-debug-recording",
                "debug-recording-uses-event-envelope-context",
                "event-envelope-represents-slack-message-context",
                "rel-test-exec-result-linked-to-debug-recording"
              ],
              "primaryConceptIds": [
                "debug-recording",
                "logging"
              ],
              "primaryRelationshipIds": [
                "debug-recording-uses-firestore"
              ]
            }
          ]
        },
        {
          "id": "error-during-background-job-execution",
          "name": "Error Handling During Background Job Execution",
          "kind": "error_flow",
          "description": "A background job encounters an error while interacting with Firestore, and shared error-handling, logging, and debug-recording utilities capture and classify the failure.",
          "tags": [
            "error-handling",
            "logging",
            "debug-recording"
          ],
          "focusConceptId": "error-handling",
          "steps": [
            {
              "id": "step-0-job-starts-with-context",
              "index": 0,
              "title": "Background job starts with contextual envelope",
              "narrative": "A background job is triggered with an event envelope that provides correlation IDs and contextual metadata for any logs or errors that may occur.",
              "conceptIds": [
                "background-job",
                "event-envelope",
                "logging",
                "debug-recording"
              ],
              "relationshipIds": [
                "event-envelope-represents-background-job-trigger",
                "background-job-represents-asynchronous-work",
                "event-envelope-enables-logging-correlation",
                "logging-uses-event-envelope-context",
                "debug-recording-uses-event-envelope-context"
              ],
              "primaryConceptIds": [
                "background-job",
                "event-envelope"
              ],
              "primaryRelationshipIds": [
                "event-envelope-represents-background-job-trigger"
              ]
            },
            {
              "id": "step-1-job-encounters-firestore-error",
              "index": 1,
              "title": "Job encounters a Firestore access error",
              "narrative": "While reading or writing data in Firestore, the background job hits an error such as a permission issue or transient outage, which must be normalized and handled.",
              "conceptIds": [
                "background-job",
                "firestore-database",
                "error-handling"
              ],
              "relationshipIds": [
                "background-job-uses-firestore",
                "firestore-used-by-background-job",
                "rel-error-handling-uses-firestore-database",
                "rel-error-handling-enables-background-job"
              ],
              "primaryConceptIds": [
                "error-handling"
              ],
              "primaryRelationshipIds": [
                "rel-error-handling-uses-firestore-database"
              ]
            },
            {
              "id": "step-2-shared-error-handling-classifies-failure",
              "index": 2,
              "title": "Shared error-handling classifies and structures the failure",
              "narrative": "The shared error-handling utilities classify the error severity, wrap it in a structured app error and operation result, and decide whether the job should retry or fail.",
              "conceptIds": [
                "error-handling",
                "environment-configuration"
              ],
              "relationshipIds": [
                "rel-error-handling-classifies-error-severity",
                "rel-error-handling-represents-operation-result",
                "rel-error-handling-represents-app-error",
                "rel-error-handling-uses-environment-configuration"
              ],
              "primaryConceptIds": [
                "error-handling"
              ],
              "primaryRelationshipIds": [
                "rel-error-handling-classifies-error-severity"
              ]
            },
            {
              "id": "step-3-log-structured-error-with-context",
              "index": 3,
              "title": "Log structured error with envelope context",
              "narrative": "Error-handling utilities emit structured error logs that include event envelope fields, making it easy to trace the failure back to the originating request or job.",
              "conceptIds": [
                "error-handling",
                "logging",
                "event-envelope",
                "environment-configuration"
              ],
              "relationshipIds": [
                "rel-error-handling-uses-logging",
                "logging-is-fed-by-error-handling",
                "logging-uses-event-envelope-context",
                "event-envelope-enables-error-handling-context",
                "rel-error-handling-uses-event-envelope",
                "logging-is-shaped-by-environment-configuration"
              ],
              "primaryConceptIds": [
                "logging"
              ],
              "primaryRelationshipIds": [
                "rel-error-handling-uses-logging"
              ]
            },
            {
              "id": "step-4-record-debug-events-for-troubleshooting",
              "index": 4,
              "title": "Record debug events for troubleshooting",
              "narrative": "In parallel, debug-recording utilities capture structured error information and store it in Firestore, enriched with event envelope context for later analysis.",
              "conceptIds": [
                "debug-recording",
                "error-handling",
                "firestore-database",
                "event-envelope",
                "environment-configuration"
              ],
              "relationshipIds": [
                "rel-error-handling-uses-debug-recording",
                "debug-recording-uses-error-handling",
                "debug-recording-uses-firestore",
                "firestore-receives-debug-recording",
                "debug-recording-uses-event-envelope-context",
                "event-envelope-represents-slack-message-context",
                "debug-recording-uses-environment-configuration",
                "environment-configuration-enables-debug-recording-storage"
              ],
              "primaryConceptIds": [
                "debug-recording"
              ],
              "primaryRelationshipIds": [
                "rel-error-handling-uses-debug-recording"
              ]
            },
            {
              "id": "step-5-job-outcome-reflected-in-test-execution-result",
              "index": 5,
              "title": "Job outcome reflected in test execution result",
              "narrative": "If the job was producing a test execution result, the failure is captured in the result object, which is complemented by logs and debug recordings for full observability.",
              "conceptIds": [
                "test-execution-result",
                "background-job",
                "logging",
                "debug-recording",
                "firestore-database"
              ],
              "relationshipIds": [
                "background-job-produces-test-execution-result",
                "rel-test-exec-result-produced-by-background-job",
                "rel-test-exec-result-derived-from-background-job-logging",
                "logging-supports-test-execution-result",
                "rel-test-exec-result-linked-to-debug-recording",
                "debug-recording-enables-test-execution-result",
                "rel-test-exec-result-stored-in-firestore",
                "firestore-stores-test-execution-result"
              ],
              "primaryConceptIds": [
                "test-execution-result"
              ],
              "primaryRelationshipIds": [
                "rel-test-exec-result-derived-from-background-job-logging"
              ]
            }
          ]
        },
        {
          "id": "configure-environment-for-shared-runtime",
          "name": "Configure Environment for Shared Runtime and Job Processing",
          "kind": "admin_flow",
          "description": "An administrator configures environment variables that shape how background jobs, Cloud Tasks, Firestore, logging, debug recording, and error handling behave.",
          "tags": [
            "environment-configuration",
            "admin",
            "shared-runtime"
          ],
          "focusConceptId": "environment-configuration",
          "steps": [
            {
              "id": "step-0-set-core-environment-variables",
              "index": 0,
              "title": "Set core environment configuration values",
              "narrative": "An administrator defines environment configuration values such as project IDs, regions, and strictness flags that will govern all runtime behavior.",
              "conceptIds": [
                "environment-configuration"
              ],
              "relationshipIds": [],
              "primaryConceptIds": [
                "environment-configuration"
              ],
              "primaryRelationshipIds": []
            },
            {
              "id": "step-1-configure-firestore-and-debug-storage",
              "index": 1,
              "title": "Configure Firestore project, region, and debug storage",
              "narrative": "The environment configuration specifies which Firestore project and region to use and enables storage locations for debug recordings.",
              "conceptIds": [
                "environment-configuration",
                "firestore-database",
                "debug-recording"
              ],
              "relationshipIds": [
                "environment-configuration-configures-firestore-database-project-region",
                "firestore-configured-by-environment",
                "environment-configuration-enables-debug-recording-storage",
                "debug-recording-uses-environment-configuration"
              ],
              "primaryConceptIds": [
                "firestore-database",
                "debug-recording"
              ],
              "primaryRelationshipIds": [
                "environment-configuration-configures-firestore-database-project-region"
              ]
            },
            {
              "id": "step-2-configure-cloud-task-queues-and-service-account",
              "index": 2,
              "title": "Configure Cloud Task queues and service account",
              "narrative": "The admin sets environment values that define which Cloud Task queue, region, and service account should be used for background job execution.",
              "conceptIds": [
                "environment-configuration",
                "cloud-task"
              ],
              "relationshipIds": [
                "environment-configuration-configures-cloud-task-queue",
                "environment-configuration-configures-cloud-task-service-account",
                "cloud-task-uses-environment-configuration"
              ],
              "primaryConceptIds": [
                "cloud-task"
              ],
              "primaryRelationshipIds": [
                "environment-configuration-configures-cloud-task-queue"
              ]
            },
            {
              "id": "step-3-configure-background-job-worker-endpoints-and-slack-integration",
              "index": 3,
              "title": "Configure background job worker endpoints and Slack integration",
              "narrative": "Environment configuration defines the HTTP endpoints that Cloud Tasks will call for background jobs and enables Slack integration for those jobs where needed.",
              "conceptIds": [
                "environment-configuration",
                "background-job"
              ],
              "relationshipIds": [
                "environment-configuration-configures-worker-endpoint-for-background-job",
                "environment-configuration-enables-background-job-slack-integration",
                "background-job-uses-environment-configuration"
              ],
              "primaryConceptIds": [
                "background-job"
              ],
              "primaryRelationshipIds": [
                "environment-configuration-configures-worker-endpoint-for-background-job"
              ]
            },
            {
              "id": "step-4-tune-logging-and-error-handling-behavior",
              "index": 4,
              "title": "Tune logging verbosity and error-handling strictness",
              "narrative": "The admin adjusts environment flags that influence logging context and verbosity, as well as how strictly errors are classified and surfaced across the system.",
              "conceptIds": [
                "environment-configuration",
                "logging",
                "error-handling"
              ],
              "relationshipIds": [
                "environment-configuration-influences-logging-context",
                "logging-is-shaped-by-environment-configuration",
                "environment-configuration-enables-error-handling-behavior",
                "rel-error-handling-uses-environment-configuration"
              ],
              "primaryConceptIds": [
                "logging",
                "error-handling"
              ],
              "primaryRelationshipIds": [
                "environment-configuration-enables-error-handling-behavior"
              ]
            },
            {
              "id": "step-5-verify-background-job-runtime-behavior",
              "index": 5,
              "title": "Verify background job runtime behavior under new configuration",
              "narrative": "A sample background job is run to confirm that it can connect to Firestore, enqueue and receive Cloud Tasks, and that logs, debug recordings, and error handling behave as configured.",
              "conceptIds": [
                "background-job",
                "cloud-task",
                "firestore-database",
                "logging",
                "debug-recording",
                "error-handling"
              ],
              "relationshipIds": [
                "background-job-uses-cloud-task",
                "cloud-task-triggers-background-job",
                "background-job-uses-firestore",
                "firestore-used-by-background-job",
                "background-job-uses-logging",
                "logging-is-used-by-background-job",
                "background-job-participates-in-debug-recording",
                "debug-recording-enables-background-job-observability",
                "rel-error-handling-enables-background-job"
              ],
              "primaryConceptIds": [
                "background-job"
              ],
              "primaryRelationshipIds": [
                "background-job-uses-cloud-task"
              ]
            }
          ]
        },
        {
          "id": "correlate-logs-and-debug-with-test-result",
          "name": "Correlate Logs and Debug Data with a Test Execution Result",
          "kind": "system_flow",
          "description": "A test execution result is examined alongside logs and debug recordings, all correlated via event envelope context and stored in Firestore.",
          "tags": [
            "observability",
            "test-execution-result"
          ],
          "focusConceptId": "test-execution-result",
          "steps": [
            {
              "id": "step-0-job-runs-with-rich-logging-and-debug",
              "index": 0,
              "title": "Background job runs with rich logging and debug recording",
              "narrative": "As a background job executes tests, it writes logs and emits debug events that are captured and stored in Firestore for later inspection.",
              "conceptIds": [
                "background-job",
                "logging",
                "debug-recording",
                "firestore-database"
              ],
              "relationshipIds": [
                "background-job-uses-logging",
                "logging-is-used-by-background-job",
                "background-job-participates-in-debug-recording",
                "debug-recording-enables-background-job-observability",
                "debug-recording-uses-firestore",
                "firestore-stores-llm-debug-events",
                "firestore-receives-debug-recording"
              ],
              "primaryConceptIds": [
                "background-job",
                "debug-recording"
              ],
              "primaryRelationshipIds": [
                "debug-recording-enables-background-job-observability"
              ]
            },
            {
              "id": "step-1-job-produces-test-execution-result-with-links",
              "index": 1,
              "title": "Job produces test execution result with links to debug data",
              "narrative": "When the job completes, it creates a test execution result that includes references to related logs and debug recordings, then stores it in Firestore.",
              "conceptIds": [
                "test-execution-result",
                "background-job",
                "firestore-database",
                "logging",
                "debug-recording"
              ],
              "relationshipIds": [
                "background-job-produces-test-execution-result",
                "rel-test-exec-result-produced-by-background-job",
                "rel-test-exec-result-stored-in-firestore",
                "firestore-stores-test-execution-result",
                "rel-test-exec-result-derived-from-background-job-logging",
                "logging-supports-test-execution-result",
                "rel-test-exec-result-linked-to-debug-recording",
                "debug-recording-enables-test-execution-result"
              ],
              "primaryConceptIds": [
                "test-execution-result"
              ],
              "primaryRelationshipIds": [
                "rel-test-exec-result-stored-in-firestore"
              ]
            },
            {
              "id": "step-2-use-event-envelope-context-to-correlate",
              "index": 2,
              "title": "Use event envelope context to correlate logs and debug",
              "narrative": "Event envelope identifiers stored with logs and debug recordings allow the system to correlate them back to the specific test execution result and originating job.",
              "conceptIds": [
                "event-envelope",
                "logging",
                "debug-recording",
                "test-execution-result"
              ],
              "relationshipIds": [
                "event-envelope-enables-logging-correlation",
                "logging-uses-event-envelope-context",
                "debug-recording-uses-event-envelope-context",
                "event-envelope-represents-slack-message-context",
                "rel-test-exec-result-linked-to-debug-recording"
              ],
              "primaryConceptIds": [
                "event-envelope"
              ],
              "primaryRelationshipIds": [
                "event-envelope-enables-logging-correlation"
              ]
            },
            {
              "id": "step-3-query-firestore-for-related-artifacts",
              "index": 3,
              "title": "Query Firestore for related logs and debug artifacts",
              "narrative": "A diagnostic tool or internal process queries Firestore for the test execution result and its associated debug recordings, using thread and correlation IDs to assemble a full picture.",
              "conceptIds": [
                "firestore-database",
                "test-execution-result",
                "debug-recording"
              ],
              "relationshipIds": [
                "firestore-stores-test-execution-result",
                "rel-test-exec-result-stored-in-firestore",
                "firestore-stores-llm-debug-events",
                "firestore-receives-debug-recording",
                "debug-recording-enables-test-execution-result"
              ],
              "primaryConceptIds": [
                "firestore-database"
              ],
              "primaryRelationshipIds": [
                "firestore-stores-test-execution-result"
              ]
            },
            {
              "id": "step-4-analyze-outcome-with-supporting-detail",
              "index": 4,
              "title": "Analyze test outcome with supporting detail",
              "narrative": "Engineers or automated tools review the test execution result alongside its logs and debug recordings to understand LLM behavior, diagnose issues, and refine tests.",
              "conceptIds": [
                "test-execution-result",
                "logging",
                "debug-recording"
              ],
              "relationshipIds": [
                "rel-test-exec-result-derived-from-background-job-logging",
                "logging-supports-test-execution-result",
                "rel-test-exec-result-linked-to-debug-recording",
                "debug-recording-enables-test-execution-result",
                "logging-coexists-with-debug-recording"
              ],
              "primaryConceptIds": [
                "test-execution-result"
              ],
              "primaryRelationshipIds": [
                "logging-supports-test-execution-result"
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "admin-and-observer-ui",
      "title": "Admin and Observer UI",
      "description": "How human operators view data requests, inspect LLM behavior, and manage templates and evaluations through a web interface.",
      "concepts": [
        {
          "id": "admin-user",
          "label": "Admin user",
          "category": "role",
          "description": "A person who uses the web UI to manage templates, tests, and to inspect data requests and LLM behavior.",
          "aliases": [
            "Admin user",
            "admin",
            "authenticated user",
            "Firebase auth user",
            "User"
          ],
          "notes": "An Admin user is a person who signs into the Admin and Observer UI (via Firebase/Google authentication) to manage templates and tests, and to inspect data requests and LLM behavior. In code, this is represented by the Firebase `User` object and is checked for authorization (e.g., `isAllowed`) before granting access to admin functionality."
        },
        {
          "id": "data-request-detail-view",
          "label": "Data request detail view",
          "category": "activity",
          "description": "Inspecting the full history, context, and outcomes of a single data request.",
          "aliases": [
            "DataRequestDetail",
            "DataRequestDetail.tsx",
            "Data request detail page",
            "Data request detail screen"
          ],
          "notes": "The data request detail view is a dedicated admin UI page/component that loads and displays all available information for a single data request, including Slack-formatted content, LLM responses (via LlmResponseTabs), and associated debug events. It is accessed via a route parameter (e.g., an ID) and relies on Firebase authentication and Firestore to fetch the underlying data."
        },
        {
          "id": "data-request-list-view",
          "label": "Data request list view",
          "category": "activity",
          "description": "Browsing and filtering multiple data requests to understand workload and status.",
          "aliases": [
            "DataRequestsList",
            "Data requests list",
            "Data requests list page",
            "Thread list",
            "ThreadDoc list"
          ],
          "notes": "The data request list view is a web UI page (DataRequestsList React component) that shows multiple Slack-based data request threads (ThreadDoc records) from Firestore. It is used by an authenticated admin user to browse, scan, and filter workload and status across many requests. Each row/card represents a single data request thread with metadata such as status, requester, channel, timestamps, and artifacts like request text and clarifying questions."
        },
        {
          "id": "llm-response-inspection",
          "label": "LLM response inspection",
          "category": "activity",
          "description": "Reviewing raw and parsed LLM responses, including XML or Slack-formatted content, to understand behavior.",
          "aliases": [
            "LLM response inspection",
            "LLM response viewer",
            "LLM response tabs",
            "XML response parser",
            "Slack markdown viewer",
            "Template variables tabs"
          ],
          "notes": "LLM response inspection is the activity of an admin user reviewing how an LLM responded to a data request, including both raw and structured views. The UI supports inspecting Slack-formatted markdown (via SlackMarkdown), XML-like structured responses (via XmlResponseParser), and related structured prompt/variable data (via TemplateVariablesTabs within LlmResponseTabs). It emphasizes understanding behavior by exposing raw content, parsed elements, and copyable artifacts such as prompts and variables."
        },
        {
          "id": "debug-events-view",
          "label": "Debug events view",
          "category": "activity",
          "description": "Viewing recorded debug events associated with LLM calls, tests, or data requests.",
          "aliases": [
            "Debug events view",
            "DebugEventsDisplay",
            "debug events display",
            "debug-events-view"
          ],
          "notes": "The debug events view is a UI component that presents a chronological list of recorded debug events related to a single data request, LLM call, or Slack interaction. It visualizes structured debug records such as LLM requests and responses, Slack messages, timing metrics, and thread creation. Within this view, specialized sub-views like LlmResponseTabs and TemplateVariablesTabs are used to inspect LLM prompts, responses, and template variables in more detail."
        },
        {
          "id": "authentication-session",
          "label": "Authentication session",
          "category": "state",
          "description": "The authenticated state of a user accessing the admin UI, managed via Firebase authentication.",
          "aliases": [
            "Authentication session",
            "Firebase auth session",
            "auth state",
            "authenticated state",
            "Firebase Authentication",
            "Google-authenticated session"
          ],
          "notes": "An authentication session represents the period during which an admin user is recognized as signed in to the Admin and Observer UI via Firebase Authentication, typically using a Google identity provider. It is backed by Firebase Auth (`getAuth(app)`) and a GoogleAuthProvider, and is required for accessing protected admin views such as data request lists, details, and debug events."
        }
      ],
      "relationships": [
        {
          "id": "admin-user-auth-session",
          "from": "admin-user",
          "to": "authentication-session",
          "phrase": "signs into",
          "category": "uses",
          "description": "An Admin user signs into the Admin and Observer UI, creating an authentication session managed by Firebase auth (e.g., via Google sign-in)."
        },
        {
          "id": "admin-user-views-data-request-list",
          "from": "admin-user",
          "to": "data-request-list-view",
          "phrase": "views",
          "category": "uses",
          "description": "An Admin user views the data request list view to browse and filter multiple data requests and understand workload and status."
        },
        {
          "id": "admin-user-views-data-request-detail",
          "from": "admin-user",
          "to": "data-request-detail-view",
          "phrase": "opens",
          "category": "uses",
          "description": "From the list, an Admin user opens a specific data request detail view to inspect its full history, context, and outcomes."
        },
        {
          "id": "admin-user-inspects-llm-responses",
          "from": "admin-user",
          "to": "llm-response-inspection",
          "phrase": "performs",
          "category": "uses",
          "description": "An Admin user performs LLM response inspection to review raw and parsed LLM responses associated with data requests, including Slack-formatted content."
        },
        {
          "id": "admin-user-views-debug-events",
          "from": "admin-user",
          "to": "debug-events-view",
          "phrase": "views",
          "category": "uses",
          "description": "An Admin user views the debug events view to inspect recorded debug events associated with LLM calls, tests, or data requests."
        },
        {
          "id": "admin-user-manages-templates",
          "from": "admin-user",
          "to": "template",
          "phrase": "manages",
          "category": "uses",
          "description": "An Admin user manages templates, including creating, editing, and tagging templates used to drive LLM behavior."
        },
        {
          "id": "admin-user-manages-template-versions",
          "from": "admin-user",
          "to": "template-version",
          "phrase": "creates and activates",
          "category": "uses",
          "description": "An Admin user creates new template versions and explicitly marks a version as active after review and testing."
        },
        {
          "id": "admin-user-runs-tests",
          "from": "admin-user",
          "to": "test-case",
          "phrase": "creates and runs",
          "category": "uses",
          "description": "An Admin user creates and runs test cases against templates to validate LLM behavior before activating new template versions."
        },
        {
          "id": "admin-user-reviews-test-results",
          "from": "admin-user",
          "to": "test-result",
          "phrase": "reviews",
          "category": "uses",
          "description": "An Admin user reviews test results to assess the impact of template changes on LLM behavior."
        },
        {
          "id": "data-request-detail-view-uses-auth-session",
          "from": "data-request-detail-view",
          "to": "authentication-session",
          "phrase": "relies on",
          "category": "uses",
          "description": "The data request detail view relies on an active authentication session to access Firestore data for a specific data request."
        },
        {
          "id": "data-request-detail-view-related-to-list-view",
          "from": "data-request-detail-view",
          "to": "data-request-list-view",
          "phrase": "is opened from",
          "category": "precedes",
          "description": "The data request detail view is typically opened from the data request list view when an admin selects a specific request."
        },
        {
          "id": "data-request-detail-view-enables-llm-inspection",
          "from": "data-request-detail-view",
          "to": "llm-response-inspection",
          "phrase": "enables",
          "category": "enables",
          "description": "The data request detail view enables LLM response inspection by embedding components such as LlmResponseTabs and SlackMarkdown to show raw and formatted LLM outputs for the selected data request."
        },
        {
          "id": "data-request-detail-view-uses-debug-events-view",
          "from": "data-request-detail-view",
          "to": "debug-events-view",
          "phrase": "includes",
          "category": "part_of",
          "description": "The data request detail view includes a debug events view to show DebugEvent records associated with the selected data request."
        },
        {
          "id": "admin-user-uses-data-request-detail-view",
          "from": "admin-user",
          "to": "data-request-detail-view",
          "phrase": "opens",
          "category": "uses",
          "description": "An admin user opens the data request detail view to inspect the full history, context, and outcomes of a single data request."
        },
        {
          "id": "rel-data-request-list-view-auth-session",
          "from": "data-request-list-view",
          "to": "authentication-session",
          "phrase": "relies on",
          "category": "uses",
          "description": "The data request list view relies on an active authentication session to determine the current user and whether they are allowed to see the list of data requests."
        },
        {
          "id": "rel-admin-user-views-data-request-list-view",
          "from": "admin-user",
          "to": "data-request-list-view",
          "phrase": "views",
          "category": "uses",
          "description": "An admin user opens the data request list view to browse and filter multiple data requests."
        },
        {
          "id": "rel-data-request-list-view-precedes-detail-view",
          "from": "data-request-list-view",
          "to": "data-request-detail-view",
          "phrase": "links to",
          "category": "precedes",
          "description": "From the data request list view, an admin user can follow a link for a specific request to open the corresponding data request detail view."
        },
        {
          "id": "rel-data-request-list-view-represents-threaddoc",
          "from": "data-request-list-view",
          "to": "data-request",
          "phrase": "lists",
          "category": "represents",
          "description": "Each entry shown in the data request list view represents a single data request (stored as a Firestore thread document with fields such as status, requester, channel, timestamps, and artifacts)."
        },
        {
          "id": "rel-data-request-list-view-uses-slack-markdown",
          "from": "data-request-list-view",
          "to": "llm-response-inspection",
          "phrase": "previews content related to",
          "category": "enables",
          "description": "The data request list view uses Slack-style markdown rendering for root messages and artifacts, providing a lightweight preview of content that can later be inspected in more depth via LLM response inspection in the detail view."
        },
        {
          "id": "rel-llm-inspection-uses-slack-markdown",
          "from": "llm-response-inspection",
          "to": "debug-events-view",
          "phrase": "renders Slack-formatted response content in",
          "category": "uses",
          "description": "During LLM response inspection, Slack-style markdown content from LLM responses is rendered as HTML within the debug or detail views using a SlackMarkdown component."
        },
        {
          "id": "rel-llm-inspection-uses-xml-parser",
          "from": "llm-response-inspection",
          "to": "debug-events-view",
          "phrase": "parses XML-like response content in",
          "category": "uses",
          "description": "During LLM response inspection, XML-like structured content from LLM responses is parsed and displayed in an expandable, structured form within the debug or detail views using an XmlResponseParser."
        },
        {
          "id": "rel-llm-inspection-uses-template-variables",
          "from": "llm-response-inspection",
          "to": "data-request-detail-view",
          "phrase": "shows prompt variables and final prompt within",
          "category": "uses",
          "description": "LLM response inspection includes viewing structured template variables and the final prompt associated with a data request, via tabbed views that allow expanding variables and copying values."
        },
        {
          "id": "rel-llm-inspection-represents-llm-behavior",
          "from": "llm-response-inspection",
          "to": "debug-events-view",
          "phrase": "represents observed LLM behavior through",
          "category": "represents",
          "description": "The inspection views represent how the LLM behaved for a given data request by exposing raw text, parsed XML elements, and Slack-formatted content within the debug events view."
        },
        {
          "id": "rel-debug-events-view-part-of-data-request-detail",
          "from": "debug-events-view",
          "to": "data-request-detail-view",
          "phrase": "is included in",
          "category": "part_of",
          "description": "The debug events view is shown as part of the data request detail view, providing low-level diagnostic information for a specific data request."
        },
        {
          "id": "rel-debug-events-view-used-by-admin-user",
          "from": "debug-events-view",
          "to": "admin-user",
          "phrase": "is viewed by",
          "category": "uses",
          "description": "Admin users open the debug events view to inspect detailed debug information about LLM behavior and Slack interactions."
        },
        {
          "id": "rel-debug-events-view-enables-llm-response-inspection",
          "from": "debug-events-view",
          "to": "llm-response-inspection",
          "phrase": "enables",
          "category": "enables",
          "description": "The debug events view provides the context and raw data (LLM request and response events) that the LLM response inspection tools use to display prompts, responses, and reasoning."
        },
        {
          "id": "rel-debug-events-view-represents-llm-calls",
          "from": "debug-events-view",
          "to": "llm-response-inspection",
          "phrase": "represents detailed LLM call timeline for",
          "category": "represents",
          "description": "The debug events view represents the sequence of LLM-related events (classification, request, response) that are then inspected in depth via LLM response inspection."
        },
        {
          "id": "rel-debug-events-view-represents-slack-interactions",
          "from": "debug-events-view",
          "to": "data-request-detail-view",
          "phrase": "represents Slack interaction history within",
          "category": "represents",
          "description": "The debug events view shows incoming Slack messages, outgoing Slack messages, and thread creation events that form the interaction history for a data request."
        },
        {
          "id": "rel-debug-events-view-uses-auth-session",
          "from": "debug-events-view",
          "to": "authentication-session",
          "phrase": "relies on",
          "category": "uses",
          "description": "Access to the debug events view is gated by the authenticated session, as it is part of the authenticated admin UI."
        },
        {
          "id": "auth-session-admin-user-holder",
          "from": "authentication-session",
          "to": "admin-user",
          "phrase": "identifies and authenticates",
          "category": "represents",
          "description": "An authentication session represents the currently signed-in admin user and proves their identity to the Admin and Observer UI."
        },
        {
          "id": "auth-session-enables-admin-ui-usage",
          "from": "authentication-session",
          "to": "admin-user",
          "phrase": "enables access for",
          "category": "enables",
          "description": "An authentication session enables an admin user to access protected areas of the Admin and Observer UI."
        },
        {
          "id": "auth-session-backs-data-request-list-view",
          "from": "authentication-session",
          "to": "data-request-list-view",
          "phrase": "backs access control for",
          "category": "enables",
          "description": "The authentication session underpins access control for the data request list view, ensuring only authenticated admin users can browse data requests."
        },
        {
          "id": "auth-session-backs-data-request-detail-view",
          "from": "authentication-session",
          "to": "data-request-detail-view",
          "phrase": "backs access control for",
          "category": "enables",
          "description": "The authentication session underpins access control for the data request detail view, ensuring only authenticated admin users can inspect detailed request histories."
        },
        {
          "id": "auth-session-backs-debug-events-view",
          "from": "authentication-session",
          "to": "debug-events-view",
          "phrase": "backs access control for",
          "category": "enables",
          "description": "The authentication session underpins access control for the debug events view, ensuring only authenticated admin users can see detailed LLM call timelines and Slack interaction history."
        },
        {
          "id": "auth-session-uses-firebase-auth",
          "from": "authentication-session",
          "to": "firebase-auth-service",
          "phrase": "is managed by",
          "category": "uses",
          "description": "Each authentication session is managed by the Firebase Authentication service created via `getAuth(app)`."
        },
        {
          "id": "auth-session-uses-google-provider",
          "from": "authentication-session",
          "to": "google-identity-provider",
          "phrase": "is established via",
          "category": "uses",
          "description": "Authentication sessions in the Admin and Observer UI are established via a Google identity provider (`GoogleAuthProvider`) configured in Firebase."
        },
        {
          "id": "auth-session-enables-firestore-access",
          "from": "authentication-session",
          "to": "firestore-database",
          "phrase": "authorizes access to",
          "category": "enables",
          "description": "The authentication session authorizes the admin UI to read and write data in Firestore (`getFirestore(app)`), subject to security rules."
        },
        {
          "id": "auth-session-enables-cloud-functions-access",
          "from": "authentication-session",
          "to": "cloud-functions-backend",
          "phrase": "authorizes calls to",
          "category": "enables",
          "description": "The authentication session authorizes the admin UI to invoke backend Cloud Functions (`getFunctions(app, region)`), which may enforce auth-based policies."
        }
      ],
      "rules": [
        {
          "id": "rule-admin-must-be-authenticated",
          "title": "Admin user must be authenticated to access admin UI",
          "text": "An Admin user must have an active authentication session (via Firebase auth) to access the Admin and Observer UI, including data request lists and template management screens.",
          "kind": "constraint",
          "conceptIds": [
            "admin-user",
            "authentication-session"
          ]
        },
        {
          "id": "rule-admin-must-be-authorized",
          "title": "Admin user must be authorized for admin features",
          "text": "Only Admin users that satisfy the system's authorization checks (e.g., being in an allowed list) may access admin functionality such as viewing data requests or managing templates.",
          "kind": "policy",
          "conceptIds": [
            "admin-user"
          ]
        },
        {
          "id": "rule-admin-activates-template-version-explicitly",
          "title": "Admin user must explicitly activate a template version",
          "text": "Saving changes to a template creates a new template version but does not automatically activate it. An Admin user must perform an explicit 'Make Active' action to deploy a template version after review and testing.",
          "kind": "policy",
          "conceptIds": [
            "admin-user"
          ]
        },
        {
          "id": "rule-data-request-detail-requires-auth",
          "title": "Data request detail view requires authentication",
          "text": "The data request detail view must only be accessible when there is a valid Firebase authentication session for the current user.",
          "kind": "constraint",
          "conceptIds": [
            "data-request-detail-view"
          ]
        },
        {
          "id": "rule-data-request-detail-identifies-request-by-id",
          "title": "Data request detail view is bound to a single request identifier",
          "text": "The data request detail view must be associated with exactly one data request, identified by a route or document identifier used to load its Firestore data.",
          "kind": "assumption",
          "conceptIds": [
            "data-request-detail-view"
          ]
        },
        {
          "id": "rule-data-request-list-view-requires-auth",
          "title": "Data request list view requires authenticated access",
          "text": "The data request list view is only available when there is a valid authentication session; if the user is not authenticated or not allowed, the list of data requests is not shown.",
          "kind": "policy",
          "conceptIds": [
            "data-request-list-view",
            "authentication-session"
          ]
        },
        {
          "id": "rule-data-request-list-view-reads-from-firestore",
          "title": "Data request list view is backed by Firestore thread documents",
          "text": "The data request list view obtains its contents from a Firestore collection of thread documents, each identified by a document ID and containing fields such as status, requester, channel, timestamps, and artifacts.",
          "kind": "assumption",
          "conceptIds": [
            "data-request-list-view"
          ]
        },
        {
          "id": "rule-data-request-list-view-status-values",
          "title": "Data request list view recognizes specific request statuses",
          "text": "The data request list view expects each listed data request to have an optional status field whose value, when present, is one of: processing, accepted, rejected, or unhandled.",
          "kind": "constraint",
          "conceptIds": [
            "data-request-list-view"
          ]
        },
        {
          "id": "rule-llm-inspection-xml-wrapper-skip",
          "title": "Skip XML response wrapper elements",
          "text": "When inspecting XML-like LLM responses, outer <response> wrapper elements are ignored so that only meaningful inner elements are shown to the admin user.",
          "kind": "invariant",
          "conceptIds": [
            "llm-response-inspection"
          ]
        },
        {
          "id": "rule-llm-inspection-xml-code-fence-cleanup",
          "title": "Clean XML code fences before parsing",
          "text": "When inspecting XML-like LLM responses, leading and trailing ```xml code block markers are removed before parsing so that the structured elements can be extracted.",
          "kind": "assumption",
          "conceptIds": [
            "llm-response-inspection"
          ]
        },
        {
          "id": "rule-llm-inspection-empty-xml-handling",
          "title": "Handle missing structured XML elements",
          "text": "If no structured XML elements are found in an LLM response, the inspection view must clearly indicate that no structured XML elements were detected.",
          "kind": "constraint",
          "conceptIds": [
            "llm-response-inspection"
          ]
        },
        {
          "id": "rule-llm-inspection-variable-expandability",
          "title": "Only expandable when content exists",
          "text": "In the template variables view used during LLM response inspection, a variable row is only expandable if its display value has non-zero length.",
          "kind": "constraint",
          "conceptIds": [
            "llm-response-inspection"
          ]
        },
        {
          "id": "rule-debug-events-are-structured",
          "title": "Debug events must be structured by type",
          "text": "Each debug event displayed in the debug events view must conform to one of the supported event shapes (e.g., time_to_react, llm_classification, thread_created, llm_request, llm_response, incoming_slack_message, outgoing_slack_message), each with a timestamp and a typed data payload.",
          "kind": "invariant",
          "conceptIds": [
            "debug-events-view"
          ]
        },
        {
          "id": "rule-debug-events-are-chronological",
          "title": "Debug events are interpreted as a timeline",
          "text": "Debug events in the debug events view are treated as a chronological sequence based on their timestamps, allowing admins to reconstruct the order of Slack messages, LLM calls, and system reactions.",
          "kind": "assumption",
          "conceptIds": [
            "debug-events-view"
          ]
        },
        {
          "id": "rule-debug-events-are-json-serializable",
          "title": "Debug event payloads must be JSON-serializable",
          "text": "The data payload of each debug event must be JSON-serializable so that it can be safely stored, transported, and rendered in the debug events view.",
          "kind": "constraint",
          "conceptIds": [
            "debug-events-view"
          ]
        },
        {
          "id": "auth-session-requires-firebase-auth",
          "title": "Authentication session must be backed by Firebase Authentication",
          "text": "Every authentication session in the Admin and Observer UI is created and managed through Firebase Authentication associated with the initialized Firebase app.",
          "kind": "invariant",
          "conceptIds": [
            "authentication-session"
          ]
        },
        {
          "id": "auth-session-requires-identity-provider",
          "title": "Authentication session must be established via a supported identity provider",
          "text": "An authentication session is only created when the admin user successfully authenticates via a configured identity provider, currently GoogleAuthProvider.",
          "kind": "constraint",
          "conceptIds": [
            "authentication-session"
          ]
        },
        {
          "id": "auth-session-required-for-protected-views",
          "title": "Authentication session required for protected admin views",
          "text": "Access to protected admin UI views such as data request list view, data request detail view, and debug events view requires a valid authentication session.",
          "kind": "policy",
          "conceptIds": [
            "authentication-session"
          ]
        },
        {
          "id": "auth-session-binds-to-single-user",
          "title": "Authentication session is bound to a single admin user identity",
          "text": "Each authentication session is associated with exactly one authenticated admin user identity at a time, as provided by Firebase Authentication.",
          "kind": "invariant",
          "conceptIds": [
            "authentication-session"
          ]
        }
      ],
      "lifecycles": [
        {
          "id": "lifecycle-data-request-detail-view-loading",
          "subjectConceptId": "data-request-detail-view",
          "stateConceptIds": [
            "data-request-detail-view-loading",
            "data-request-detail-view-loaded"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "data-request-detail-view-loading",
          "terminalStateIds": [
            "data-request-detail-view-loaded"
          ]
        },
        {
          "id": "auth-session-basic-lifecycle",
          "subjectConceptId": "authentication-session",
          "stateConceptIds": [
            "auth-session-unauthenticated",
            "auth-session-authenticated",
            "auth-session-expired-or-signed-out"
          ],
          "transitionRelationshipIds": [],
          "initialStateId": "auth-session-unauthenticated",
          "terminalStateIds": [
            "auth-session-expired-or-signed-out"
          ]
        }
      ],
      "views": [
        {
          "id": "admin-ui-access-control",
          "name": "Admin UI access and authentication",
          "kind": "overview",
          "description": "How an admin user signs in and how the authentication session enables access to admin UI views and backend services.",
          "conceptIds": [
            "admin-user",
            "authentication-session",
            "firebase-auth-service",
            "google-identity-provider",
            "firestore-database",
            "cloud-functions-backend",
            "data-request-list-view",
            "data-request-detail-view"
          ],
          "relationshipIds": [
            "admin-user-auth-session",
            "auth-session-admin-user-holder",
            "auth-session-enables-admin-ui-usage",
            "auth-session-uses-firebase-auth",
            "auth-session-uses-google-provider",
            "auth-session-enables-firestore-access",
            "auth-session-enables-cloud-functions-access",
            "auth-session-backs-data-request-list-view",
            "auth-session-backs-data-request-detail-view",
            "rel-data-request-list-view-auth-session"
          ]
        },
        {
          "id": "admin-browses-data-requests",
          "name": "Admin browsing and opening data requests",
          "kind": "lifecycle",
          "description": "How an admin user uses the list view to browse data requests and open a specific requestâ€™s detail view.",
          "conceptIds": [
            "admin-user",
            "authentication-session",
            "data-request-list-view",
            "data-request-detail-view",
            "llm-response-inspection",
            "debug-events-view",
            "data-request"
          ],
          "relationshipIds": [
            "admin-user-auth-session",
            "rel-admin-user-views-data-request-list-view",
            "rel-data-request-list-view-auth-session",
            "rel-data-request-list-view-represents-threaddoc",
            "rel-data-request-list-view-precedes-detail-view",
            "admin-user-views-data-request-detail",
            "data-request-detail-view-uses-auth-session",
            "data-request-detail-view-related-to-list-view",
            "data-request-detail-view-enables-llm-inspection",
            "data-request-detail-view-uses-debug-events-view"
          ]
        },
        {
          "id": "llm-behavior-inspection",
          "name": "Inspecting LLM behavior within a data request",
          "kind": "implementation",
          "description": "How the data request detail view, LLM response inspection, and debug events view work together to reveal LLM behavior.",
          "conceptIds": [
            "admin-user",
            "data-request-detail-view",
            "llm-response-inspection",
            "debug-events-view",
            "authentication-session",
            "data-request-list-view"
          ],
          "relationshipIds": [
            "admin-user-uses-data-request-detail-view",
            "data-request-detail-view-uses-auth-session",
            "data-request-detail-view-enables-llm-inspection",
            "data-request-detail-view-uses-debug-events-view",
            "rel-debug-events-view-part-of-data-request-detail",
            "rel-debug-events-view-used-by-admin-user",
            "rel-debug-events-view-enables-llm-response-inspection",
            "rel-debug-events-view-represents-llm-calls",
            "rel-llm-inspection-represents-llm-behavior",
            "rel-llm-inspection-uses-template-variables"
          ]
        },
        {
          "id": "llm-response-content-views",
          "name": "Views for LLM response content and formatting",
          "kind": "implementation",
          "description": "How Slack-formatted and XML-like LLM responses are previewed and parsed across list, detail, and debug views.",
          "conceptIds": [
            "data-request-list-view",
            "data-request-detail-view",
            "llm-response-inspection",
            "debug-events-view",
            "admin-user"
          ],
          "relationshipIds": [
            "rel-data-request-list-view-uses-slack-markdown",
            "rel-llm-inspection-uses-slack-markdown",
            "rel-llm-inspection-uses-xml-parser",
            "rel-llm-inspection-represents-llm-behavior",
            "rel-debug-events-view-represents-llm-calls",
            "rel-debug-events-view-represents-slack-interactions",
            "rel-debug-events-view-part-of-data-request-detail",
            "admin-user-inspects-llm-responses",
            "admin-user-views-debug-events"
          ]
        },
        {
          "id": "admin-manages-templates-and-tests",
          "name": "Admin management of templates and tests",
          "kind": "structure",
          "description": "How an admin user manages templates, template versions, and test cases and reviews their results via the admin UI.",
          "conceptIds": [
            "admin-user",
            "template",
            "template-version",
            "test-case",
            "test-result",
            "authentication-session"
          ],
          "relationshipIds": [
            "admin-user-auth-session",
            "auth-session-enables-admin-ui-usage",
            "admin-user-manages-templates",
            "admin-user-manages-template-versions",
            "admin-user-runs-tests",
            "admin-user-reviews-test-results"
          ]
        }
      ],
      "storyViews": [
        {
          "id": "admin-signs-in-and-reviews-recent-data-requests",
          "name": "Admin signs in and reviews recent data requests",
          "kind": "user_flow",
          "description": "An admin authenticates into the UI and scans the recent workload using the data request list, then drills into a specific request.",
          "tags": [
            "authentication",
            "list-view",
            "overview"
          ],
          "focusConceptId": "data-request-list-view",
          "steps": [
            {
              "id": "admin-initiates-authentication",
              "index": 0,
              "title": "Admin initiates authentication",
              "narrative": "The admin user opens the admin UI and is prompted to sign in using their Google account, which starts an authentication session managed by Firebase.",
              "conceptIds": [
                "admin-user",
                "authentication-session"
              ],
              "relationshipIds": [
                "admin-user-auth-session",
                "auth-session-admin-user-holder",
                "auth-session-uses-firebase-auth",
                "auth-session-uses-google-provider"
              ],
              "primaryConceptIds": [
                "admin-user",
                "authentication-session"
              ],
              "primaryRelationshipIds": [
                "admin-user-auth-session"
              ]
            },
            {
              "id": "auth-session-enables-admin-ui-access",
              "index": 1,
              "title": "Authentication session enables UI access",
              "narrative": "Once authenticated, the session identifies the admin and authorizes access to Firestore and Cloud Functions so the UI can load data request metadata.",
              "conceptIds": [
                "authentication-session",
                "admin-user"
              ],
              "relationshipIds": [
                "auth-session-enables-admin-ui-usage",
                "auth-session-enables-firestore-access",
                "auth-session-enables-cloud-functions-access"
              ],
              "primaryConceptIds": [
                "authentication-session"
              ],
              "primaryRelationshipIds": [
                "auth-session-enables-admin-ui-usage"
              ]
            },
            {
              "id": "admin-opens-data-request-list",
              "index": 2,
              "title": "Admin opens the data request list view",
              "narrative": "The admin navigates to the data request list view, which relies on the active authentication session to query and display recent data requests.",
              "conceptIds": [
                "admin-user",
                "data-request-list-view",
                "authentication-session"
              ],
              "relationshipIds": [
                "rel-admin-user-views-data-request-list-view",
                "rel-data-request-list-view-auth-session",
                "auth-session-backs-data-request-list-view"
              ],
              "primaryConceptIds": [
                "data-request-list-view"
              ],
              "primaryRelationshipIds": [
                "rel-admin-user-views-data-request-list-view"
              ]
            },
            {
              "id": "admin-scans-and-filters-requests",
              "index": 3,
              "title": "Admin scans and filters recent requests",
              "narrative": "Within the list view, the admin browses and filters data requests, seeing high-level status and previews of LLM-related content to decide which request needs deeper inspection.",
              "conceptIds": [
                "admin-user",
                "data-request-list-view",
                "llm-response-inspection"
              ],
              "relationshipIds": [
                "rel-data-request-list-view-represents-threaddoc",
                "rel-data-request-list-view-uses-slack-markdown"
              ],
              "primaryConceptIds": [
                "data-request-list-view"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-list-view-represents-threaddoc"
              ]
            },
            {
              "id": "admin-drills-into-specific-request",
              "index": 4,
              "title": "Admin drills into a specific data request",
              "narrative": "After identifying an interesting request, the admin clicks it in the list, which opens the data request detail view for that specific item.",
              "conceptIds": [
                "admin-user",
                "data-request-list-view",
                "data-request-detail-view"
              ],
              "relationshipIds": [
                "rel-data-request-list-view-precedes-detail-view",
                "data-request-detail-view-related-to-list-view",
                "admin-user-views-data-request-detail"
              ],
              "primaryConceptIds": [
                "data-request-detail-view"
              ],
              "primaryRelationshipIds": [
                "rel-data-request-list-view-precedes-detail-view"
              ]
            }
          ]
        },
        {
          "id": "admin-inspects-llm-behavior-for-a-problematic-request",
          "name": "Admin inspects LLM behavior for a problematic request",
          "kind": "user_flow",
          "description": "An admin uses the detail view, debug events, and LLM response inspection to understand why a particular data request behaved unexpectedly.",
          "tags": [
            "llm",
            "debugging",
            "detail-view"
          ],
          "focusConceptId": "llm-response-inspection",
          "steps": [
            {
              "id": "admin-opens-problem-request-detail",
              "index": 0,
              "title": "Admin opens the problematic data request detail",
              "narrative": "From the list of data requests, the admin opens the detail view for a request that produced an unexpected result, with access backed by the current authentication session.",
              "conceptIds": [
                "admin-user",
                "data-request-detail-view",
                "data-request-list-view",
                "authentication-session"
              ],
              "relationshipIds": [
                "admin-user-uses-data-request-detail-view",
                "data-request-detail-view-related-to-list-view",
                "data-request-detail-view-uses-auth-session",
                "auth-session-backs-data-request-detail-view"
              ],
              "primaryConceptIds": [
                "data-request-detail-view"
              ],
              "primaryRelationshipIds": [
                "admin-user-uses-data-request-detail-view"
              ]
            },
            {
              "id": "admin-reviews-slack-interaction-history",
              "index": 1,
              "title": "Admin reviews Slack interaction and debug history",
              "narrative": "Within the detail view, the admin scrolls through the embedded debug events view to see the Slack interaction history and the sequence of system events for this request.",
              "conceptIds": [
                "data-request-detail-view",
                "debug-events-view",
                "admin-user"
              ],
              "relationshipIds": [
                "data-request-detail-view-uses-debug-events-view",
                "rel-debug-events-view-part-of-data-request-detail",
                "rel-debug-events-view-represents-slack-interactions",
                "rel-debug-events-view-used-by-admin-user"
              ],
              "primaryConceptIds": [
                "debug-events-view"
              ],
              "primaryRelationshipIds": [
                "data-request-detail-view-uses-debug-events-view"
              ]
            },
            {
              "id": "admin-focuses-on-llm-call-timeline",
              "index": 2,
              "title": "Admin focuses on the LLM call timeline",
              "narrative": "The admin filters the debug events to highlight LLM calls, using the debug events view to see a detailed timeline of prompts, retries, and responses.",
              "conceptIds": [
                "debug-events-view",
                "llm-response-inspection",
                "admin-user"
              ],
              "relationshipIds": [
                "rel-debug-events-view-enables-llm-response-inspection",
                "rel-debug-events-view-represents-llm-calls"
              ],
              "primaryConceptIds": [
                "debug-events-view"
              ],
              "primaryRelationshipIds": [
                "rel-debug-events-view-represents-llm-calls"
              ]
            },
            {
              "id": "admin-inspects-raw-llm-response",
              "index": 3,
              "title": "Admin inspects raw and formatted LLM responses",
              "narrative": "Using the LLM response inspection tools, the admin reviews raw XML-like content and Slack-formatted messages rendered from the debug events to understand exactly what the model returned.",
              "conceptIds": [
                "llm-response-inspection",
                "debug-events-view",
                "admin-user"
              ],
              "relationshipIds": [
                "rel-llm-inspection-uses-slack-markdown",
                "rel-llm-inspection-uses-xml-parser",
                "rel-llm-inspection-represents-llm-behavior"
              ],
              "primaryConceptIds": [
                "llm-response-inspection"
              ],
              "primaryRelationshipIds": [
                "rel-llm-inspection-represents-llm-behavior"
              ]
            },
            {
              "id": "admin-compares-prompts-and-variables",
              "index": 4,
              "title": "Admin compares prompts and variables to outcomes",
              "narrative": "The admin examines the prompt variables and final prompt shown within the data request detail view, correlating them with the inspected LLM responses to pinpoint where behavior diverged from expectations.",
              "conceptIds": [
                "llm-response-inspection",
                "data-request-detail-view",
                "admin-user"
              ],
              "relationshipIds": [
                "rel-llm-inspection-uses-template-variables",
                "data-request-detail-view-enables-llm-inspection"
              ],
              "primaryConceptIds": [
                "llm-response-inspection",
                "data-request-detail-view"
              ],
              "primaryRelationshipIds": [
                "rel-llm-inspection-uses-template-variables"
              ]
            }
          ]
        },
        {
          "id": "auth-session-lifecycle-across-views",
          "name": "Authentication session lifecycle across views",
          "kind": "system_flow",
          "description": "A system-level view of how a single authentication session underpins access to list, detail, and debug views during an adminâ€™s visit.",
          "tags": [
            "authentication",
            "system",
            "access-control"
          ],
          "focusConceptId": "authentication-session",
          "steps": [
            {
              "id": "session-created-via-google-and-firebase",
              "index": 0,
              "title": "Session is created via Google and Firebase",
              "narrative": "When the admin signs in, Firebase Auth and the Google identity provider establish an authentication session that represents the adminâ€™s identity.",
              "conceptIds": [
                "authentication-session",
                "admin-user"
              ],
              "relationshipIds": [
                "admin-user-auth-session",
                "auth-session-admin-user-holder",
                "auth-session-uses-firebase-auth",
                "auth-session-uses-google-provider"
              ],
              "primaryConceptIds": [
                "authentication-session"
              ],
              "primaryRelationshipIds": [
                "admin-user-auth-session"
              ]
            },
            {
              "id": "session-enables-backend-access",
              "index": 1,
              "title": "Session enables backend access",
              "narrative": "The authentication session authorizes the admin UI to read from Firestore and call Cloud Functions, preparing it to load data requests and debug information.",
              "conceptIds": [
                "authentication-session",
                "admin-user"
              ],
              "relationshipIds": [
                "auth-session-enables-admin-ui-usage",
                "auth-session-enables-firestore-access",
                "auth-session-enables-cloud-functions-access"
              ],
              "primaryConceptIds": [
                "authentication-session"
              ],
              "primaryRelationshipIds": [
                "auth-session-enables-firestore-access"
              ]
            },
            {
              "id": "session-backs-data-request-list-view",
              "index": 2,
              "title": "Session backs the data request list view",
              "narrative": "When the admin opens the data request list view, the view relies on the active session, which backs its access control and determines which data requests can be listed.",
              "conceptIds": [
                "authentication-session",
                "data-request-list-view",
                "admin-user"
              ],
              "relationshipIds": [
                "rel-data-request-list-view-auth-session",
                "auth-session-backs-data-request-list-view",
                "rel-admin-user-views-data-request-list-view"
              ],
              "primaryConceptIds": [
                "authentication-session",
                "data-request-list-view"
              ],
              "primaryRelationshipIds": [
                "auth-session-backs-data-request-list-view"
              ]
            },
            {
              "id": "session-backs-detail-and-debug-views",
              "index": 3,
              "title": "Session backs detail and debug views",
              "narrative": "As the admin navigates into a specific data request, the same authentication session backs access to the detail view and its embedded debug events view.",
              "conceptIds": [
                "authentication-session",
                "data-request-detail-view",
                "debug-events-view"
              ],
              "relationshipIds": [
                "auth-session-backs-data-request-detail-view",
                "auth-session-backs-debug-events-view",
                "data-request-detail-view-uses-auth-session",
                "rel-debug-events-view-uses-auth-session"
              ],
              "primaryConceptIds": [
                "authentication-session"
              ],
              "primaryRelationshipIds": [
                "auth-session-backs-data-request-detail-view"
              ]
            },
            {
              "id": "session-persists-through-llm-inspection",
              "index": 4,
              "title": "Session persists through LLM inspection",
              "narrative": "Throughout LLM response inspection and navigation between list and detail views, the same authentication session continues to authorize all data and debug event retrieval until it expires or the admin signs out.",
              "conceptIds": [
                "authentication-session",
                "llm-response-inspection",
                "data-request-detail-view",
                "debug-events-view"
              ],
              "relationshipIds": [
                "data-request-detail-view-enables-llm-inspection",
                "rel-debug-events-view-enables-llm-response-inspection"
              ],
              "primaryConceptIds": [
                "authentication-session"
              ],
              "primaryRelationshipIds": []
            }
          ]
        },
        {
          "id": "admin-uses-debug-events-to-verify-llm-evaluation",
          "name": "Admin uses debug events to verify LLM evaluation",
          "kind": "user_flow",
          "description": "An admin leverages the debug events view and LLM response inspection to verify that an LLM evaluation ran as expected for a given data request.",
          "tags": [
            "debug-events",
            "llm",
            "verification"
          ],
          "focusConceptId": "debug-events-view",
          "steps": [
            {
              "id": "admin-navigates-to-request-detail-for-evaluation",
              "index": 0,
              "title": "Admin navigates to request detail for evaluation",
              "narrative": "After identifying a request associated with a recent evaluation, the admin opens its data request detail view from the list.",
              "conceptIds": [
                "admin-user",
                "data-request-list-view",
                "data-request-detail-view"
              ],
              "relationshipIds": [
                "rel-admin-user-views-data-request-list-view",
                "rel-data-request-list-view-precedes-detail-view",
                "admin-user-uses-data-request-detail-view"
              ],
              "primaryConceptIds": [
                "data-request-detail-view"
              ],
              "primaryRelationshipIds": [
                "admin-user-uses-data-request-detail-view"
              ]
            },
            {
              "id": "admin-opens-debug-events-section",
              "index": 1,
              "title": "Admin opens the debug events section",
              "narrative": "Within the detail view, the admin expands the debug events view, which is included as part of the request detail to show all recorded events.",
              "conceptIds": [
                "data-request-detail-view",
                "debug-events-view",
                "admin-user"
              ],
              "relationshipIds": [
                "data-request-detail-view-uses-debug-events-view",
                "rel-debug-events-view-part-of-data-request-detail",
                "rel-debug-events-view-used-by-admin-user"
              ],
              "primaryConceptIds": [
                "debug-events-view"
              ],
              "primaryRelationshipIds": [
                "data-request-detail-view-uses-debug-events-view"
              ]
            },
            {
              "id": "admin-filters-for-llm-evaluation-events",
              "index": 2,
              "title": "Admin filters for LLM evaluation events",
              "narrative": "The admin filters the debug events to focus on LLM-related calls, using the detailed LLM call timeline to confirm when and how the evaluation ran.",
              "conceptIds": [
                "debug-events-view",
                "llm-response-inspection"
              ],
              "relationshipIds": [
                "rel-debug-events-view-enables-llm-response-inspection",
                "rel-debug-events-view-represents-llm-calls"
              ],
              "primaryConceptIds": [
                "debug-events-view"
              ],
              "primaryRelationshipIds": [
                "rel-debug-events-view-represents-llm-calls"
              ]
            },
            {
              "id": "admin-inspects-evaluation-responses",
              "index": 3,
              "title": "Admin inspects evaluation responses",
              "narrative": "Using LLM response inspection, the admin reviews the raw and Slack-formatted responses associated with the evaluation to ensure the scoring or behavior matches expectations.",
              "conceptIds": [
                "llm-response-inspection",
                "debug-events-view",
                "admin-user"
              ],
              "relationshipIds": [
                "rel-llm-inspection-uses-slack-markdown",
                "rel-llm-inspection-uses-xml-parser",
                "rel-llm-inspection-represents-llm-behavior"
              ],
              "primaryConceptIds": [
                "llm-response-inspection"
              ],
              "primaryRelationshipIds": [
                "rel-llm-inspection-represents-llm-behavior"
              ]
            },
            {
              "id": "admin-correlates-evaluation-with-request-context",
              "index": 4,
              "title": "Admin correlates evaluation with request context",
              "narrative": "Finally, the admin cross-checks the inspected LLM behavior with the broader request context in the detail view, confirming that the evaluation ran on the intended inputs and Slack interaction history.",
              "conceptIds": [
                "data-request-detail-view",
                "llm-response-inspection",
                "debug-events-view"
              ],
              "relationshipIds": [
                "rel-llm-inspection-uses-template-variables",
                "rel-debug-events-view-represents-slack-interactions"
              ],
              "primaryConceptIds": [
                "data-request-detail-view"
              ],
              "primaryRelationshipIds": [
                "rel-debug-events-view-represents-slack-interactions"
              ]
            }
          ]
        }
      ]
    }
  ]
}